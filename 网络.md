by：2021dragon

# 网络基础

## 网络发展

- 独立模式：计算机之间相互独立

    > 计算机之间是相互独立的，如果多个计算机要协同完成某种业务，那么就只能等一台计算机处理完后再将数据传递给下一台计算机，然后下一台计算机再进行相应的业务处理，效率非常低下。

    ![image-20230328090302751](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328090302751.png)

- 网络互联： 多台计算机连接在一起

    > 将这些计算机连接在一起，当某个业务需要多台计算机协同完成时，可以将共享的数据放到服务器中进行集中管理，此时各个计算机就都能获取到这些共享的数据，所以各个业务在处理就能随时进行切换了。

    ![image-20230328090312365](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328090312365.png)

- 局域网LAN：计算机数量更多了, 通过交换机和路由器连接在一起

    > 后来这样的网络雏形逐渐发展，连入这个网络中的机器变得越来越多，于是就出现了局域网。
    >
    > 在局域网中有一种设备叫做交换机，**交换机主要完成局域网内数据的转发工作**，也就是在局域网内将数据从一台主机转发给另一台主机。各个局域网之间通过路由器连接起来，**路由器主要完成数据的路由转发工作**。

    ![image-20230328090735409](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328090735409.png)

- 广域网WAN：将远隔千里的计算机都连在一起

    > 各个局域网之间通过路由器相互连接在一起，便组成了一个更大的网络结构，我们将其称之为广域网。实际局域网和广域网是一种相对的概念，我们也**可以将广域网看作一个比较大的局域网**。

    ![image-20230328090801965](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328090801965.png)



城域网和校园网：城域网实际就是在一个城市范围内所建立的计算机通信网，而校园网对应的就是在一个校园范围内所建立的计算机通信网。**城域网和校园网实际也是一种相对的概念，我们都可以将它们看作一个大的局域网。**

## 认识协议

> 协议：参与各方**约定**好的规则

“协议”本质就是一种约定，通信双方协商好某种约定，之后就可以使用这种约定来完成某种事情。而网络协议是通信计算机双方必须共同遵从的一组约定。

比如通信计算机双方曾经做过如下约定：

- 如果code的值为1，则表示需要将data的值存储进数据库。
- 如果code的值为2，则表示需要将data的值写入日志信息。
- 如果code的值为3，则表示需要将data的值进行打印输出。

![fb75ddbbc8c546c9918e81315dfa2774](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/fb75ddbbc8c546c9918e81315dfa2774.png)

我们可以通过**位段**来表示上述协议规定，而实际上计算机网络里面的协议报头也就是通过位段来实现的。

我们有了这样的约定后，当甲计算机向乙计算机发送类似于{1, 0x1234}的数据时，乙计算机识别到code的值是1，于是就知道了甲计算机是让自己将data的值存储进数据库，这是一种纯软件的约定方案。

另外我们知道计算机之间的传输媒介是光信号和电信号，通过“频率”和“强弱”来表示0和1这样的信息，因此要想传递各种不同的信息，就需要约定好双方的数据格式，这就是一种纯硬件的一种约定方案。

## 网络协议栈

互联网发展到现在，已经存在了许多经过验证的可靠的网络协议，我们先不谈其细节，而是**认识这些网络协议在整个网络通信中的位置和作用，这就是网络协议栈。**

### 协议分层

> 网络协议栈设计成层状结构，其目的就是为了将层与层之间进行**解耦**，保证代码的可维护性和可扩展性。

比如在打电话的时候，站在工程师的角度实际这两个人并不是直接进行沟通的，而是甲的电话将甲说的话记录下来，经过一系列编码转码后，通过通信网络将信息从甲的电话传递到了乙的电话，然后信息在乙的电话中再经过对应的编码转码，最后乙才通过话筒听到了甲所说的话。

其中，人与人之间通信使用的是汉语，我们可以将其称为语言层；而电话和电话之间通信使用的是电话系统相关的一些接口，我们可以将其称之为通信设备层。**这样，当语言层从英语变成汉语时，通信设备层仍然可以继续使用**。

**协议分层使各协议层不需要关心其他层如何实现的，而是认为是“通信只在本层进行”。**

![image-20230328095856321](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328095856321.png)

### OSI七层模型

- OSI（Open System Interconnection，开放系统互联）七层网络模型称为开方式系统互联参考模型，是一个逻辑上的定义和规范。
- OSI把网络从逻辑上分为了七层，每一层都有相关的、相对应的物理设备，比如路由器，交换机。
- OSI七层模型是一种框架性的设计方法，其最主要的功能就是帮助不同类型的主机实现数据传输，比如手机和电视之间数据的传输。
- OSI七层模型最大的优点是将服务、接口和协议这三个概念明确地区分开来，概念清楚，理论也比较完整，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯。
- 但是，OSI七层模型既复杂又不实用，所以后来在具体实现的时候就对其进行了调整，于是就有了我们现在看到的TCP/IP四层协议。

OSI七层模型如下：

![image-20230328105049447](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328105049447.png)

### TCP/IP五层模型

> TCP/IP是一组协议的代名词，它还包括许多协议，共同组成了TCP/IP协议簇。TCP/IP通讯协议采用了五层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。

- **物理层：** **负责光/电信号的传递方式**。比如现在以太网通用的网线（双绞线）、早期以太网采用的同轴电缆（现在主要用于有线电视）、光纤，现在的WiFi无线网使用的电磁波等都属于物理层的概念。物理层的能力决定了最大传输速率、传输距离、抗干扰性等。**集线器（Hub）就是工作在物理层的**。
- **数据链路层：** **负责设备之间的数据帧的传送和识别**。例如网卡设备的驱动、帧同步、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。数据链路层底层的网络通信标准有很多，如以太网、令牌环网、无线LAN等。**交换机（Switch）就是工作在数据链路层的**。
- **网络层：** **负责地址管理和路由选择**。例如在IP协议中，通过IP地址来标识一台主机，并通过路由表的方式规划出两台主机之间数据传输的线路（路由）。**路由器（Router）就是工作在网络层的**。
- **传输层：** **负责两台主机之间的数据传输**。例如传输控制协议（TCP），能够确保数据可靠的从源主机发送到目标主机。
- **应用层：** **负责应用程序间沟通**。比如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。我们的网络编程主要就是针对应用层的。

与OSI七层模型各层的对应关系：

![image-20230328100432678](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328100432678.png)

物理层我们考虑的比较少. 因此很多时候也可以称为 TCP/IP四层模型.

一般而言：

> - 对于一台主机, 它的**操作系统内核实现了从传输层到物理层的内容**; 
> - 对于一台**路由器, 它实现了从网络层到物理层**; 
> - 对于一台**交换机, 它实现了从数据链路层到物理层**; 
> - 对于**集线器, 它只实现了物理层**；
> - 但是并不绝对. 很多交换机也实现了网络层的转发; 很多路由器也实现了部分传输层的内容(比如端口转发)。

[OSI与TCP/IP](http://blog.csdn.net/superjunjin/article/details/7841099)

## 网络传输基本流程

网络协议栈：

![image-20230328101426811](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328101426811.png)

- **同局域网的两台主机通信**

    首先需要明确的是，同一个局域网内的主机是能够直接进行通信的，因为最初局域网设计的目的，就是为了让局域网内的主机能够进行通信。

    ![image-20230328102457236](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328102457236.png)

    当用户要将文件传输给另一台主机前，该文件数据需要先通过网络协议栈进行封装：

    - 文件数据先交给应用层，应用层添加上对应应用层协议的报头信息后，将数据再交给传输层。
    - 传输层收到数据后，再添加上对应传输层协议的报头信息，并将数据继续向下进行交付。
    - 网络层收到数据后，再添加上对应网络层协议的报头信息，接着将数据再交给链路层。
    - 链路层收到数据后，最后再添加上对应链路层协议的报头信息，至此数据封装完毕。

    而当对端主机收到数据后，对应也需要通过网络协议栈对该数据进行解包与分用：

    - 链路层收到数据后，先将数据中对应链路层协议的报头信息提取出来，然后将剩下的数据交给网络层。
    - 网络层收到该数据后，再将数据中对应网络层协议的报头信息提取出来，然后将剩下的数据继续向上进行交付。
    - 传输层收到该数据后，再将数据中对应传输层协议的报头信息提取出来，然后将剩下的数据再交付给应用层。
    - 应用层收到数据后，最后将数据中对应应用层协议的报头信息提取出来，至此便完成了数据的解包与分用。

    > 也就是说，任何一台主机在发送数据之前，该数据都要先自顶向下贯穿协议栈来完成数据的封装，在这个过程中，每一层协议都会添加上对应的报头信息；而任何一台主机收到数据后，都要先自底向上贯穿协议栈来完成数据的解包和分用，在这个过程中，每一层协议都会将对应的报头信息提取出来。

- **不同局域网的两台主机通信**

    局域网之间都是通过路由器连接起来的，因此一个路由器至少能够横跨两个局域网。而这些被路由器级联局域网都认为，该路由器就是本局域网内的一台主机，因此路由器可以和这些局域网内的任意一台主机进行直接通信。
    
    比如局域网1当中的主机A想要和局域网2当中的主机H进行通信，那么主机A可以先将数据发送给路由器，然后路由器再将数据转发给局域网2当中的主机H。
    
    ![image-20230328112519728](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328112519728.png)
    
    由于以太网和令牌环网是不同的通信标准，它们给数据添加的报头也是不一样的，因此令牌环网当中的主机无法对以太网当中的数据帧进行解包。
    
    这种情况实际是由路由器来处理的，路由器是工作在网络层的一个设备，我们可以认为路由器当中的协议栈是下面这样的。
    
    ![image-20230328112540319](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328112540319.png)
    
    此时当数据要从局域网1发送到局域网2时，路由器收到局域网1的数据后，会先将以太网对应的报头进行解包，然后将剩下的数据向上交付给网络层，在网络层进行一系列数据分析后，再将数据向下交付给链路层，此时在链路层当中就会给该数据添加上令牌环对应的报头信息，然后再将该数据发送到局域网2当中，此时该数据就能够在令牌环网当中传输了。
    
    ![image-20230328102804677](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328102804677.png)
    
- 其他

    **路由器为什么能够“认路”？**

    > 一个路由器可能会级联多个局域网，当路由器需要将一个局域网的数据转发到另一个局域网时，路由器如何知道该数据应该转发到哪一个局域网的呢？
    >
    > 路由器其实是通过IP地址来确定数据的转发方向的，因特网上的每台计算机都有一个唯一的IP地址，而在数据向下进行封装时，在网络层封装的报头当中就会包含两个字段，分别是源IP地址和目的IP地址。
    >
    > 当路由器需要将一个局域网的数据转发到另一个局域网时，在路由器的链路层会先将数据的在当前局域网对应的底层报头(链路层协议报头)去掉，然后将剩下的数据向上交付给网络层，此时在网络层就可以获取到该数据对应的目的IP地址，然后路由器就可以根据该IP地址在路由表当中进行查找，最终就能够确认该数据应该发送到哪一个局域网。

    **屏蔽底层的差异**

    > IP地址的存在除了帮助数据“路由”以外，还有一个很重要的作用，那就是屏蔽了底层网络的差异。对于通信主机双方的IP层及其往上的协议来说，它们并不需要关心底层采用的是以太网还是令牌环网，它们认为只要填写了源IP地址和目的IP地址就能够将数据发送出去，因此现在主流的网络也叫做“IP网络”。

## 数据包封装和分用

### 封装与分用

- 不同协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。
- 应用层数据通过协议栈发到网络上，每层协议都要加上一个数据首部（header），称为封装（Encapsulation）。
- 首部信息中包含了一些类似于首部有多长，载荷（payload）有多长，上层协议是什么等信息。
- 数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，根据首部中的“上层协议字段”将数据交给对应的上层协议处理。

**下图为数据封装的过程：**

![image-20230328102918376](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328102918376.png)

**下图为数据分用的过程：**

![image-20230328102937455](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328102937455.png)

### 报头处理

**什么是报头**

> 报头本质也是一种数据，报头一般是通过位段实现的，因此协议栈的每一层都有一个对应的位段来表示当前层的报头。
>
> 数据的封装与解包：
>
> - 数据封装，实际就是不断给数据加上各种对应的报头，这些报头里面填充的就是对应的各种协议细节。
> - 数据解包，实际就是不断从数据中提取对应的报头，并对提取出来的报头进行数据分析。
>
> **可以认为，报头就是各个协议的实现的载体，通过对报头的解析实现具体协议。**

**报头与有效载荷**

> 当对端主机收到数据后，需要自底向上贯穿协议栈，依次进行数据的解包与分用。在这个解包的过程中，每一层的协议只需要提取出数据中对应的报头，然后对该报头进行分析处理，而剩下的数据则直接交付给上层就行了。
>
> 因为每一层的协议实际上只关心数据中与当前层对应的报头信息，而剩下信息的具体内容根本不必关心，我们**将数据中除当前层的报头以外的数据叫做“有效载荷”**。
>
> 需要注意的是，上层协议在数据封装时添加的报头信息，在下层协议进行数据解包时看来就是有效载荷。比如数据封装时应用层添加的报头信息，在对端主机进行数据解包时，在对端主机的传输层、网络层以及链路层看来，该应用层曾经添加的报头信息就是有效载荷。

**如何将报头与有效载荷进行分离？**

> 协议栈的每一层都要从数据中提取对应的报头信息，而要将数据中的报头提取出来，首先就需要明确报头与有效载荷之间的界限，这样才能将它们进行分离。而每一层添加报头时都是将报头添加到数据的首部的，因此我们只要知道了报头的大小，就能够讲报头和有效载荷进行分离。
>
> 获取报头大小的方法通常有两种：
>
> - **定长报头。**顾名思义就是报头的大小是固定的。
> - **自描述字段。**报头当中提供了一个字段，用来表示报头的长度，即变长报头。
>
> 实际上每个协议都要提供一种方法，让我们获取到报头的大小，这样我们才能在解包时将报头与有效载荷进行分离。

**当前层如何知道应该将有效载荷交付给上层的哪个协议？**

> 网络协议栈的每一层都可能会对应多种协议，即便将报头与有效载荷分离了，那当前层应该将有效载荷交付给上层对应的哪个协议呢？
>
> 实际在每种协议的报头当中，几乎都会包含一个字段，表明我们应该把分离出来的有效载荷交付给上层的哪个协议，这就是分用的过程。

## 局域网通信

### 通信方式

在一个局域网当中，除了当前正在进行通信的A主机和B主机以外，还有其他的主机，那A主机是如何将数据成功发送给B主机的呢？

![image-20230328105654163](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328105654163.png)

实际当主机A想要发数据给主机B的时候，该局域网内的其他主机也都收到了该数据，只不过除了主机B以外，其他主机识别到该数据并不是发给自己的，此时其他主机就把收到的数据丢弃了。也就是说，在局域网（以太网）通信时，该**局域网内所有的主机在底层其实都收到了任何数据，只不过经过筛选后只提交上来了发给自己的数据**。

**扩展：**

> - **单向数据发送**： 主机发送数据帧时，将数据帧当中的目的MAC地址指定为某一台主机，此时每台主机对数据帧进行识别后，最终只有那台指定的主机会将该数据帧向上交付进行处理。
> - **局域网内进行数据广播**： 主机发送数据帧时，将数据帧当中的目的MAC地址设置为全1，此时所有主机收到该数据帧后都会对该数据帧进行处理，但是上层协议有方法处理该数据，即把数据的辨别工作交给了上层。

### 数据碰撞

当主机A在向主机B发送数据时，其他主机彼此之间可能也正在进行通信，甚至主机A在和主机B通信的同时也在和其他主机进行通信。

![image-20230328110357368](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328110357368.png)

但同一局域网中的所有主机在通信时，使用的都是一个共同的通信信道，因此如果局域网内的多台主机同时进行通信，此时这些数据之间就可能会相互干扰。

每一个局域网都可以看作是一个**碰撞域**，如果某个主机发送出去的数据与其他主机发送的数据之间产生了干扰，我们就称这两台主机在该碰撞域中发生了碰撞。

**如何判断发送出去的数据是否发生了碰撞？**

> 因为发送到局域网当中的数据是所有主机都能够收到的，因此当一个主机将数据发送出去后，该主机本身也是能够收到这个数据的。当该主机收到该数据后就可以将其与之前发送出去的数据进行对比，如果**发现收到的数据与之前发送出去的数据不相同，则说明在发送过程中发生了碰撞。**
>
> 也就是说，主机实际是能够通过某种方式，知道曾经发送出去的数据是否发生了碰撞的。

**发生碰撞后是如何处理的？**

> 当一个主机发现自己发送出去的数据产生了碰撞，此时该主机就要执行**“碰撞避免”算法**。“碰撞避免”算法实际很简单：当一个主机发送出去的数据产生了碰撞，那么该主机可以选择等一段时间后，再重新发送该数据。这就像现实生活中的两个人同时想要说话，此时对方就都会说“你先说吧”，这实际上就是一种碰撞避免。
>
> 需要注意的是，实际在网络通信压力不大的时候发生碰撞的概率是不大的，我们不要太小瞧计算机的处理速度，也不要太小瞧网线传播数据的速度。
>
> 还有一种方式就是让**碰撞域尽可能的小**，**交换机**可以将一个局域网分成不同的碰撞域。工作原理？

**每个主机如何判断该数据是否是发送给自己的？**

> 在局域网中发送的数据实际叫做MAC数据帧，在这个MAC数据帧的报头当中会包含两个字段，分别叫做源MAC地址和目的MAC地址。
>
> 每一台计算机都至少配有一张网卡，而每一张网卡在出厂时就已经内置了一个48位的序列号，我们将这个序列号称之为“MAC地址”，这个**MAC地址是全球唯一的**。
>
> 在局域网中进行通信的时候，每一个主机在收到一个MAC数据帧后，都会提取该MAC数据帧的报头，找到对应的目的MAC地址与自己的MAC地址进行比对。**如果该MAC地址与自己的MAC地址不匹配，则直接将该MAC数据帧丢弃，只有MAC地址匹配时，该主机才会将该数据帧的有效载荷继续向上进行交付处理**。

**与碰撞相关的一种局域网攻击机制**

> 如果局域网内的某台主机一直向该局域网内发送一些无用的数据，那么其他主机一发数据就会产生碰撞，此时该局域网也就瘫痪了，这实际就是局域网本身的一个攻击原理。但需要注意的是，这台一直发送“垃圾数据”的主机，必须要通过某种方式绕过“碰撞避免”算法，否则当其发送的数据产生碰撞后，该主机自己也会执行“碰撞避免”算法。

## 网络中的地址

**ifconfig**

> 在Linux系统中：ifconfig可以查看自己的网络地址
>
> inet字段：一般为私有地址
>
> ether字段：MAC地址

### IP地址

IP协议有两个版本, IPv4和IPv6. 凡是提到IP协议, 没有特殊说明的, 默认都是指IPv4

> - IP地址是在IP协议中, 用来标识网络中不同主机的地址; 
> - 对于IPv4来说, IP地址是一个4字节, 32位的整数; 
> - 我们通常也使用 "点分十进制" 的字符串表示IP地址, 例如 192.168.0.1 ; 用点分割的每一个数字表示一个 字节, 范围是 0 - 255

### MAC地址

> - MAC地址用来识别数据链路层中相连的节点; 
> - 长度为48位, 即6个字节. 一般用16进制数字加上冒号的形式来表示(例如: 08:00:27:03:fb:19) 
> - 在网卡出厂时就确定了, 不能修改. mac地址通常是唯一的(虚拟机中的mac地址不是真实的mac地址, 可能会冲突; 也有些网卡支持用户配置mac地址).

# 网络编程

## 基础知识

> 源：即网络数据在通信网络中的出发地
>
> 目的：即网络数据的目的地

### 源IP/目的IP

IP地址是在IP协议中, 用来标识网络中不同主机的地址，主机可以是计算机，也可以是路由器，每台主机都有一个唯一的IP地址。

对于一个完整的通信过程，站在网络的角度上，我们需要知道数据从哪里来到哪里去，这就是源IP/目的IP。代表了这个数据是从哪台主机上产生的，哪台主机需要接收这条数据。

如果一台主机上的数据要传输到另一台主机，那么对端主机的IP地址就应该作为该数据传输时的目的IP地址。但仅仅知道目的IP地址是不够的，当对端主机收到该数据后，对端主机可能还需要对该主机做出响应。因此对端主机也需要发送数据给该主机，此时对端主机就必须知道该主机的IP地址。因此**一个传输的数据当中应该涵盖其源IP地址和目的IP地址，目的IP地址表明该数据传输的目的地，源IP地址作为对端主机响应时的目的IP地址**。

在数据进行传输之前，会先自顶向下贯穿网络协议栈完成数据的封装，其中在网络层封装的IP报头当中就涵盖了源IP地址和目的IP地址。

而除了源IP地址和目的IP地址之外，还有源MAC地址和目的MAC地址的概念。

### 源MAC/目的MAC

大部分数据的传输都是跨局域网的，数据在传输过程中会经过若干个路由器，最终才能到达对端主机，在这个过程中源MAC/目的MAC可能会发生变化。

![image-20230328120501226](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328120501226.png)

源MAC地址和目的MAC地址是包含在链路层的报头当中的，而MAC地址实际只在当前局域网内有效（路由器级联多个局域网，每个局域网都认为它是网内的一台主机），因此**当数据跨网络到达另一个局域网时，其源MAC地址和目的MAC地址就需要发生变化，则当数据到达路由器时，路由器会将该数据当中链路层的报头去掉，然后再重新封装一个报头，此时该数据的源MAC地址和目的MAC地址就发生了变化。**

例如，在图中主机１向主机２发送数据的过程中，数据的源MAC地址和目的MAC地址的变化过程如下：

![image-20230328120726820](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328120726820.png)



**因此数据在传输的过程中是有两套地址：**

- 一套是**源IP地址和目的IP地址，这两个地址在数据传输过程中基本是不会发生变化的**（存在一些特殊情况，比如在数据传输过程中使用NET技术，其源IP地址会发生变化，但至少目的IP地址是不会变化的）。
- 另一套就是**源MAC地址和目的MAC地址，这两个地址是一直在发生变化的**，因为在数据传输的过程中路由器不断在进行解包和重新封装。

### 源端口号/目的端口号

两台主机之间通信的目的不仅仅是为了将数据发送给对端主机，而是为了访问对端主机上的某个服务。比如我们在用百度搜索引擎进行搜索时，不仅仅是想将我们的请求发送给对端服务器，而是想访问对端服务器上部署的百度相关的搜索服务。这些**服务的本质就是运行在OS上的进程/线程，网络通信的本质就是进程通信**。

所以当数据到来时，我们还需要将数据交付给具体的进程，就需要标识OS上的具体进程。而在网络角度上，我们使用端口号来标识某一个具体进程，则**IP+端口号就可以唯一标识网络中的某一个具体进程**。

> - 端口号是传输层协议的内容。
> - 端口号是一个2字节16位的整数。
> - 端口号用来标识一个进程，告诉操作系统，当前的这个数据要交给哪一个进程来处理。
> - 一个端口号只能被一个进程占用。

由于IP地址能够唯一标识公网内的一台主机，而端口号能够唯一标识一台主机上的一个进程，因此用**IP地址+端口号就能够唯一标识网络上的某一台主机的某一个进程。**

当数据在传输层进行封装时，就会添加上对应源端口号和目的端口号的信息。这时通过源IP地址+源端口号就能够在网络上唯一标识发送数据的进程，通过目的IP地址+目的端口号就能够在网络上唯一标识接收数据的进程，此时就实现了跨网络的进程间通信。

因为端口号是隶属于某台主机的，所以端口号可以在两台不同的主机当中重复，但是在同一台主机上进行网络通信的进程的端口号不能重复。此外，**一个进程可以绑定多个端口号，但是一个端口号不能被多个进程同时绑定**。

**为什么不使用进程pid标识**

> 进程ID（PID）是用来标识系统内所有进程的唯一性的，它是**属于系统级**的概念；而端口号（port）是用来标识需要对外进行网络数据请求的进程的唯一性的，它是**属于网络**的概念。
>
> 一台机器上可能会有大量的进程，但并不是所有的进程都要进行网络通信，可能有很大一部分的进程是不需要进行网络通信的本地进程，此时PID虽然也可以标识这些网络进程的唯一性，但在该场景下就不太合适了，PID无法区分哪些进程进行网络通信，哪些没有进行。
>
> **解耦合**

**底层如何通过port找到对应进程的**

> **底层采用哈希的方式建立了端口号和进程PID或PCB之间的映射关系**，当底层拿到端口号时就可以直接执行对应的哈希算法，然后就能够找到该端口号对应的进程。

### 网络字节序

#### 网络中的大小端问题

计算机在存储数据时是有大小端的概念的：

> - **大端模式：** 数据的高字节内容保存在内存的低地址处，**数据的低字节内容保存在内存的高地址处**。
> - **小端模式：** 数据的高字节内容保存在内存的高地址处，**数据的低字节内容保存在内存的低地址处**。

如果编写的程序只在本地机器上运行，那么是不需要考虑大小端问题的，因为同一台机器上的数据采用的存储方式都是一样的，要么采用的都是大端存储模式，要么采用的都是小端存储模式。但如果涉及网络通信，那就必须考虑大小端的问题，否则对端主机识别出来的数据可能与发送端想要发送的数据是不一致的。

例如，现在两台主机之间在进行网络通信，其中发送端是小端机，而接收端是大端机。发送端将发送缓冲区中的数据按内存地址从低到高的顺序发出后，接收端从网络中获取数据依次保存在接收缓冲区时，也是按内存地址从低到高的顺序保存的。

![image-20230328144825114](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328144825114.png)

但由于发送端和接收端采用的分别是小端存储和大端存储，此时对于内存地址从低到高为44332211的序列，发送端按小端的方式识别出来是0x11223344，而接收端按大端的方式识别出来是0x44332211，此时接收端识别到的数据与发送端原本想要发送的数据就不一样了，这就是由于大小端的偏差导致数据识别出现了错误。

由于我们不能保证通信双方存储数据的方式是一样的，因此网络当中传输的数据必须考虑大小端问题。因此**TCP/IP协议规定，网络数据流采用大端字节序**，即低地址高字节。无论是大端机还是小端机，都必须按照TCP/IP协议规定的网络字节序来发送和接收数据。

> - 如果发送端是小端，需要先将数据转成大端，然后再发送到网络当中。
> - 如果发送端是大端，则可以直接进行发送。
> - 如果接收端是小端，需要先将接收到数据转成小端后再进行数据识别。
> - 如果接收端是大端，则可以直接进行数据识别。

需要注意的是，**所有的大小端的转化工作是由操作系统来完成的**，因为该操作属于通信细节，不过**也有部分的信息需要我们自行进行处理，比如端口号和IP地址**。

#### 转换函数

为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，系统提供了四个函数，可以通过调用以下库函数实现网络字节序和主机字节序之间的转换。

~~~C++
#include <arpa/inet.h>

uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
~~~

- 函数名当中的h表示host，n表示network，l表示32位长整数，s表示16位短整数。
- 例如htonl表示将32位长整数从主机字节序转换为网络字节序。
- 如果主机是小端字节序，则这些函数将参数做相应的大小端转换然后返回。
- 如果主机是大端字节序，则这些函数不做任何转换，将参数原封不动地返回。

## 认识TCP/UDP

网络协议栈是贯穿整个体系结构的，在应用层、操作系统层和驱动层各有一部分。当我们使用系统调用接口实现网络数据通信时，不得不面对的协议层就是传输层，而传输层最典型的两种协议就是TCP协议和UDP协议。

### TCP

- TCP协议叫做传输控制协议（Transmission Control Protocol），TCP协议是一种**面向连接的、可靠的、基于字节流的**传输层通信协议。
- TCP协议是面向连接的，如果两台主机之间想要进行数据传输，那么必须要**先建立连接**，当连**接建立成功后才能进行数据传输**。
- TCP协议是保证可靠的协议，数据在传输过程中如果出现了丢包、乱序等情况，TCP协议都有对应的解决方法。
- TCP协议是面向字节流的协议。

### UDP

- UDP协议叫做用户数据报协议（User Datagram Protocol），UDP协议是一种**无需建立连接的、不可靠的、面向数据报的**传输层通信协议。
- 使用UDP协议进行通信时无需建立连接，如果两台主机之间想要进行数据传输，那么直接将数据发送给对端主机就行了。
- 但这也就意味着UDP协议是不可靠的，数据在传输过程中如果出现了丢包、乱序等情况，UDP协议本身是不知道的。

**TCP协议是一种可靠的传输协议，使用TCP协议能够在一定程度上保证数据传输时的可靠性，而UDP协议是一种不可靠的传输协议，UDP协议的存在有什么意义？**

> 首先，可靠是需要我们做更多的工作的，TCP协议虽然是一种可靠的传输协议，但这一定意味着TCP协议在底层需要做更多的工作，因此TCP协议底层的实现是比较复杂的，我们不能只看到TCP协议面向连接可靠这一个特点，我们也要能看到TCP协议对应的缺点。
>
> 同样的，UDP协议虽然是一种不可靠的传输协议，但这一定意味着UDP协议在底层不需要做过多的工作，因此UDP协议底层的实现一定比TCP协议要简单，UDP协议虽然不可靠，但是它能够快速的将数据发送给对方，虽然在数据在传输的过程中可能会出错。
>
> 编写网络通信代码时具体采用TCP协议还是UDP协议，完全取决于上层的应用场景。如果应用场景严格要求数据在传输过程中的可靠性，此时我们就必须采用TCP协议，如果应用场景允许数据在传输出现少量丢包，那么我们肯定优先选择UDP协议，因为UDP协议足够简单。
>

## socket编程接口

### API

创建套接字：（TCP/UDP，客户端+服务器）

```C
int socket(int domain, int type, int protocol);
```

绑定端口号：（TCP/UDP，服务器）

```C
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

监听套接字：（TCP，服务器）

```C
int listen(int sockfd, int backlog);
```

接收请求：（TCP，服务器）

```C
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

建立连接：（TCP/UDP，客户端）

```C
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

> TCP客户端必须调用connect建立链接，形成三次握手
>
> 而UDP客户端不强求connect，但使用connect建立连接后，可以使用send/recv，不用每次都指定ip和端口号
>
> recv/from使用的sockfd不是socket创建出来的，而是connect返回的

发送内容：sendto（UDP）

~~~C++
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
~~~

接收内容：recvfrom（UDP）

~~~C++
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
~~~

接受内容：recv，前提是存在sockfd，可用read

~~~C++
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
~~~

发送内容：send，前提是存在sockfd，可用write

~~~C++
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
~~~

### sockaddr结构

套接字不仅支持跨网络的进程间通信，还支持本地的进程间通信（域间套接字）。在进行跨网络通信时我们需要传递的端口号和IP地址，而本地通信则不需要，因此套接字提供了`sockaddr_in`结构体和`sockaddr_un`结构体，其中**`sockaddr_in`结构体是用于跨网络通信的，而`sockaddr_un`结构体是用于本地通信的。**

为了让套接字的网络通信和本地通信能够使用同一套函数接口，于是就出现了`sockeaddr`结构体，该结构体与`sockaddr_in`和`sockaddr_un`的结构都不相同，但这三个结构体头部的16个比特位都是一样的，这个字段叫做协议家族。

![image-20230328145720177](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328145720177.png)

此时当我们在传递在传参时，就不用传入`sockeaddr_in`或`sockeaddr_un`这样的结构体，而统一传入`sockeaddr`这样的结构体。在设置参数时就可以通过设置协议家族这个字段，来表明我们是要进行网络通信还是本地通信，在这些API内部就可以提取`sockeaddr`结构头部的16位进行识别，进而得出我们是要进行网络通信还是本地通信，然后执行对应的操作。此时我们就通过通用`sockaddr`结构，将套接字网络通信和本地通信的参数类型进行了统一。

> 实际我们在进行网络通信时，定义的还是`sockaddr_in`这样的结构体，只不过在传参时需要将该结构体的地址类型进行强转为`sockaddr*`。

### 其他

**为什么会有这么多本地进程间通信的方式？**

> 本地进程间通信的方式已经有管道、消息队列、共享内存、信号量等方式了，现在在套接字这里又出现了可以用于本地进程间通信的域间套接字，为什么会有这么多通信方式，并且这些通信方式好像并不相关？
>
> 实际是因为早期有很多不同的实验室都在研究通信的方式，由于是不同的实验室，因此就出现了很多不同的通信方式，比如常见的有System V标准的通信方式和POSIX标准的通信方式。

**IPv4和IPv6**

> - IPv4和IPv6的地址格式定义在netinet/in.h中，IPv4地址用sockaddr_in结构体表示，包括16位地址类型，16位端口号和32位IP地址。
>- IPv4、IPv6地址类型分别定义为常数AF_INET、AF_INET6。这样，只要取得某种sockaddr结构体的首地址，不需要知道具体是哪种类型的sockaddr结构体，就可以根据地址类型字段确定结构体中的内容。
> - socket API可以都用struct sockaddr* 类型表示，在使用的时候需要强制转化成sockaddr_in；这样的好处是程序的通用性，可以接收IPv4、IPv6，以及UNIX Domain Socket各种类型的sockaddr结构体指针做为参数。

**为什么没有用`void*`代替`struct sockaddr*`类型？**

> 我们可以将这些函数的`struct sockaddr`*参数类型改为`void`*，此时在函数内部也可以直接指定提取头部的16个比特位进行识别，最终也能够判断是需要进行网络通信还是本地通信，那为什么还要设计出s`ockaddr`这样的结构呢？
>
> 实际在设计这一套网络接口的时候C语言还不支持`void*`，于是就设计出了`sockaddr`这样的解决方案。并且在C语言支持了`void*`之后也没有将它改回来，因为这些接口是系统接口，系统接口是所有上层软件接口的基石，系统接口是不能轻易更改的，否则引发的后果是不可想的，这也就是为什么现在依旧保留`sockaddr`结构的原因。

## UDP编程

UDP网络编程分为四个部分

1. 创建套接字：socket

    > 调用socket系统调用，由OS创建一个用于网络通信的文件，我们把这个文件对应的文件描述符叫做套接字

2. 绑定套接字：bind

    > 绑定套接字，可以认为是告诉套接字你和主机上的哪一个进程绑定了

3. 发送数据：sendto

    > 发送数据给套接字

4. 读取数据：recvfrom

    > 从套接字中读取数据

### 如何编程

作为网络通信，可简单分为服务器方，客户端方，我们就从这两个方面入手UDP编程。

#### 准备知识

socket函数

地址转换函数

sockaddr结构体

bind函数

recvfrom函数

sendto函数

#### 创建套接字

##### socket函数

> `int socket(int domain, int type, int protocl);`
>
> 参数说明
>
> - domain：创建套接字的域或者叫做协议家族，也就是创建套接字的类型。该参数就相当于`struct sockaddr`结构的前16个位。如果是本地通信就设置为`AF_UNIX`，如果是网络通信就设置为`AF_INET`（IPv4）或`AF_INET6`（IPv6）。
> - type：创建套接字时所需的服务类型。其中最常见的服务类型是`SOCK_STREAM`和`SOCK_DGRAM`，如果是基于UDP的网络通信，我们采用的就是`SOCK_DGRAM`，叫做用户数据报服务，如果是基于TCP的网络通信，我们采用的就是`SOCK_STREAM`，叫做流式套接字，提供的是流式服务。
> - protocol：创建套接字的协议类别。你可以指明为TCP或UDP，但该字段一般直接设置为0就可以了，设置为0表示的就是默认，此时会根据传入的前两个参数自动推导出你最终需要使用的是哪种协议。
>
> 返回值说明：
>
> - 套接字创建成功返回一个文件描述符，创建失败返回-1，同时错误码会被设置。

##### 代码

**创建套接字操作，服务器与客户端没有区别。**

当我们在进行初始化服务器创建套接字时，就是调用socket函数创建套接字，创建套接字时我们需要填入的协议家族就是`AF_INET`，因为我们要进行的是网络通信，而我们需要的服务类型就是`SOCK_DGRAM`，因为我们现在编写的UDP服务器是面向数据报的，而第三个参数之间设置为0即可。

###### server

> 
>
> ~~~C++
> #pragma once
> 
> #ifndef _UDP_SERVER_HPP
> #define _UDP_SERVER_HPP
> #endif
> 
> #include "log.hpp"
> 
> #include <sys/types.h> //通信数据结构类型
> #include <sys/socket.h> //套接字函数
> 
> #include <iostream>
> #include <cstdio>
> #include <cstdlib>
> 
> #include <unistd.h> //文件操作
> 
> namespace UDP
> {
>  class UdpServer
>  {
>  public:
>      UdpServer()
>      {
>          Test();
>      }
>      ~UdpServer()
>      {
>          close(_sockfd);
>      }
> 
>  private:
>      void Test()
>      {
>          _sockfd = socket(AF_INET, SOCK_DGRAM, 0);
>          if(_sockfd < 0) //失败返回-1
>          {
>              std::cout << "socket error" << std::endl;
>          }
>          else
>          {
>              std::cout << "socket create sussess, sockfd: " << _sockfd << std::endl;
>          }
> 
>      }
>  private:
>      int _sockfd; // 套接字，即文件描述符
>  };
> }
> 
> 
> ~~~
>
> **当析构服务器时，我们可以将sockfd对应的文件进行关闭，但实际上不进行该操作也行，因为一般服务器运行后是就不会停下来的。**
>
> 测试是否创建成功：
>
> ~~~C++
> #include "udp_server.hpp"
> 
> int main()
> {
>  UDP::UdpServer Server;
> 
>  return 0;
> }
> //[qlz@tianen1573 UDP_socket]$ ./udp_server
> //socket create sussess, sockfd: 3
> ~~~
>

###### client

> ~~~C++
> #pragma once
> 
> #include "log.hpp"
> 
> #include <sys/types.h> //通信数据结构类型
> #include <sys/socket.h> //套接字函数
> 
> #include <iostream>
> #include <cstdio>
> #include <cstdlib>
> 
> #include <unistd.h> //文件操作
> 
> namespace UDP
> {
>  class UdpClient
>  {
>  public:
>      UdpClientUdpClient()
>      {
>          Test();
>      }
>      ~UdpClientUdpClientUdpClientr()
>      {
>          close(_sockfd);
>      }
> 
>  private:
>      void Test()
>      {
>          _sockfd = socket(AF_INET, SOCK_DGRAM, 0);
>          if(_sockfd < 0) //失败返回-1
>          {
>              std::cout << "client error" << std::endl;
>          }
>          else
>          {
>              std::cout << "client create sussess, sockfd: " << _sockfd << std::endl;
>          }
> 
>      }
>  private:
>      int _sockfd; // 套接字，即文件描述符
>  };
> }
> 
> 
> #include "udp_client.hpp"
> 
> int main()
> {
>  UDP::UdpClient Client;
> 
>  return 0;
> }
> //[qlz@tianen1573 UDP_socket]$ ./udp_server
> //socket create sussess, sockfd: 3
> ~~~
>
> 

##### 理解

> **socket是系统调用**
>
> 网络协议栈是分层的，按照TCP/IP四层模型来说，自顶向下依次是应用层、传输层、网络层和数据链路层。而我们现在所写的代码都叫做用户级代码，也就是说我们是在应用层编写代码，因此我们调用的实际是下三层的接口，而传输层和网络层都是在操作系统内完成的，也就意味着我们在**应用层调用的接口都叫做系统调用接口**。
>
> ----
>
> **socket的背后工作**
>
> socket函数是被进程所调用的，而每一个进程在系统层面上都有一个进程地址空间PCB（task_struct）、文件描述符表（files_struct）以及对应打开的各种文件。而文件描述符表里面包含了一个数组fd_array，其中数组中的0、1、2下标依次对应的就是标准输入、标准输出以及标准错误。
>
> ![image-20230328190002537](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328190002537.png)
>
> 当我们调用socket函数创建套接字时，实际相当于我们打开了一个“网络文件”，打开后在内核层面上就形成了一个对应的struct file结构体，同时该结构体被连入到了该进程对应的文件双链表，并将该结构体的首地址填入到了fd_array数组当中下标为3的位置，此时fd_array数组中下标为3的指针就指向了这个打开的“网络文件”，最后3号文件描述符作为socket函数的返回值返回给了用户。
>
> ![image-20230328190020119](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328190020119.png)
>
> 其中每一个struct file结构体中包含的就是对应打开文件各种信息，比如文件的属性信息、操作方法以及文件缓冲区等。其中文件对应的属性在内核当中是由struct inode结构体来维护的，而文件对应的操作方法实际就是一堆的函数指针（比如read*和write*）在内核当中就是由struct file_operations结构体来维护的。而文件缓冲区对于打开的普通文件来说对应的一般是磁盘，但对于现在打开的“网络文件”来说，这里的文件缓冲区对应的就是网卡。
> ![image-20230328190115764](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328190115764.png)
>
> 对于一般的普通文件来说，当用户通过文件描述符将数据写到文件缓冲区，然后再把数据刷到磁盘上就完成了数据的写入操作。而对于现在socket函数打开的“网络文件”来说，当用户将数据写到文件缓冲区后，操作系统会定期将数据刷到网卡里面，而网卡则是负责数据发送的，因此数据最终就发送到了网络当中。

#### 绑定套接字

创建套接字只是在系统层面上打开了一个文件，操作系统并不知道是要将数据写入到磁盘还是刷到网卡，因为此时该文件还没有与网络关联起来。

![image-20230328221250746](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328221250746.png)

##### bind函数

> `int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`
>
> 参数说明：
>
> - sockfd：绑定的文件的文件描述符。也就是我们创建套接字时获取到的文件描述符。
> - addr：网络相关的属性信息，包括协议家族、IP地址、端口号等。
> - addrlen：传入的addr结构体的长度。
>
> 返回值说明：
>
> - 绑定成功返回0，绑定失败返回-1，同时错误码会被设置。

##### 地址转换函数

> **字符串IP VS 整数IP**
>
> IP地址的表现形式有两种：
>
> - 字符串IP：类似于`192.168.233.123`这种字符串形式的IP地址，叫做基于字符串的点分十进制IP地址。
> - 整数IP：IP地址在进行网络传输时所用的形式，用一个32位的整数来表示IP地址。
>
> **整数IP存在的意义**
>
> 网络传输数据时是寸土寸金的，如果我们在网络传输时直接以基于字符串的点分十进制IP的形式进行IP地址的传送，那么此时一个IP地址至少就需要15个字节，但实际并不需要耗费这么多字节。
>
> IP地址实际可以划分为四个区域，其中每一个区域的取值都是0~255，而这个范围的数字只需要用8个比特位就能表示，因此我们实际只需要32个比特位就能够表示一个IP地址。其中这个32位的整数的每一个字节对应的就是IP地址中的某个区域，我们将IP地址的这种表示方法称之为整数IP，此时表示一个IP地址只需要4个字节。
> ![image-20230328222435106](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328222435106.png)
>
> 因为采用整数IP的方案表示一个IP地址只需要4个字节，并且在网络通信也能表示同样的含义，因此在网络通信时就没有用字符串IP而用的是整数IP，因为这样能够减少网络通信时数据的传送。
>
> 两者的转换由OS提供，安全可靠。
>
> **16位端口号**
>
> sockaddr_in中的端口号变量类型位16位整数，为2字节，建议：
>
> - 定义时用`uint16_t`类型，减少空间开销
> - 上传和提取时使用转换函数
>
> **转换函数**
>
> ![image-20230329082218696](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230329082218696.png)
>
> ![image-20230329082229066](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230329082229066.png)
>
> - inet_addr函数：将字符串IP转换成整数IP的函数叫做inet_addr
>
>     `in_addr_t inet_addr(const char *cp);`
>
> - inet_ntoa函数：将整数IP转换成字符串IP的函数叫做inet_ntoa
>
>     `char *inet_ntoa(struct in_addr in);`
>
> **认识inet_ntoa**
>
> inet_ntoa这个函数返回了一个char*, 很显然是这个函数自己在内部为我们申请了一块内存来保存ip的结果. 那么是否需要调用者手动释放呢?
>
> ![image-20230329082300051](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230329082300051.png)
>
> man手册上说, inet_ntoa函数, 是把这个返回结果放到了静态存储区. 这个时候不需要我们手动进行释放. 那么问题来了, 如果我们调用多次这个函数, 会有什么样的效果呢? 参见如下代码:
>
> ![image-20230329082337834](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230329082337834.png)
>
> **因为inet_ntoa把结果放到自己内部的一个静态存储区, 这样第二次调用时的结果会覆盖掉上一次的结果**。
>
> - 思考: 如果有多个线程调用 inet_ntoa, 是否会出现异常情况呢? 
> - 在APUE中, 明确提出**inet_ntoa不是线程安全的函数**;  
> - 但是在centos7上测试, 并没有出现问题, 可能内部的实现加了互斥锁;  
> - 自己写程序验证一下在自己的机器上inet_ntoa是否会出现多线程的问题; 
> - **在多线程环境下, 推荐使用inet_ntop, 这个函数由调用者提供一个缓冲区保存结果, 可以规避线程安全问 题**;
>
> ~~~C++
> #include <stdio.h>
> #include <unistd.h>
> #include <sys/socket.h>
> #include <netinet/in.h>
> #include <arpa/inet.h>
> #include <pthread.h>
> void* Func1(void* p) {
>  struct sockaddr_in* addr = (struct sockaddr_in*)p;
>  while (1) {
>  char* ptr = inet_ntoa(addr->sin_addr);
>  printf("addr1: %s\n", ptr);
>  }
>  return NULL;
> }
> void* Func2(void* p) {
>  struct sockaddr_in* addr = (struct sockaddr_in*)p;
>  while (1) {
>  char* ptr = inet_ntoa(addr->sin_addr);
>      printf("addr2: %s\n", ptr);
>  }
>  return NULL;
> }
> int main() {
>  pthread_t tid1 = 0;
>  struct sockaddr_in addr1;
>  struct sockaddr_in addr2;
>  addr1.sin_addr.s_addr = 0;
>  addr2.sin_addr.s_addr = 0xffffffff;
>  pthread_create(&tid1, NULL, Func1, &addr1);
>  pthread_t tid2 = 0;
>  pthread_create(&tid2, NULL, Func2, &addr2);
>  pthread_join(tid1, NULL);
>  pthread_join(tid2, NULL);
>  return 0;
> }
> ~~~
>
> 

##### struct sockaddr_in

**认识结构**

> 在绑定时需要将网络相关的属性信息填充到一个结构体当中，然后将该结构体作为bind函数的第二个参数进行传入，这实际就是`struct sockaddr_in`结构体。
>
> ![image-20230328221919662](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328221919662.png)
>
> `struct sockaddr_in`中的成员如下
>
> - sin_family：表示协议家族。
> - sin_port：表示端口号，是一个16位的整数。
> - sin_addr：表示IP地址，是一个32位的结构体。
>
> 剩下的字段一般不做处理，当然你也可以进行初始化。
>
> 其中sin_addr的类型是`struct in_addr`，实际该结构体当中就只有一个成员，该成员就是一个32位的整数，IP地址实际就是存储在这个整数当中的。
>
> ![image-20230328221907769](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230328221907769.png)

**初始化**

> ~~~C++
> //填充网络通信相关信息
> struct sockaddr_in local;
> 
> memset(&local, '\0', sizeof(local));//初始化位0
> 
> local.sin_family = AF_INET;//填充协议簇
> local.sin_port = htons(_port);//填充端口号，short 转 short
> local.sin_addr.s_addr = inet_addr(_ip.c_str());//填充IP，char* 转 int
> ~~~
>

##### CS区别

> 在绑定阶段，我们就需要给服务器/客户端进程指定IP+端口号，保证通信进行
>
> 但对于这一步的处理，CS有着很大的区别
>
> **对于服务器**
>
> - 需要固定IP+端口号
> - 发送者的信息可在接受信息时获得
>
> **对于客户端**
>
> - 不需要固定端口号，由OS自动分配
> - 需要服务器的IP+端口号
> - 自己的信息在发送数据时，会一并传输
>
> 则启动时，我们需要**告诉服务器本机IP+指定端口号，告诉客户端目标IP+端口号**

##### 代码

###### 服务器

> ~~~C++
> #pragma once
> 
> #ifndef _UDP_SERVER_HPP
> #define _UDP_SERVER_HPP
> #endif
> 
> #include "log.hpp"
> 
> #include <sys/types.h>  //通信类型
> #include <sys/socket.h> //套接字函数
> #include <netinet/in.h> //结构体
> #include <arpa/inet.h>  //结构体
> 
> #include <iostream>
> #include <cstdio>
> #include <cstdlib>
> 
> #include <unistd.h> //文件操作
> 
> namespace UDP
> {
>     class UdpServer
>     {
>     public:
>         UdpServer()
>         {
>         }
>         UdpServer(std::string ip, uint16_t port)
>             : _port(port), _ip(ip)
>         {
>             // 1. 创建套接字
>             _sockfd = socket(AF_INET, SOCK_DGRAM, 0);
>             if (_sockfd < 0) // 失败返回-1
>             {
>                 std::cout << "socket error" << std::endl;
>             }
>             else
>             {
>                 std::cout << "socket create sussess, sockfd: " << _sockfd << std::endl;
>             }
>         }
>         void Start()
>         {
>             // 2. 绑定
>             // 对于服务器，因为服务器是被链接的，别人需要知道服务器进程的IP+端口号
>             // 所以我们给服务器进程指定 固定的IP+端口号，使得客户端可以找到我们
> 
>             // a. 创建sockaddr_in结构体
>             struct sockaddr_in local;
>             local.sin_family = AF_INET;                     // 通信类型
>             local.sin_port = htons(_port);                  // 主机转网络
>             local.sin_addr.s_addr = inet_addr(_ip.c_str()); // 主机转网络
>             // b. 绑定
>             if (bind(_sockfd, (sockaddr *)&local, sizeof(local)) < 0)
>             {
>                 std::cerr << "bind error" << std::endl;
>             }
>             else
>             {
>                 std::cout << "bind success" << std::endl;
>             }
> 
>             // 3. 读取 返回
>             //实现一个将数据原路返回的服务器
>             
>         }
>         ~UdpServer()
>         {
>             if (_sockfd >= 0)
>             {
>                 close(_sockfd);
>             }
>         }
> 
>     private:
>         uint16_t _port;  // 16位端口号
>         std::string _ip; // 字符串型IP
>         int _sockfd;     // 套接字，即文件描述符
>     };
> }
> ~~~
>
> 测试：
>
> ~~~C++
> #include "udp_server.hpp"
> 
> //命令行提示
> static void usage(std::string proc)
> {
>     std::cout << "\nUsage: " << proc << " port\n" << std::endl;
> }
> 
> //命令行参数
> // ./unp_server ip port
> int main(int argc, char* argv[])
> {
>     if(argc != 3)
>     {
>         usage(argv[0]);
>         exit(1);
>     }
> 
>     std::string ip = argv[1];
>     uint16_t port = atoi(argv[2]);
>     UDP::UdpServer *Server = new UDP::UdpServer(ip, port);
>     Server->Start();//启动服务器
> 
>     return 0;
> }
> //[qlz@tianen1573 UDP_socket]$ ./udp_server 127.0.0.1 8080
> //socket create sussess, sockfd: 3
> //bind success
> ~~~

###### 客户端

> ~~~C++
> #pragma once
> 
> #include "log.hpp"
> 
> #include <sys/types.h>  //通信类型
> #include <sys/socket.h> //套接字函数
> #include <netinet/in.h> //结构体
> #include <arpa/inet.h>  //结构体
> 
> #include <iostream>
> #include <cstdio>
> #include <cstdlib>
> 
> #include <unistd.h> //文件操作
> 
> namespace UDP
> {
>     class UdpClient
>     {
>     public:
>         UdpClient()
>         {
>         }
>         UdpClient(std::string ip, uint16_t port)
>             : _server_ip(ip), _server_port(port)
>         {
>             // 1. 创建套接字
>             _sockfd = socket(AF_INET, SOCK_DGRAM, 0);
>             if (_sockfd < 0) // 失败返回-1
>             {
>                 std::cout << "socket error" << std::endl;
>             }
>             else
>             {
>                 std::cout << "socket create sussess, sockfd: " << _sockfd << std::endl;
>             }
>         }
>         void Start()
>         {
>             // 2. 绑定
>             //对于客户端，我们不需要手动绑定IP+端口号，因为客户端不会是被动链接的，是主动连接的发起者
>             //那么客户端需要知道服务器的IP+端口号，而自身的IP+端口号会在通信过程中交付给服务器
>             //则我们一般并不给客户端套接字进行绑定操作，这个任务一般由OS进行，绑定 主机IP+随机的端口号
>             
>             //不需要绑定，但我们需要为目标服务器进程创建一个通信数据结构，用于通信
>             // a. 创建sockaddr_in结构体
>             struct sockaddr_in server;
>             server.sin_family = AF_INET;                            // 通信类型
>             server.sin_port = htons(_server_port);                  // 主机转网络
>             server.sin_addr.s_addr = inet_addr(_server_ip.c_str()); // 主机转网络
>         }
>         ~UdpClient()
>         {
>             if (_sockfd >= 0)
>             {
>                 close(_sockfd);
>             }
>         }
> 
>     private:
>     private:
>         uint16_t _server_port;  // 16位端口号
>         std::string _server_ip; // 字符串型IP
>         int _sockfd;            // 套接字，即文件描述符
>     };
> }
> ~~~

##### 理解

> 在进行绑定的时候需要将IP地址和端口号告诉对应的网络文件，此时就可以改变网络文件当中文件操作函数的指向，将对应的文件操作函数改为对应网卡的操作方法，此时读数据和写数据对应的操作对象就是网卡了，所以绑定实际上就是将文件和网络关联起来。
>
> 则发送给指定IP+端口号，就会发送给对应绑定的套接字。使用指定IP+端口号的进程，发送给其他网络上的进程时，也会发送给该套接字，让它负责处理。
>
> ----
>
> 首先，由于是网络通信，通信双方都需要找到对方，因此服务端和客户端都需要有源IP+端口号，目的IP+端口号，两者在这方面是有区别的。
>
> 因为服务器就是为了给别人提供服务的，因此服务器必须要让别人知道自己的IP地址和端口号，IP地址一般对应的就是域名，而端口号一般没有显示指明过，因此服务端的端口号一定要是一个众所周知的端口号，并且选定后不能轻易改变，否则客户端是无法知道服务端的端口号的，这就是服务端要进行绑定的原因，只有绑定之后这个端口号才真正属于自己，因为一个端口只能被一个进程所绑定，服务器绑定一个端口就是为了独占这个端口。
>
> 而客户端在通信时虽然也需要端口号+IP，但客户端一般是不进行绑定的，这个步骤是由OS进行的，我们一般不关心。
>
> 如果客户端绑定了某个端口号，那么以后这个端口号就只能给这一个客户端使用，就是这个客户端没有启动，这个端口号也无法分配给别人，并且如果这个端口号被别人使用了，那么这个客户端就无法启动了。所以客户端的端口只要保证唯一性就行了，**因此客户端端口可以动态的进行设置，并且客户端的端口号不需要我们来设置，当我们调用类似于sendto这样的接口时，操作系统会自动给当前客户端获取一个唯一的端口号。**
>
> 也就是说，客户端每次启动时使用的端口号可能是变化的，此时只要我们的端口号没有被耗尽，客户端就永远可以启动。

#### 发送与接收

##### 发送

###### sendto函数

> `ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);`
>
> 参数说明：
>
> - sockfd：对应操作的文件描述符。表示将数据写入该文件描述符索引的文件当中。
> - buf：待写入数据的存放位置。
> - len：期望写入数据的字节数。
> - flags：写入的方式。一般设置为0，表示阻塞写入。
> - dest_addr：对端网络相关的属性信息，包括协议家族、IP地址、端口号等。 addrlen：传入dest_addr结构体的长度。
>
> 返回值说明：
>
> - 写入成功返回实际写入的字节数，写入失败返回-1，同时错误码会被设置。
>
> 注意：
>
> - 由于UDP不是面向连接的，因此除了传入待发送的数据以外还需要指明对端网络相关的信息，包括IP地址和端口号等。
> - 由于sendto函数提供的参数也是`struct sockaddr*`类型的，因此我们在传入结构体地址时需要将`struct sockaddr_in*`类型进行强转。

###### 代码

> 发送：以客户端为例
>
> ~~~C++
> // 3. 发送数据 -- 接收数据
>             // a. 为目标服务器进程创建通信数据结构
>             struct sockaddr_in server;
>             server.sin_family = AF_INET;                            // 通信类型
>             server.sin_port = htons(_server_port);                  // 主机转网络
>             server.sin_addr.s_addr = inet_addr(_server_ip.c_str()); // 主机转网络
>             // b. 创建发送缓冲区
>             std::string sentdoBuf;
>             std::string recvBuf;
> 
>             // c.发送数据
>             for (;;)
>             {
>                 std::cout << "client # ";
>                 std::cin >> sentdoBuf;
>                 ssize_t write_size = sendto(_sockfd, sentdoBuf.c_str(), sentdoBuf.size(), 0, (const sockaddr *)&server, sizeof(server));
>                 if (write_size == 0)
>                 {
>                     std::cout << "server sockfd is closed" << std::endl;
>                     return;
>                 }
>                 else if (write_size < 0)
>                 {
>                     std::cout << "sentdo error " << std::endl;
>                     return;
>                 }
>                 else
>                 {
>                     std::cout << "sendto sussess." << std::endl;
>                 }
>             }
> ~~~

##### 接收

###### recvfrom函数

> `ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);`
>
> 参数说明：
>
> - sockfd：对应操作的文件描述符。表示从该文件描述符索引的文件当中读取数据。
> - buf：读取数据的存放位置。
> - len：期望读取数据的字节数。
> - flags：读取的方式。一般设置为0，表示阻塞读取。
> - src_addr：对端网络相关的属性信息，包括协议家族、IP地址、端口号等。
> - addrlen：调用时传入期望读取的src_addr结构体的长度，返回时代表实际读取到的src_addr结构体的长度，这是一个输入输出型参数。
>
> 返回值说明：
>
> - 读取成功返回实际读取到的字节数，读取失败返回-1，同时错误码会被设置。
>
> 注意：
>
> - 由于UDP是不面向连接的，因此我们除了获取到数据以外还需要获取到对端网络相关的属性信息，包括IP地址和端口号等。
> - 在调用recvfrom读取数据时，必须将addrlen设置为你要读取的结构体对应的大小。
> - 由于recvfrom函数提供的参数也是struct sockaddr*类型的，因此我们在传入结构体地址时需要将struct sockaddr_in*类型进行强转

###### 代码

> 接收：以服务器为例
>
> ~~~C++
> // 3. 发送数据 -- 接收数据
>             // a. 为客户端进程创建通信数据结构保存其信息
>             struct sockaddr_in client;
>             socklen_t client_len = sizeof(client);
>             // b. 创建接收缓冲区
>             char buffer[SIZE];
>             // c.接收数据
>             for (;;)
>             {
>                 
>                ssize_t size = recvfrom(_sockfd, buffer, sizeof(buffer) - 1, 0, (struct sockaddr*)&client, &client_len);
>                 if (size < 0)
>                 {
>                     std::cout << "recvfrom error " << std::endl;
>                     //可能有多个客户端发送数据，一次失败不代表直接结束
>                 }
>                 else
>                 {
>                     buffer[size] = '\0';
>                     int client_port = ntohs(client.sin_port);
>                     std::string client_ip = inet_ntoa(client.sin_addr);
>                     std::cout << client_ip << ":" << client_port << " # ";
>                     std::cout << buffer << std::endl;
>                 }
>             }
> ~~~

##### 测试

> ~~~
> -- 服务器启动
> [qlz@tianen1573 UDP_socket]$ ./udp_server 127.0.0.1 8080
> socket create sussess, sockfd: 3
> bind success
> -- 接收
> 127.0.0.1:44236 # 你好
> 127.0.0.1:44236 # 我是客户端
> ~~~
>
> ~~~C++
> -- 客户端启动
> [qlz@tianen1573 UDP_socket]$ ./udp_server 127.0.0.1 8080
> socket create sussess, sockfd: 3
> bind success
>     
> -- 发送
> client # 你好
> sendto sussess.
>     
> client # 我是客户端
> sendto sussess.
> ~~~

#### 总结

- 服务器与客户端在绑定时的差别
- inet_ntoa不一定是线程安全的，不推荐这个转换函数

### 回声服务器+跨网络

#### 准备知识

本地环回 和 INADDR_ANY

开放端口号

netstat：查看系统网络属性

telent：工具

bzero函数

#### 服务器IP

##### 本地环回IP

127.0.0.1 是一个特殊的IP地址，当向这个IP发送数据时，代表数据只会在本主机的网络协议栈走一遭，不会出本主机，更不会进入网络

##### INADDR_ANY

本质是0，代表该主机绑定的所有IP。

#### 开放端口号

云服务器端口号基本都是关闭的，需要手动打开

#### 封装套接字

~~~C++
#pragma once

#define SIZE 1024

#include <sys/types.h>  //通信类型
#include <sys/socket.h> //套接字函数
#include <netinet/in.h> //结构体
#include <arpa/inet.h>  //结构体

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <cstring>

#include <unistd.h> //文件操作

typedef void (*Handler)(const std::string &req, std::string *resp);
// #include <functional>
// typedef std::function<void(const std::string &, std::string *resp)> Handler;

typedef struct sockaddr_in sockaddr_in;
typedef struct sockaddr sockaddr;

namespace UDP
{
    class UdpSocket
    {
    public:
        UdpSocket()
            : _sockfd(-1)
        {
        }
        bool Socket()
        {
            //创建套接字
            _sockfd = socket(AF_INET, SOCK_DGRAM, 0);
            if (_sockfd < 0) // 失败返回-1
            {
                return false;
            }
            else
            {
                return true;
            }
        }
        bool Bind(uint16_t port, const std::string &ip = "")
        {
            // 绑定

            // a. 创建sockaddr_in结构体
            sockaddr_in local;
            local.sin_family = AF_INET;   // 通信类型
            local.sin_port = htons(port); // 主机转网络
            if (!ip.empty())
                local.sin_addr.s_addr = inet_addr(ip.c_str()); // 主机转网络
            else
                local.sin_addr.s_addr = INADDR_ANY;
            // b. 绑定
            if (bind(_sockfd, (sockaddr *)&local, sizeof(local)) < 0)
            {
                return false;
            }
            else
            {
                return true;
            }
        }
        bool RecvFrom(std::string *buf, std::string *ip = NULL, uint16_t *port = NULL)
        {
            // 接收数据
            // a. 为客户端进程创建通信数据结构保存其信息
            sockaddr_in peer;
            socklen_t peer_len = sizeof(peer);
            // b. 创建接收缓冲区
            char buffer[SIZE];
            // c. 接收数据
            ssize_t size = recvfrom(_sockfd, buffer, sizeof(buffer) - 1, 0, (sockaddr *)&peer, &peer_len);
            if (size < 0)
            {
                perror("recvrrom");
                return false;
            }

            buf->assign(buffer, size); //将读到的数据放到输出型参数buf
            // d. 是否关系客户端信息
            if (ip != NULL)
            {
                *ip = inet_ntoa(peer.sin_addr);
            }
            if (port != NULL)
            {
                *port = ntohs(peer.sin_port);
            }

            return true;
        }
        bool Sendto(const std::string &buf, const std::string &ip, uint16_t port)
        {
            sockaddr_in addr;
            addr.sin_family = AF_INET;
            addr.sin_addr.s_addr = inet_addr(ip.c_str());
            addr.sin_port = htons(port);
            ssize_t write_size = sendto(_sockfd, buf.c_str(), buf.size(), 0, (sockaddr *)&addr, sizeof(addr));
            if (write_size < 0)
            {
                perror("sendto");
                return false;
            }
            return true;
        }
        bool Close()
        {
            close(_sockfd);
            return true;
        }
        ~UdpSocket()
        {
        }

    private:
        int _sockfd; // 套接字，即文件描述符
    };
}

~~~

#### 服务器

~~~C++
//.hpp
#pragma once

#include "udp_scoket.hpp"


namespace UDP
{
    class UdpServer
    {
    public:
        UdpServer()
        {
        }
        UdpServer(uint16_t port, std::string ip = "")
            : _port(port)
        {
            assert(_sock.Socket());
        }
        ~UdpServer()
        {
            _sock.Close();
        }

        bool Start(Handler handler)
        {
            //1. 创建套接字
            //2. 绑定端口号
            bool ret = _sock.Bind(_port);
            if (!ret)
            {
                return false;
            }

            std::cout << "Server Star" << std::endl;
            
            //3. 等待连接
            for (;;)
            {
                //4. 读取请求
                std::string req;
                std::string remote_ip;
                uint16_t remote_port = 0;
                bool ret = _sock.RecvFrom(&req, &remote_ip, &remote_port); //输入型参数
                if (!ret)
                    continue; //没读到数据，并不返回

                //5. 处理请求
                std::string resp;
                handler(req, &resp);

                //6. 返回请求
                _sock.Sendto(resp, remote_ip, remote_port);
                printf("[%s:%d] req: %s, resp: %s\n", remote_ip.c_str(), remote_port,
                       req.c_str(), resp.c_str());
            }

            //7. 关闭套接字   --基本不执行
            _sock.Close();
            return true;
        }

    private:
        UdpSocket _sock;
        std::string _ip;
        uint16_t _port;
    };
}

//.cc
#include "udp_server.hpp"

void RETURN(const std::string &req, std::string *resp)
{
    //可简单的一条一条回复
    // std::cout << req << std::endl;
    // std::string str;
    // std::getline(std::cin, str);
    // *resp = "Server # req is " + str;
    
     *resp = "\nServer # req is " + req;

}

//命令行提示
static void usage(std::string proc)
{
    std::cout << "\nUsage: " << proc << " port\n"
              << std::endl;
}

// ./udp_server port
int main(int argc, char *argv[])
{

    if (argc != 2)
    {
        usage(argv[0]);
    }
    UDP::UdpServer *Server = new UDP::UdpServer(atoi(argv[1]));

    Server->Start(RETURN);

    return 0;
}
~~~

#### 客户端

~~~C++

//.hpp

#pragma once

#include "udp_scoket.hpp"

namespace UDP
{
    class UdpClient
    {
    public:
        UdpClient()
        {
        }
        UdpClient(uint16_t port, std::string ip)
            : _server_port(port), _server_ip(ip)
        {
            assert(_sock.Socket());

            std::cout << "Client Star" << std::endl;

        }
        ~UdpClient()
        {
            _sock.Close();
        }

        //1. 创建套接字
        //2. 绑定端口号
        //3. 发送数据
        bool SendTo(const std::string &buf)
        {
            return _sock.Sendto(buf, _server_ip, _server_port);
        }
        //4. 接收数据
        bool RecvFrom(std::string *buf)
        {
            return _sock.RecvFrom(buf);
        }

    private:
        UdpSocket _sock;
        std::string _server_ip;
        uint16_t _server_port;
    };
}

//.cc
#include "udp_client.hpp"

//命令行提示
static void usage(std::string proc)
{
    std::cout << "\nUsage: " << proc << " ip : port\n"
              << std::endl;
}

// ./udp_server ip port
int main(int argc, char *argv[])
{

    if (argc != 3)
    {
        usage(argv[0]);
    }
    UDP::UdpClient *Client = new UDP::UdpClient(atoi(argv[2]), argv[1]);

    for (;;)
    {
        std::string req;
        std::string resp;
        std::cout << std::endl;
        std::getline(std::cin, req);

        Client->SendTo(req);
        Client->RecvFrom(&resp);
        std::cout << std::endl;

        std::cout << resp;
    }

    return 0;
}
~~~

#### 效果

![image-20230329191903739](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230329191903739.png)

![image-20230329191929985](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230329191929985.png)

#### 总结

##### 解耦合

##### netstat

##### telent

##### bzero

`extern void bzero(void *ptr, int n)`

### 模拟 xshell -- popen

#### 准备知识

popen函数

strcasestr函数

#### popen

**可以执行传入的命令**

`FILE *popen(const char *command, const char *type)`

`int pclose(FILE *stream)`

popen函数流程

> 1. pipe()创建管道：用于父子进程通信
> 2. fork()创建子进程，并替换为(exec*)command命令：子进程执行命令
> 3. FILE* ：可以将执行结果通过FILE*读取出来：保存执行结果
>

#### strcasestr

查找函数

#### 代码

更改RETURN即可

~~~c++
void RETURN(const std::string &req, std::string *resp)
{
    //req : 读取到的命令
    *resp = "Server # req is \n";

    //过滤 非法命令
    if(strcasestr(req.c_str(), "rm") != NULL || strcasestr(req.c_str(), "rmdir") != NULL )
    {
        *resp += "非法命令：rm/rmdir\n";
        return ;
    }

    char result[256];

    FILE *fp = popen(req.c_str(), "r");
    if(NULL == fp)
    {
        *resp += "ERROR : popen\n";
        return ;
    }
    while(fgets(result, sizeof(result), fp) != NULL)
    {
        *resp += result;
    }

    fclose(fp);
}
~~~

#### 效果

![image-20230403105555752](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230403105555752.png)

![image-20230403105533815](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230403105533815.png)



### 多人聊天--多线程

#### 准备知识

多线程

重定向

#### thread

~~~C++
#pragma once
#include <iostream>
#include <string>
#include <functional>
#include <cstdio>

// typedef std::function<void* (void*)> fun_t;
typedef void *(*fun_t)(void *);

class ThreadData
{
public:
    void *args_;
    std::string name_;
};

class Thread
{
public:
    Thread(int num, fun_t callback, void *args) : func_(callback)
    {
        char nameBuffer[64];
        snprintf(nameBuffer, sizeof nameBuffer, "Thread-%d", num);
        name_ = nameBuffer;

        tdata_.args_ = args;
        tdata_.name_ = name_;
    }
    void start()
    {
        pthread_create(&tid_, NULL, func_, (void*)&tdata_);
    }
    void join()
    {
        pthread_join(tid_, NULL);
    }
    std::string name()
    {
        return name_;
    }
    ~Thread()
    {
    }

private:
    std::string name_;
    fun_t func_;
    ThreadData tdata_;
    pthread_t tid_;
};
~~~

#### 客户端

~~~
#include "udp_client.hpp"
#include "thread.hpp"
#include <memory>

//命令行提示
static void usage(std::string proc)
{
    std::cout << "\nUsage: " << proc << " ip : port\n"
              << std::endl;
}

static void *udpSend(void *args)
{
    UDP::UdpClient *Client = (UDP::UdpClient *)(((ThreadData *)(args))->args_);
    std::string req;

    for (;;)
    {
        std::cout << std::endl;
        std::getline(std::cin, req);

        Client->SendTo(req);
    }
}
static void *udpRecv(void *args)
{
    UDP::UdpClient *Client = (UDP::UdpClient *)(((ThreadData *)(args))->args_);
    std::string resp;

    for (;;)
    {
        std::cout << std::endl;
        Client->RecvFrom(&resp);
        std::cout << resp;
    }
}

// ./udp_server ip port
int main(int argc, char *argv[])
{

    if (argc != 3)
    {
        usage(argv[0]);
    }
    UDP::UdpClient *Client = new UDP::UdpClient(atoi(argv[2]), argv[1]);

    std::unique_ptr<Thread> sender(new Thread(1, udpSend, (void *)Client));
    std::unique_ptr<Thread> recver(new Thread(2, udpRecv, (void *)Client));

    sender->start();
    recver->start();

    sender->join();
    recver->join();

    

    return 0;
}
~~~

#### 服务端

~~~C++
//.hpp
#pragma once
#include "udp_scoket.hpp"

namespace UDP
{
    class UdpServer
    {
    public:
        UdpServer()
        {
        }
        UdpServer(uint16_t port, std::string ip = "")
            : _port(port)
        {
            assert(_sock.Socket());
        }
        ~UdpServer()
        {
            _sock.Close();
        }

        bool Start(Handler handler)
        {
            //1. 创建套接字
            //2. 绑定端口号
            bool ret = _sock.Bind(_port);
            if (!ret)
            {
                return false;
            }

            std::cout << "Server Star" << std::endl;

            //3. 等待连接
            for (;;)
            {
                //4. 读取请求
                std::string req;
                std::string remote_ip;
                sockaddr_in peer;
                uint16_t remote_port = 0;
                bool ret = _sock.RecvFrom(&req, &remote_ip, &remote_port); //输入型参数
                if (!ret)
                    continue; //没读到数据，并不返回

                //保存用户
                auto it = _users.find(remote_ip);
                if (it == _users.end())
                {
                    sockaddr_in addr;
                    bzero(&addr, sizeof(addr));
                    addr.sin_family = AF_INET;
                    addr.sin_addr.s_addr = inet_addr(remote_ip.c_str());
                    addr.sin_port = htons(remote_port);

                    _users[remote_ip] = addr;
                }

                //5. 处理请求
                std::string resp;
                handler(req, &resp, remote_ip);

                //6. 返回请求
                for(auto it = _users.begin(); it != _users.end(); ++ it)
                {
                     _sock.Sendto(resp, inet_ntoa(it->second.sin_addr), ntohs(it->second.sin_port));
                }
                printf("[%s:%d] req: %s\n", remote_ip.c_str(), remote_port, req.c_str());
            }

            //7. 关闭套接字   --基本不执行
            _sock.Close();
            return true;
        }

    private:
        UdpSocket _sock;
        std::string _ip;
        uint16_t _port;
        std::unordered_map<std::string, sockaddr_in> _users;
        std::queue<std::string> messageQueue;
    };
}
//.cc
#include "udp_server.hpp"

void RETURN(const std::string &req, std::string *resp, const std::string &srcIp)
{
    // //可简单的一条一条回复
    // std::cout << req << std::endl;
    // //std::string str;
    // //std::getline(std::cin, str);
    //  *resp = "Server # req is " + req + '\n';


    // //req : 读取到的命令
    // *resp = "Server # req is \n";
    // //过滤 非法命令
    // if(strcasestr(req.c_str(), "rm") != NULL || strcasestr(req.c_str(), "rmdir") != NULL )
    // {
    //     *resp += "非法命令：rm/rmdir\n";
    //     return ;
    // }
    // char result[256];
    // FILE *fp = popen(req.c_str(), "r");
    // if(NULL == fp)
    // {
    //     *resp += "ERROR : popen\n";
    //     return ;
    // }
    // while(fgets(result, sizeof(result), fp) != NULL)
    // {
    //     *resp += result;
    // }
    // fclose(fp);

    *resp = '[' + srcIp + "] " + req + '\n';
    
}

//命令行提示
static void usage(std::string proc)
{
    std::cout << "\nUsage: " << proc << " port\n"
              << std::endl;
}

// ./udp_server port
int main(int argc, char *argv[])
{

    if (argc != 2)
    {
        usage(argv[0]);
    }
    UDP::UdpServer *Server = new UDP::UdpServer(atoi(argv[1]));

    Server->Start(RETURN);

    return 0;
}
~~~

其他不变

**进行输出重定向，将输入和输出进行窗口分离**

### Windows客户端

有bug

~~~
#pragma warning(disable:4996)
#include <WinSock2.h>
#include <iostream>
#include <string>

using namespace std;
#pragma comment(lib,"ws2_32.lib") //固定用法

uint16_t serverport = 8080;
std::string serverip = "123.249.100.5";

int main()
{
	// windows 独有的
	WSADATA WSAData;
	WORD sockVersion = MAKEWORD(2, 2);
	if (WSAStartup(sockVersion, &WSAData) != 0)
		return 0;

	SOCKET clientSocket = socket(AF_INET, SOCK_DGRAM, 0);
	if (INVALID_SOCKET == clientSocket)
	{
		cout << "socket error!";
		return 0;
	}

	sockaddr_in dstAddr;
	dstAddr.sin_family = AF_INET;
	dstAddr.sin_port = htons(serverport);
	dstAddr.sin_addr.S_un.S_addr = inet_addr(serverip.c_str());

	char buffer[1024];

	while (true)
	{
		std::string message;
		std::cout << "请输入# ";
		std::getline(std::cin, message);
		sendto(clientSocket, message.c_str(), (int)message.size(), 0, (sockaddr*)&dstAddr, sizeof(dstAddr));

		struct sockaddr_in temp;
		int len = sizeof(temp);
		int s = recvfrom(clientSocket, buffer, sizeof buffer, 0, (sockaddr*)&temp, &len);
		if (s > 0)
		{
			buffer[s] = '\0';
			std::cout << "server echo# " << buffer << std::endl;
		}
	}

	// windows 独有
	closesocket(clientSocket);
	WSACleanup();

	return 0;
}
~~~



## TCP编程

### 回声服务器

#### 准备知识

##### listen函数

> `int listen(int sockfd, int backlog);`
>
> 参数说明：
>
> - sockfd：需要设置为监听状态的套接字对应的文件描述符。
> - backlog：全连接队列的最大长度。如果有多个客户端同时发来连接请求，此时未被服务器处理的连接就会放入连接队列，该参数代表的就是这个全连接队列的最大长度，一般不要设置太大，设置为5或10即可。
>
> 返回值说明：
>
> - 监听成功返回0，监听失败返回-1，同时错误码会被设置。

##### accept函数

> `int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);`
>
> 参数说明：
>
> - sockfd：特定的监听套接字，表示从该监听套接字中获取连接。
> - addr：对端网络相关的属性信息，包括协议家族、IP地址、端口号等。
> - addrlen：调用时传入期望读取的addr结构体的长度，返回时代表实际读取到的addr结构体的长度，这是一个输入输出型参数。
>
> 返回值说明：
>
> - 获取连接成功返回接收到的套接字的文件描述符，获取连接失败返回-1，同时错误码会被设置。
>     

##### connect函数

> `int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`
>
> 参数说明：
>
> - sockfd：特定的套接字，表示通过该套接字发起连接请求。
> - addr：对端网络相关的属性信息，包括协议家族、IP地址、端口号等。
> - addrlen：传入的addr结构体的长度。
>
> 返回值说明：
>
> - 连接或绑定成功返回0，连接失败返回-1，同时错误码会被设置。

##### inet_pton转换函数

> ~~~C++
> #include <arpe/inet.h>
> int inet_pton(int family, const char *strptr, void *addrptr);
>  inet_pton(AF_INET, ip.c_str(), &(local.sin_addr)); // 主机转网络
> ~~~
>
> 参数说明：
>
> - family：协议家族。
> - strptr：字节流IP。
> - addrptr：结构体的IP成员变量的地址。
>
> 返回值说明：
>
> - 若成功则为1，若输入不是有效的表达式则为0，若出错则为-1

##### 文件IO

##### 注意事项：写在编码后

---

#### 创建套接字

客户端和服务器都需要创建套接字，但是两者的含义是有区别

- 客户端创建的套接字，就是用来通信的
- 服务器创建的套接字，是用来监听通信的，监测是否有通信请求，并通过该套接字获取通信请求，获取通信套接字

所以，前者创建的是通信套接字，后者创建的是监听套接字。在这个阶段并没有区别。

~~~C++
int Socket()
        {
            //1. 创建套接字
            int sock = socket(AF_INET, SOCK_STREAM, 0);
            if (sock < 0) // 失败返回-1
            {
                std::cout << "创建监听套接字失败" << std::endl;
                assert(false);
            }

            return sock;
        }
~~~

#### 绑定套接字

客户端不需要显示绑定

~~~C++
void Bind(int sockfd, uint16_t port, const std::string &ip = "0.0.0.0")
        {
            // 2. 绑定套接字

            // a. 创建sockaddr_in结构体
            sockaddr_in local;
            bzero(&local, sizeof(local)); //全部初始化为0
    
            local.sin_family = AF_INET;   // 通信类型
            local.sin_port = htons(port); // 主机转网络
            inet_pton(AF_INET, ip.c_str(), &(local.sin_addr)); // 主机转网络
            
            // b. 绑定
            if (bind(sockfd, (sockaddr *)&local, sizeof(local)) < 0)
            {
                std::cout << "bind error" << std::endl;
                assert(false);
            }
        }
~~~



#### 监听套接字

服务器需要监听套接字，即监听通信请求

~~~C++
void Listen(int sockfd)
        {
            // 3. 监听
            if (listen(sockfd, _gbacklog) < 0)
            {
                assert(false);
            }
        }
~~~

#### 请求连接

TCP是面向链接的通信，通信前需要先请求连接

~~~C++
bool Connect(int socket, const std::string &server_ip, const uint16_t &server_port)
        {
            //请求连接
            sockaddr_in server;
            bzero(&server, sizeof(server));
            server.sin_family = AF_INET;
            server.sin_port = htons(server_port);
            server.sin_addr.s_addr = inet_addr(server_ip.c_str());

            if (connect(socket, (sockaddr *)&server, sizeof(server)) == 0)
                return true;
            else
                return false;
        }
~~~



#### 获取连接

从监听套接字获取链接，代表服务器已经和某一个客户端建立了通信链接，获取的是用来和该客户端通信的套接字

~~~C++
int Accept(int listenSock, std::string *ip, uint16_t *port)
{
    // 4. 获取连接， 获取通信套接字
    // UDP不需要连接，服务端是一对多的
    // 而TCP是需要连接的，是一对一的
    // 此时，通信准备已经做好了
    sockaddr_in src;
    socklen_t len = sizeof(src);

    int serviceSock = accept(listenSock, (sockaddr *)&src, &len);
    if (serviceSock < 0)
    {
        assert(false);
    }

    //关系通信方身份信息
    if (port)
        *port = ntohs(src.sin_port);
    if (ip)
        *ip = inet_ntoa(src.sin_addr);
    return serviceSock;
}
~~~

#### 发送/读取

TCP是基于字节流的通信协议，我们使用的是read/wrtie进行读取/发送，OS会帮我们发送给对端。姑且认为，write就是将数据发送给对端，read就是读到了对端发送的数据。

#### 实现

##### TCP_socket.hpp

~~~C++
#pragma once

#define SIZE 1024

#include <sys/types.h>  //通信类型
#include <sys/socket.h> //套接字函数
#include <netinet/in.h> //结构体
#include <arpa/inet.h>  //结构体
#include <ctype.h>

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <cstring>

#include <queue>
#include <unordered_map>

#include <unistd.h> //文件操作

typedef void (*Handler)(const std::string &req, std::string *resp);
// #include <functional>
// typedef std::function<void(const std::string &, std::string *resp)> Handler;

typedef struct sockaddr_in sockaddr_in;
typedef struct sockaddr sockaddr;

namespace TCP
{
    class TcpSocket
    {
    public:
        TcpSocket(int num = 5)
        :_gbacklog(num)
        {
        }
        int Socket()
        {
            //1. 创建套接字
            int sock = socket(AF_INET, SOCK_STREAM, 0);
            if (sock < 0) // 失败返回-1
            {
                std::cout << "创建监听套接字失败" << std::endl;
                assert(false);
            }

            return sock;
        }
        void Bind(int sockfd, uint16_t port, const std::string &ip = "0.0.0.0")
        {
            // 2. 绑定套接字

            // a. 创建sockaddr_in结构体
            sockaddr_in local;
            bzero(&local, sizeof(local)); //全部初始化为0
            local.sin_family = AF_INET;   // 通信类型
            local.sin_port = htons(port); // 主机转网络
            
            inet_pton(AF_INET, ip.c_str(), &(local.sin_addr)); // 主机转网络
            
            // b. 绑定
            if (bind(sockfd, (sockaddr *)&local, sizeof(local)) < 0)
            {
                std::cout << "bind error" << std::endl;
                assert(false);
            }
        }
        void Listen(int sockfd)
        {
            // 3. 监听
            if (listen(sockfd, _gbacklog) < 0)
            {
                assert(false);
            }
        }
        
        // const &输入
        // * 输出
        // & 输入&&输出
        int Accept(int listenSock, std::string *ip, uint16_t *port)
        {
            // 4. 获取连接， 获取通信套接字
            // UDP不需要连接，服务端是一对多的
            // 而TCP是需要连接的，是一对一的
            // 此时，通信准备已经做好了
            sockaddr_in src;
            socklen_t len = sizeof(src);

            int serviceSock = accept(listenSock, (sockaddr *)&src, &len);
            if (serviceSock < 0)
            {
                assert(false);
            }

            //关系通信方身份信息
            if (port)
                *port = ntohs(src.sin_port);
            if (ip)
                *ip = inet_ntoa(src.sin_addr);
            return serviceSock;
        }
        bool Connect(int socket, const std::string &server_ip, const uint16_t &server_port)
        {
            //请求连接
            sockaddr_in server;
            bzero(&server, sizeof(server));
            server.sin_family = AF_INET;
            server.sin_port = htons(server_port);
            server.sin_addr.s_addr = inet_addr(server_ip.c_str());

            if (connect(socket, (sockaddr *)&server, sizeof(server)) == 0)
                return true;
            else
                return false;
        }

        ~TcpSocket()
        {
        }

    private:
        const int _gbacklog;
    };
}


~~~



##### tcp_server

~~~C++
//.hpp
#pragma once

#include "TCP_scoket.hpp"

namespace TCP
{
    class TcpServer
    {
    public:
        TcpServer(const uint16_t &port, const std::string &ip = "", const int gbl = 5)
            : _port(port), _ip(ip), _gblaklog(gbl)
        {

            // 1.创建套接字
            _listen_sock = _sock.Socket();
            assert(_listen_sock != -1);
            
            // 2.绑定监听套接字
            _sock.Bind(_listen_sock, _port);

            
            // 3.监听套接字
            _sock.Listen(_listen_sock);

            std::cout << "server start" << std::endl;
        }

        void Service(int sock, std::string srcIp, int srcPort, Handler handler)
        {
            char buffer[1024];

            //直到通信关闭
            while (true)
            {
                ssize_t size = read(sock, buffer, sizeof(buffer) - 1);
                if (size > 0)
                {
                    buffer[size] = '\0';

                    std::string req = buffer;
                    std::string resp;
                    handler(req, &resp);
                    std::cout << '[' << srcIp << ':' << srcPort << "]# " << req << std::endl;
                    write(sock, resp.c_str(), resp.size());
                }
                if (size == 0) //客户端关闭
                {
                    std::cout << srcIp << " close" << std::endl;
                    break;
                }
                if (size < 0) //读取失败
                {
                    std::cout << "read error" << std::endl;
                    break;
                }
            }
            close(sock);
        }

        void Start(Handler handler)
        {
            while (true)
            {
                // 4. 获取链接
                // a. 保存通信方信息
                std::string srcIp;
                uint16_t srcPort;
                int sock = _sock.Accept(_listen_sock, &srcIp, &srcPort);
                if (sock < 0)
                    continue;
                
                //当前服务器只能执行一条通信
                //一个结束才能另一个

                Service(sock, srcIp, srcPort, handler);

            }

            
        }

    private:
        TcpSocket _sock;
        int _listen_sock;

        uint16_t _port;
        std::string _ip;

        int _gblaklog;
    };
}


//.cc
#include "tcp_server.hpp"

static void usage(std::string proc)
{
    std::cout << "\nUsage: " << proc << " port\n" << std::endl;
}

void handler(const std::string &req, std::string *resp)
{
    *resp = "server# " + req + '\n';
}

//./server 8080


int main(int argc, char* argv[])
{
    if(argc != 2)
    {
        usage(argv[0]);
        exit(1);
    }

    uint16_t port = atoi(argv[1]);
   

    TCP::TcpServer Server(port);
    
    Server.Start(handler);
    
    return 0;

}
~~~



##### tcp_client

~~~C++

//.hpp
#include "TCP_scoket.hpp"

namespace TCP
{
    class TcpClient
    {
    public:
        TcpClient(const uint16_t &descPort, const std::string &descIp)
            : _server_port(descPort), _server_ip(descIp)
        {

            // 1.创建套接字
            _sockfd = _sock.Socket();
            assert(_sockfd != -1);

            // 2.绑定套接字

            std::cout << "Client start" << std::endl;
        }

        void Request(std::string srcIp, int srcPort)
        {
            char buffer[1024];
            std::string req, resp;
            //直到通信关闭
            while (true)
            {
                std::cout << "Please Enter# ";
                std::getline(std::cin, req);

                write(_sockfd, req.c_str(), req.size());

                ssize_t size = read(_sockfd, buffer, sizeof(buffer) - 1);
                if (size > 0)
                {
                    buffer[size] = '\0';
                    resp = buffer;
                    std::cout << resp << std::endl;
                }
                if (size == 0) //服务端关闭
                {
                    std::cout << srcIp << "close" << std::endl;
                    break;
                }
                if (size < 0) //读取失败
                {
                    std::cout << "read error" << std::endl;
                    break;
                }
            }
        
        }
        void Start()
        {

            if (_sock.Connect(_sockfd, _server_ip, _server_port))
            {
                Request(_server_ip, _server_port);
            }
            close(_sockfd);

            std::cout << "client end" << std::endl;
        }

    private:
        TcpSocket _sock;
        int _sockfd;

        uint16_t _server_port;
        std::string _server_ip;
    };
}

//.cc
#include"tcp_client.hpp"

void Usage(std::string proc)
{
	std::cout << "Usage: " << proc << "server_ip server_port" << std::endl;
}

int main(int argc, char* argv[])
{
	if (argc != 3){
		Usage(argv[0]);
		exit(1);
	}
	std::string server_ip = argv[1];
	uint16_t server_port = atoi(argv[2]);
	TCP::TcpClient Client( server_port, server_ip);
	Client.Start();
	return 0;
}

~~~

![image-20230404185530763](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230404185530763.png)

![image-20230404185547099](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230404185547099.png)

### 多进程版本

单进程回声服务器只能串行的处理客户端请求，只有一个客户端关闭连接后，才能处理另一个。

这个版本我们实现一个多进程的回声服务器，并发执行多个客户端请求。

#### 准备知识

父子进程：资源继承/执行流判断

进程等待：阻塞等待/非阻塞等待/不等待

关闭资源

**setsockopt函数**

> 在TCP连接中，先退出的一方会维持一段时间的TIME_WAIT状态，该状态下的套接字不会立即释放它所申请的资源
> 只有过了2MSL时间，才会释放资源，比如释放端口号，fd等，则这段时间内，一些系统资源是不能使用的，使用setsockopt函数进行socket地址复用，对应的套接字不等待TIME_WAIT状态退出，强制忽略该状态，使用相应的系统资源，当然需要保证这些系统资源是属于TIME_WAIT状态的
> https://www.cnblogs.com/cthon/p/9270778.html
> https://zhuanlan.zhihu.com/p/145635380#:~:text=%E8%AE%BE%E7%BD%AEsocket%E7%9A%84SO_REUSEADDR%E9%80%89%E9%A1%B9%EF%BC%8C%E5%8D%B3%E5%8F%AF%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%EF%BC%9A%20int%20opt%20%3D%201%3B%20%2F%2F%20sockfd%E4%B8%BA%E9%9C%80%E8%A6%81%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E7%9A%84%E5%A5%97%E6%8E%A5%E5%AD%97%20setsockopt,%28sockfd%2C%20SOL_SOCKET%2C%20SO_REUSEADDR%2C%20%28const%20void%20%2A%29%26opt%2C%20sizeof%20%28opt%29%29%3B
>
> `setsockopt(sock, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt));`
>
> - SO_REUSEADDR：允许sock复用端口号
> - SO_REUSEPORT：使sock绑定端口号时，不需要关心port是否在TIME_WAIT状态

shell脚本：while :; do ps axj | head -1 && ps axj | grep tcp_server | grep -v grep;echo "######################";sleep 1;done

难点：谁在执行处理数据的任务？

##### 注意事项

#### 改造服务器代码

Linux默认情况下需要父进程等待子进程退出，这是阻塞的，那么我们就需要改造代码，使服务器进程不关心任务进程的状态。

##### 信号

~~~C++
#include "TCP_scoket.hpp"

namespace TCP
{
    class TcpClient
    {
    public:
        TcpClient(const uint16_t &descPort, const std::string &descIp)
            : _server_port(descPort), _server_ip(descIp)
        {

            // 1.创建套接字
            _sockfd = _sock.Socket();
            assert(_sockfd != -1);

            // 2.绑定套接字

            std::cout << "Client start" << std::endl;
        }

        void Request(std::string srcIp, int srcPort)
        {
            char buffer[1024];
            std::string req, resp;
            //直到通信关闭
            while (true)
            {
                std::cout << "Please Enter# ";
                std::getline(std::cin, req);

                write(_sockfd, req.c_str(), req.size());

                ssize_t size = read(_sockfd, buffer, sizeof(buffer) - 1);
                if (size > 0)
                {
                    buffer[size] = '\0';
                    resp = buffer;
                    std::cout << resp << std::endl;
                }
                if (size == 0) //服务端关闭
                {
                    std::cout << srcIp << " close" << std::endl;
                    break;
                }
                if (size < 0) //读取失败
                {
                    std::cout << "read error" << std::endl;
                    break;
                }
            }
        
        }
        void Start(Handler handler)
        {
            //信号
            signal(SIGCHLD, SIG_IGN);//忽略子进程退出
            while (true)
            {
                // 4. 获取链接
                // a. 保存通信方信息
                std::string srcIp;
                uint16_t srcPort;
                int sock = _sock.Accept(_listen_sock, &srcIp, &srcPort);
                if (sock < 0)
                    continue;
                
                //子进程执行处理，父进程继续获取链接
                pid_t pid = fork();
                if(pid == 0)
                {
                    close(_listen_sock);//子进程不需要关心监听套接字
                    Service(sock, srcIp, srcPort, handler);
                    exit(0);
                }
                close(sock);//父进程不需要关心通信套接字
                //已经忽略了子进程退出，不需要等待
                

            }

    private:
        TcpSocket _sock;
        int _sockfd;

        uint16_t _server_port;
        std::string _server_ip;
    };
}
~~~

![image-20230405151038139](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230405151038139.png)

![image-20230405151049478](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230405151049478.png)

##### 孙子进程

~~~C++
#pragma once

#include "TCP_scoket.hpp"

namespace TCP
{
    class TcpServer
    {
    public:
        TcpServer(const uint16_t &port, const std::string &ip = "", const int gbl = 5)
            : _port(port), _ip(ip), _gblaklog(gbl)
        {

            // 1.创建套接字
            _listen_sock = _sock.Socket();
            assert(_listen_sock != -1);
            
            // 2.绑定监听套接字
            _sock.Bind(_listen_sock, _port);

            
            // 3.监听套接字
            _sock.Listen(_listen_sock);

            std::cout << "server start" << std::endl;
        }

        void Service(int sock, std::string srcIp, int srcPort, Handler handler)
        {
            
            char buffer[1024];

            //直到通信关闭
            while (true)
            {
                ssize_t size = read(sock, buffer, sizeof(buffer) - 1);
                if (size > 0)
                {
                    buffer[size] = '\0';

                    std::string req = buffer;
                    std::string resp;
                    handler(req, &resp);
                    std::cout << '[' << srcIp << ':' << srcPort << "]# " << req << std::endl;
                    write(sock, resp.c_str(), resp.size());
                }
                if (size == 0) //客户端关闭
                {
                    std::cout << srcIp << " close" << std::endl;
                    break;
                }
                if (size < 0) //读取失败
                {
                    std::cout << "read error" << std::endl;
                    break;
                }
            }
            close(sock);
        }

        void Start(Handler handler)
        {
            // //信号
            // signal(SIGCHLD, SIG_IGN);//忽略子进程退出
            while (true)
            {
                // 4. 获取链接
                // a. 保存通信方信息
                std::string srcIp;
                uint16_t srcPort;
                int sock = _sock.Accept(_listen_sock, &srcIp, &srcPort);
                if (sock < 0)
                    continue;

                //子进程执行处理，父进程继续获取链接
                pid_t pid = fork();
                if(pid == 0)
                {
                    close(_listen_sock);//子进程不需要关心监听套接字
                    if(fork() > 0)
                    {
                        exit(0);//子进程退出--会关闭资源
                    }
                    Service(sock, srcIp, srcPort, handler);//孙子进程处理通信连接
                    exit(0);//孤儿进程，init接管
                    
                }
                close(sock);//父进程不需要关心通信套接字
                waitpid(pid, nullptr, 0);//子进程已退出
                

            }

            
        }

    private:
        TcpSocket _sock;
        int _listen_sock;

        uint16_t _port;
        std::string _ip;

        int _gblaklog;
    };
}
~~~

![image-20230405151718371](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230405151718371.png)

![image-20230405151733402](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230405151733402.png)

### 多线程版本

#### 准备知识

线程创建

线程分离

shell脚本：while :; do ps -aL|head -1&&ps -aL|grep tcp_server;echo "####################";sleep 1;done

**客户端写不能为空：死锁**

完善客户端请求连接功能：客户端循环请求链接，直到成功

谁在执行处理数据的任务？

#### 实现

[多线程](https://github.com/tianen1573/LINUX/tree/main/TCP/TCP_3)

### 线程池版本

#### 准备知识

RAII + 互斥锁

> RAII不用关心互斥锁的释放，但如果处理不好，会增加临界区使用时间，增加互斥时间，建议配合使用{}

条件变量

超级无敌超级多的回调

单例模式：锁与判断

运算符重载

任务类

谁在执行处理数据的任务，和之前的区别

服务器功能的变换只需要改变回调服务器函数即可

##### 注意事项

#### 实现

[TCP线程池版本](https://github.com/tianen1573/LINUX/tree/main/TCP/TCP_4)

## 总结

socket编程API

创建套接字：进程+文件

绑定套接字：文件+网络

# 网络协议

## 协议是什么

协议，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定，比如怎么建立连接、怎么互相识别等。

为了使数据在网络上能够从源到达目的，网络通信的参与方必须遵循相同的规则，我们将这套规则称为协议（protocol），而协议最终都需要通过计算机语言的方式表示出来。只有通信计算机双方都遵守相同的协议，计算机之间才能互相通信交流。

**模拟实现一个网络版计算器，来认识协议。**

### 结构化数据的传输

通信双方在进行网络通信时：

- 如果需要传输的数据是一个字符串，那么直接将这一个字符串发送到网络当中，此时对端也能从网络当中获取到这个字符串。
- 但如果需要传输的是一些结构化的数据，此时就不能将这些数据一个个发送到网络当中。

比如现在要实现一个网络版的计算器，那么客户端每次给服务端发送的请求数据当中，就需要包括左操作数、右操作数以及对应需要进行的操作，此时客户端要发送的就不是一个简单的字符串，而是一组结构化的数据。

如果客户端将这些结构化的数据单独一个个的发送到网络当中，那么服务端从网络当中获取这些数据时也只能一个个获取，此时服务端还需要纠结如何将接收到的数据进行组合。因此客户端最好把这些结构化的数据打包后统一发送到网络当中，此时服务端每次从网络当中获取到的就是一个完整的请求数据，客户端常见的“打包”方式有以下两种。

1. 将结构化的数据组合成一个字符串

    > 约定方案一：
    >
    > - 客户端发送一个形如“1+1”的字符串。
    > - 这个字符串中有两个操作数，都是整型。
    > - 两个数字之间会有一个字符是运算符。
    > - 数字和运算符之间没有空格。
    >
    > 客户端可以按某种方式将这些结构化的数据组合成一个字符串，然后将这个字符串发送到网络当中，此时服务端每次从网络当中获取到的就是这样一个字符串，然后服务端再以相同的方式对这个字符串进行解析，此时服务端就能够从这个字符串当中提取出这些结构化的数据。
    > 

2. 定制结构体+序列化和反序列化

    > 约定方案二：
    >
    > - 定制结构体来表示需要交互的信息。
    > - 发送数据时将这个结构体按照一个规则转换成网络标准数据格式，接收数据时再按照相同的规则把接收到的数据转化为结构体。
    > - 这个过程叫做“序列化”和“反序列化”。
    >
    > 客户端可以定制一个结构体，将需要交互的信息定义到这个结构体当中。客户端发送数据时先对数据进行序列化，服务端接收到数据后再对其进行反序列化，此时服务端就能得到客户端发送过来的结构体，进而从该结构体当中提取出对应的信息。

3.  总结

    > 结构化数据+序列化字节流，网络通信的两种数据结构
    >
    > 结构化数据：上层业务使用，规定字段
    >
    > 序列化字节流：网络传输使用，按一定规则将结构化的数据转化为字节流

### 序列化和反序列化

**序列化和反序列化**：

- 序列化是将对象的状态信息转换为可以存储或传输的形式（字节序列）的过程。
- 反序列化是把字节序列恢复为对象的过程。

OSI七层模型中表示层的作用就是，实现设备固有数据格式和网络标准数据格式的转换。其中设备固有的数据格式指的是数据在应用层上的格式，而网络标准数据格式则指的是序列化之后可以进行网络传输的数据格式。

**序列化和反序列化的目的**

- 在网络传输时，序列化目的是为了方便网络数据的发送和接收，无论是何种类型的数据，经过序列化后都变成了二进制序列，此时底层在进行网络数据传输时看到的统一都是二进制序列。
- 序列化后的二进制序列只有在网络传输时能够被底层识别，上层应用是无法识别序列化后的二进制序列的，因此需要将从网络中获取到的数据进行反序列化，将二进制序列的数据转换成应用层能够识别的数据格式。

我们可以认为网络通信和业务处理处于不同的层级，在进行网络通信时底层看到的都是二进制序列的数据，而在进行业务处理时看得到则是可被上层识别的数据。如果数据需要在业务处理和网络通信之间进行转换，则需要对数据进行对应的序列化或反序列化操作。

![image-20230407133658602](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230407133658602.png)

### 网络计算器

#### 理论知识

服务器准备写回/正在写回的时候 客户端读文件的进程关闭

数据报和字节流的区别

数据报的发送和读取控制，能够保证每次都是读到一条，而字节流不能确定，必须由协议进行控制 

守护进程

jsoncpp库

TCP协议序列号

安装jsoncpp

#### 实现



## HTTP协议

> HTTP（Hyper Text Transfer Protocol）协议又叫做超文本传输协议，是一个简单的请求-响应协议，HTTP通常运行在TCP之上，是基于TCP的应用层协议。版本不同，HTTP协议使用的传输层协议也是不同的。
>
> 在编写网络通信代码时，我们可以自己进行协议的定制，但实际有很多优秀的工程师早就已经写出了许多非常成熟的应用层协议，其中最典型的就是HTTP协议。

### URL

> URL（Uniform Resource Lacator）叫做统一资源定位符，也就是我们通常所说的网址，是因特网的万维网服务程序上用于指定信息位置的表示方法。

一个URL大致由如下几部分构成：

![image-20230407134844117](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230407134844117.png)

#### 协议方案名

`http://`表示的是协议名称，表示请求时需要使用的协议，通常使用的是HTTP协议或安全协议HTTPS。HTTPS是以安全为目标的HTTP通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。

常见的应用层协议：

- DNS（Domain Name System）协议：域名系统。
- FTP（File Transfer Protocol）协议：文件传输协议。
- TELNET（Telnet）协议：远程终端协议。
- HTTP（Hyper Text Transfer Protocol）协议：超文本传输协议。
- HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer）协议：安全数据传输协议。
- SMTP（Simple Mail Transfer Protocol）协议：电子邮件传输协议。
- POP3（Post Office Protocol - Version 3）协议：邮件读取协议。
- SNMP（Simple Network Management Protocol）协议：简单网络管理协议。
- TFTP（Trivial File Transfer Protocol）协议：简单文件传输协议。

#### 登录信息

`usr:pass`表示的是登录认证信息，包括登录用户的用户名和密码。虽然登录认证信息可以在URL中体现出来，但绝大多数URL的这个字段都是被省略的，因为登录信息可以通过其他方案交付给服务器。

#### 服务器地址

`www.example.jp`表示的是服务器地址，也叫做域名，比如`www.alibaba.com`，`www.qq.com`，`www.baidu.com`。

需要注意的是，我们用IP地址标识公网内的一台主机，但IP地址本身并不适合给用户看。比如说我们可以通过ping命令，分别获得w`ww.baidu.com`和`www.qq.com`这两个域名解析后的IP地址。
![image-20230407135104988](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230407135104988.png)

如果用户看到的是这两个IP地址，那么用户在访问这个网站之前并不知道这两个网站到底是干什么的，但如果用户看到的是`www.baidu.com`和`www.qq.com`这两个域名，那么用户至少知道这两个网站分别对应的是哪家公司，因此**域名具有更好的自描述性**。

实际我们可以认为域名和IP地址是等价的，在计算机当中使用的时候既可以使用域名，也可以使用IP地址。但URL呈现出来是可以让用户看到的，因此URL当中是以域名的形式表示服务器地址的。

**域名是给人看的，IP地址是给计算机看的**

#### 服务器端口号

`80`表示的是服务器端口号。HTTP协议和套接字编程一样都是位于应用层的，在进行套接字编程时我们需要给服务器绑定对应的IP和端口，而这里的应用层协议也同样需要有明确的端口号。

常见协议对应的端口号：

| **协议名称** | **对应端口号** |
| ------------ | -------------- |
| HTTP         | 80             |
| HTTPS        | 443            |
| SSH          | 22             |

#### 带层次的文件路径

`/dir/index.htm`表示的是要访问的资源所在的路径。访问服务器的目的是获取服务器上的某种资源，通过前面的域名和端口已经能够找到对应的服务器进程了，此时要做的就是指明该资源所在的路径。

比如我们打开浏览器输入百度的域名后，此时浏览器就帮我们获取到了百度的首页。

![image-20230407140339165](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230407140339165.png)

当我们发起网页请求时，本质是获得了这样的一张网页信息，然后浏览器对这张网页信息进行解释，最后就呈现出了对应的网页。

![img](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/5271b3532c0f4368a8e286763b0bc0dc.png)

我们可以将这种资源称为网页资源，此外我们还会向服务器请求视频、音频、网页、图片等资源。HTTP之所以叫做超文本传输协议，而不叫做文本传输协议，就是因为有很多资源实际并不是普通的文本资源。

因此在URL当中就有这样一个字段，用于表示要访问的资源所在的路径。此外我们可以看到，这里的路径分隔符是`/`，而不是`\`，这也就证明了实际很多服务都是部署在Linux上的。

#### 查询字符串

`uid=1`表示的是请求时提供的额外的参数，这些参数是以键值对的形式，通过`&`符号分隔开的。

比如我们在百度上面搜索HTTP，此时可以看到URL中有很多参数，而在这众多的参数当中有一个参数wd（word），表示的就是我们搜索时的搜索关键字`wd=HTTP`。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/9b1ba20a1d7a41e38a5584fb49d51293-16808475475595.png)

因此双方在进行网络通信时，是能够通过URL进行用户数据传送的。

#### 片段标识符

`ch1`表示的是片段标识符，是对资源的部分补充。

比如我们在看组图的时候，URL当中就会出现片段标识符。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/1f547ead939e445d9db5d2ff918eee15-168084765351611.png)

当我们在翻看组图时，这个片段标识符就会发生变化。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/b0bdae23d23a48d5b5fe5d79b3e9d0e7-168084767331515.png)

#### urlencode和urldecode

如果在搜索关键字当中出现了像`/?:`这样的字符，由于这些字符已经被URL当作特殊意义理解了，因此URL在呈现时会对这些特殊字符进行转义。

转义的规则如下：

- 将需要转码的字符转为十六进制，然后从右到左，取4位（不足4位直接处理），每两位做一位，前面加上%，编码成%XY格式。

比如当我们搜索C++时，由于`+`加号在URL当中也是特殊符号，而`+`字符转为十六进制后的值就是`0x2B`，因此一个`+`就会被编码成一个`%2B`。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/1e1d38db01754754a6e18ced0ec27175-168084789644019.png)

**URL当中除了会对这些特殊符号做编码，对中文也会进行编码。**

在线编码工具：

- http://tool.chinaz.com/tools/urlencode.aspx

### HTTP协议格式

应用层常见的协议有HTTP和HTTPS，传输层常见的协议有TCP，网络层常见的协议是IP，数据链路层对应的就是MAC帧了。其中下三层是由操作系统或者驱动帮我们完成的，它们主要负责的是通信细节。如果应用层不考虑下三层，在应用层自己的心目当中，它就可以认为自己是在和对方的应用层在直接进行数据交互。
![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/e5d2972261354c5ea53f99e59158aad0-168084814630423.png)

下三层负责的是通信细节，而应用层负责的是如何使用传输过来的数据，两台主机在进行通信的时候，应用层的数据能够成功交给对端应用层，因为网络协议栈的下三层已经负责完成了这样的通信细节，而如何使用传输过来的数据就需要我们去定制协议，这里最典型的就是HTTP协议。

HTTP是基于请求和响应的应用层服务，作为客户端，你可以向服务器发起request，服务器收到这个request后，会对这个request做数据分析，得出你想要访问什么资源，然后服务器再构建response，完成这一次HTTP的请求。这种基于request&response这样的工作方式，我们称之为cs或bs模式，其中c表示client，s表示server，b表示browser。

由于HTTP是基于请求和响应的应用层访问，因此我们必须要知道HTTP对应的请求格式和响应格式，这就是学习HTTP的重点。

#### HTTP请求

##### HTTP请求协议格式如下：

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/65b49ea37f4448228cf27699937a33be-168084825831227.png)

HTTP请求由以下四部分组成：

- **请求行：[请求方法]+[url]+[http版本]**
- **请求报头：请求的属性，这些属性都是以key: value的形式按行陈列的。**
- **空行：遇到空行表示请求报头结束。**
- **请求正文：请求正文允许为空字符串，如果请求正文存在，则在请求报头中会有一个Content-Length属性来标识请求正文的长度。**

其中，前面三部分一般是HTTP协议自带的，是由HTTP协议自行设置的，而请求正文一般是用户的相关信息或数据，如果用户在请求时没有信息要上传给服务器，此时请求正文就为空字符串。

##### 如何将HTTP请求的报头与有效载荷进行分离？

当应用层收到一个HTTP请求时，它必须想办法将HTTP的报头与有效载荷进行分离。对于HTTP请求来讲，这里的请求行和请求报头就是HTTP的报头信息，而这里的请求正文实际就是HTTP的有效载荷。

我们可以根据HTTP请求当中的空行来进行分离，当服务器收到一个HTTP请求后，就可以按行进行读取，如果读取到空行则说明已经将报头读取完毕，实际HTTP请求当中的空行就是用来分离报头和有效载荷的。

**如果将HTTP请求想象成一个大的线性结构，此时每行的内容都是用\n隔开的，因此在读取过程中，如果连续读取到了两个\n，就说明已经将报头读取完毕了，后面剩下的就是有效载荷了。**

##### 获取浏览器的HTTP请求

在网络协议栈中，应用层的下一层叫做传输层，而HTTP协议底层通常使用的传输层协议是TCP协议，因此我们可以用套接字编写一个TCP服务器，然后启动浏览器访问我们的这个服务器。

由于我们的服务器是直接用TCP套接字读取浏览器发来的HTTP请求，此时在服务端没有应用层对这个HTTP请求进行过任何解析，因此我们可以直接将浏览器发来的HTTP请求进行打印输出，此时就能看到HTTP请求的基本构成。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/a79fd0e38cb14039a70e38274d9c8c95-168084844712631.png)

##### 分离HTTP请求

~~~C++
#include <iostream>
#include <fstream>
#include <string>
#include <cstring>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
using namespace std;

int main()
{
	//创建套接字
	int listen_sock = socket(AF_INET, SOCK_STREAM, 0);
	if (listen_sock < 0){
		cerr << "socket error!" << endl;
		return 1;
	}
	//绑定
	struct sockaddr_in local;
	memset(&local, 0, sizeof(local));
	local.sin_family = AF_INET;
	local.sin_port = htons(8081);
	local.sin_addr.s_addr = htonl(INADDR_ANY);
	if (bind(listen_sock, (struct sockaddr*)&local, sizeof(local)) < 0){
		cerr << "bind error!" << endl;
		return 2;
	}
	//监听
	if (listen(listen_sock, 5) < 0){
		cerr << "listen error!" << endl;
		return 3;
	}
	//启动服务器
	struct sockaddr peer;
	memset(&peer, 0, sizeof(peer));
	socklen_t len = sizeof(peer);
	for (;;){
		int sock = accept(listen_sock, (struct sockaddr*)&peer, &len);
		if (sock < 0){
			cerr << "accept error!" << endl;
			continue;
		}
		if (fork() == 0){ //爸爸进程
			close(listen_sock);
			if (fork() > 0){ //爸爸进程
				exit(0);
			}
			//孙子进程
			char buffer[1024];
			recv(sock, buffer, sizeof(buffer), 0); //读取HTTP请求
			cout << "--------------------------http request begin--------------------------" << endl;
			cout << buffer << endl;
			cout << "---------------------------http request end---------------------------" << endl;
			
			close(sock);
			exit(0);
		}
		//爷爷进程
		close(sock);
		waitpid(-1, nullptr, 0); //等待爸爸进程
	}
	return 0;
}
~~~

运行服务器程序后，然后用浏览器进行访问，此时我们的服务器就会收到浏览器发来的HTTP请求，并将收到的HTTP请求进行打印输出。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/e8b74801a5a04c4a86aad3646a1121cb-168084858406635.png)

说明一下：

- 浏览器向我们的服务器发起HTTP请求后，因为我们的服务器没有对其进行响应，此时浏览器就会认为服务器没有收到，然后再不断发起新的HTTP请求，因此虽然我们只用浏览器访问了一次，但会受到多次HTTP请求。
- 由于浏览器发起请求时默认用的就是HTTP协议，因此我们在浏览器的url框当中输入网址时可以不用指明HTTP协议。
- url当中的/不能称之为我们云服务器上根目录，这个/表示的是**web根目录**，这个web根目录可以是你的机器上的任何一个目录，这个是可以自己指定的，不一定就是Linux的根目录。

其中请求行当中的url一般是不携带域名以及端口号的，因为在请求报头中的Host字段当中会进行指明，**请求行当中的url表示你要访问这个服务器上的哪一路径下的资源。**如果浏览器在访问我们的服务器时指明要访问的资源路径，那么此时浏览器发起的HTTP请求当中的url也会跟着变成该路径。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/5f161a1e528f48d38b5d66fa469689d7-168084865100039.png)

请求报头当中全部都是以`key: value`形式按行陈列的各种请求属性。

#### HTTP响应

##### HTTP响应协议格式如下：

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/108ed120cde9485fbb5761d438d6cad1-168084898739243.png)

HTTP响应由以下四部分组成：

- 状态行：[http版本]+[状态码]+[状态码描述]
- 响应报头：响应的属性，这些属性都是以key: value的形式按行陈列的。
- 空行：遇到空行表示响应报头结束。
- 响应正文：响应正文允许为空字符串，如果响应正文存在，则响应报头中会有一个Content-Length属性来标识响应正文的长度。比如服务器返回了一个html页面，那么这个html页面的内容就是在响应正文当中的。

##### 如何将HTTP响应的报头与有效载荷进行分离？

对于HTTP响应来讲，这里的状态行和响应报头就是HTTP的报头信息，而这里的响应正文实际就是HTTP的有效载荷。与HTTP请求相同，当应用层收到一个HTTP响应时，也是根据HTTP响应当中的空行来分离报头和有效载荷的。当客户端收到一个HTTP响应后，就可以按行进行读取，如果读取到空行则说明报头已经读取完毕。

##### 构建HTTP响应给浏览器

服务器读取到客户端发来的HTTP请求后，需要对这个HTTP请求进行各种数据分析，然后构建成对应的HTTP响应发回给客户端。而我们的服务器连接到客户端后，实际就只读取了客户端发来的HTTP请求就将连接断开了。

接下来我们可以构建一个HTTP请求给浏览器，鉴于现在还没有办法分析浏览器发来的HTTP请求，这里我们可以给浏览器返回一个固定的HTTP响应。我们就将当前服务程序所在的路径作为我们的web根目录，我们可以在该目录下创建一个html文件，然后编写一个简单的html作为当前服务器的首页。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/62e29bee11e04634a1e561e29b3fc58d-168084915491947.png)

当浏览器向服务器发起HTTP请求时，不管浏览器发来的是什么请求，我们都将这个网页响应给浏览器，此时这个html文件的内容就应该放在响应正文当中，我们只需读取该文件当中的内容，然后将其作为响应正文即可。

~~~C++
#include <iostream>
#include <fstream>
#include <string>
#include <cstring>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
using namespace std;

int main()
{
	//创建套接字
	int listen_sock = socket(AF_INET, SOCK_STREAM, 0);
	if (listen_sock < 0){
		cerr << "socket error!" << endl;
		return 1;
	}
	//绑定
	struct sockaddr_in local;
	memset(&local, 0, sizeof(local));
	local.sin_family = AF_INET;
	local.sin_port = htons(8081);
	local.sin_addr.s_addr = htonl(INADDR_ANY);
	if (bind(listen_sock, (struct sockaddr*)&local, sizeof(local)) < 0){
		cerr << "bind error!" << endl;
		return 2;
	}
	//监听
	if (listen(listen_sock, 5) < 0){
		cerr << "listen error!" << endl;
		return 3;
	}
	//启动服务器
	struct sockaddr peer;
	memset(&peer, 0, sizeof(peer));
	socklen_t len = sizeof(peer);
	for (;;){
		int sock = accept(listen_sock, (struct sockaddr*)&peer, &len);
		if (sock < 0){
			cerr << "accept error!" << endl;
			continue;
		}
		if (fork() == 0){ //爸爸进程
			close(listen_sock);
			if (fork() > 0){ //爸爸进程
				exit(0);
			}
			//孙子进程
			char buffer[1024];
			recv(sock, buffer, sizeof(buffer), 0); //读取HTTP请求
			cout << "--------------------------http request begin--------------------------" << endl;
			cout << buffer << endl;
			cout << "---------------------------http request end---------------------------" << endl;
			
#define PAGE "index.html" //网站首页
			//读取index.html文件
			ifstream in(PAGE);
			if (in.is_open()){
				in.seekg(0, in.end);
				int len = in.tellg();
				in.seekg(0, in.beg);
				char* file = new char[len];
				in.read(file, len);
				in.close();
				
				//构建HTTP响应
				string status_line = "http/1.1 200 OK\n"; //状态行
				string response_header = "Content-Length: " + to_string(len) + "\n"; //响应报头
				string blank = "\n"; //空行
				string response_text = file; //响应正文
				string response = status_line + response_header + blank + response_text; //响应报文
				
				//响应HTTP请求
				send(sock, response.c_str(), response.size(), 0);

				delete[] file;
			}
			close(sock);
			exit(0);
		}
		//爷爷进程
		close(sock);
		waitpid(-1, nullptr, 0); //等待爸爸进程
	}
	return 0;
}

~~~

因此当浏览器访问我们的服务器时，服务器会将这个index.html文件响应给浏览器，而该html文件被浏览器解释后就会显示出相应的内容。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/baeda8e19c7643a08c87ecf574a0b6e1-168084927887051.png)

此外，我们也可以通过`telnet`命令来访问我们的服务器，此时也是能够得到这个HTTP响应的。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/4cfda9e29c004944a99261a661fe841d.png)

说明一下：

- 实际我们在进行网络请求的时候，如果不指明请求资源的路径，此时默认你想访问的就是目标网站的首页，也就是web根目录下的index.html文件。
- 由于只是作为示例，我们在构建HTTP响应时，在响应报头当中只添加了一个属性信息Content-Length，表示响应正文的长度，实际HTTP响应报头当中的属性信息还有很多。

##### HTTP为什么要交互版本？

HTTP请求当中的请求行和HTTP响应当中的状态行，当中都包含了http的版本信息。其中HTTP请求是由客户端发的，因此HTTP请求当中表明的是客户端的http版本，而HTTP响应是由服务器发的，因此HTTP响应当中表明的是服务器的http版本。

客户端和服务器双方在进行通信时会交互双方http版本，主要还是为了兼容性的问题。因为服务器和客户端使用的可能是不同的http版本，为了让不同版本的客户端都能享受到对应的服务，此时就要求通信双方需要进行版本协商。

客户端在发起HTTP请求时告诉服务器自己所使用的http版本，此时服务器就可以根据客户端使用的http版本，为客户端提供对应的服务，而不至于因为双方使用的http版本不同而导致无法正常通信。因此为了保证良好的兼容性，通信双方需要交互一下各自的版本信息。

### HTTP的方法

#### HTTP常见的方法如下：

![image-20230407143653901](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230407143653901.png)

其中最常用的就是**GET方法和POST方法**。

**GET方法一般用于获取某种资源信息，而POST方法一般用于将数据上传给服务器**。但实际我们上传数据时也有可能使用GET方法，比如百度提交数据时实际使用的就是GET方法。

GET方法和POST方法都可以带参：

- **GET方法是通过url传参的。**
- **POST方法是通过正文传参的。**

从GET方法和POST方法的传参形式可以看出，POST方法能传递更多的参数，因为url的长度是有限制的，POST方法通过正文传参就可以携带更多的数据。

此外，使用POST方法传参更加私密，因为POST方法不会将你的参数回显到url当中，此时也就不会被别人轻易看到。不能说POST方法比GET方法更安全，因为POST方法和GET方法实际都不安全，要做到安全只能通过加密来完成。

#### Postman演示GET和POST的区别

如果访问我们的服务器时使用的是GET方法，此时应该通过url进行传参，可以在Params下进行参数设置，因为Postman当中的Params就相当于url当中的参数，你在设置参数时可以看到对应的url也在随之变化。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/840fd1efe2a64b75b17712252ea0d8a1-168084990975057.png)

此时在我们的服务器收到的HTTP请求当中，可以看到请求行中的url就携带上了我们刚才在Postman当中设置的参数。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/4ea952a55f9149d78fa1152a7e4ea339-168084992289361.png)

而如果我们使用的是POST方法，此时就应该通过正文进行传参，可以在Body下进行参数设置，在设置时可以选中Postman当中的raw方式传参，表示原始传参，也就是你输入的参数是什么样的实际传递的参数就是什么样的。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/02f429bb5b93458682086c6fb7c5e2b1.png)

此时服务器收到的HTTP请求的请求正文就不再是空字符串了，而是我们通过正文传递的参数。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/8f0aa717923447c8a9552fbab2c775a3.png)

#### TCP套接字演示GET和POST的区别

要演示GET方法和POST方法传参的区别，就需要让浏览器提交参数，此时我们可以在index.html当中再加入两个表单，用作用户名和密码的输入，然后再新增一个提交按钮，此时就可以让浏览器提交参数了。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/b9544266aea041e3b24d788d3d29063d.png)

我们可以通过修改表单当中的method属性指定参数提交的方法，还有一个属性叫做action，表示想把这个表单提交给服务器上的哪个资源。

此时当我们用浏览器访问我们的服务器时，就会显示这两个表单。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/5164c5ec5e32471a9eeb36016f6f6f4c-168085003896071.png)

当前我们是用GET方法提交参数的，当我们填充完用户名和密码进行提交时，我们的用户名和密码就会自动被同步到url当中。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/f09835cedad640a79b97c9aea42fefdc.png)

同时在服务器这边也通过url收到了刚才我们在浏览器提交的参数。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/a2cc19adea73438ea69322ee74658bc8.png)

如果我们将提交表单的方法改为POST方法，此时当我们填充完用户名和密码进行提交时，对应提交的参数就不会在url当中体现出来，而会通过正文将这两个参数传递给了服务器。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/91902d815645450ebed054136e321c12.png)

此时用户名和密码就通过正文的形式传递给服务器了。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/7e4703f2d801493d8359301b52ba96eb.png)

说明一下：

- 当我们使用GET方法时，我们提交的参数会回显到url当中，因此GET方法一般是处理数据不敏感的。
- 如果你要传递的数据比较私密的话你一定要用POST方法，倒不是因为POST方法更安全，实际上GET和POST方法传参时都是明文传送，所以都不安全，但是POST方法更私密，因为POST是通过正文传参的，不会将参数立马回显到浏览器的url框当中的，所以相对更私密。

### HTTP的状态码

#### HTTP的状态码如下：

![image-20230407144947658](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230407144947658.png)

最常见的状态码，比如200（OK），404（Not Found），403（Forbidden请求权限不够），302（Redirect），504（Bad Gateway）。

#### Redirection（重定向状态码）

重定向就是通过各种方法将各种网络请求重新定个方向转到其它位置，此时这个服务器相当于提供了一个引路的服务。

重定向又可分为临时重定向和永久重定向，**其中状态码301表示的就是永久重定向，而状态码302和307表示的是临时重定向。**

**临时重定向和永久重定向本质是影响客户端的标签，决定客户端是否需要更新目标地址。**如果某个网站是永久重定向，那么第一次访问该网站时由浏览器帮你进行重定向，但后续再访问该网站时就不需要浏览器再进行重定向了，此时你访问的直接就是重定向后的网站。而如果某个网站是临时重定向，那么每次访问该网站时如果需要进行重定向，都需要浏览器来帮我们完成重定向跳转到目标网站。

##### 临时重定向演示

进行临时重定向时需要用到Location字段，Location字段是HTTP报头当中的一个属性信息，该字段表明了你所要重定向到的目标网站。

我们这里要演示临时重定向，可以将HTTP响应当中的状态码改为307，然后跟上对应的状态码描述，此外，还需要在HTTP响应报头当中添加Location字段，这个Location后面跟的就是你需要重定向到的网页，比如我们这里将其设置为CSDN的首页。

~~~C++
#include <iostream>
#include <fstream>
#include <string>
#include <cstring>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
using namespace std;

int main()
{
	//创建套接字
	int listen_sock = socket(AF_INET, SOCK_STREAM, 0);
	if (listen_sock < 0){
		cerr << "socket error!" << endl;
		return 1;
	}
	//绑定
	struct sockaddr_in local;
	memset(&local, 0, sizeof(local));
	local.sin_family = AF_INET;
	local.sin_port = htons(8081);
	local.sin_addr.s_addr = htonl(INADDR_ANY);
	if (bind(listen_sock, (struct sockaddr*)&local, sizeof(local)) < 0){
		cerr << "bind error!" << endl;
		return 2;
	}
	//监听
	if (listen(listen_sock, 5) < 0){
		cerr << "listen error!" << endl;
		return 3;
	}
	//启动服务器
	struct sockaddr peer;
	memset(&peer, 0, sizeof(peer));
	socklen_t len = sizeof(peer);
	for (;;){
		int sock = accept(listen_sock, (struct sockaddr*)&peer, &len);
		if (sock < 0){
			cerr << "accept error!" << endl;
			continue;
		}
		if (fork() == 0){ //爸爸进程
			close(listen_sock);
			if (fork() > 0){ //爸爸进程
				exit(0);
			}
			//孙子进程
			char buffer[1024];
			recv(sock, buffer, sizeof(buffer), 0); //读取HTTP请求
			cout << "--------------------------http request begin--------------------------" << endl;
			cout << buffer << endl;
			cout << "---------------------------http request end---------------------------" << endl;
			
			//构建HTTP响应
			string status_line = "http/1.1 307 Temporary Redirect\n"; //状态行
			string response_header = "Location: https://www.csdn.net/\n"; //响应报头
			string blank = "\n"; //空行
			string response = status_line + response_header + blank; //响应报文
			
			//响应HTTP请求
			send(sock, response.c_str(), response.size(), 0);

			close(sock);
			exit(0);
		}
		//爷爷进程
		close(sock);
		waitpid(-1, nullptr, 0); //等待爸爸进程
	}
	return 0;
}

~~~

此时运行我们的服务器，当我们用`telnet`命令登录我们的服务器时，向服务器发起HTTP请求时，此时服务器给我们的响应就是状态码307，响应报头当中是Location字段对应的就是CSDN首页的网址

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/4b890c3865f34800b7b33b4a2758676b-168085030470683.png)

telnet命令实际上只是一来一回，如果我们用浏览器访问我们的服务器，当浏览器收到这个HTTP响应后，还会对这个HTTP响应进行分析，当浏览器识别到状态码是307后就会提取出Location后面的网址，然后继续自动对该网站继续发起请求，此时就完成了页面跳转这样的功能，这样就完成了重定向功能。

此时当浏览器访问我们的服务器时，就会立马跳转到CSDN的首页。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/eb6fd4e013f74d17a76119e7c37ab03b.gif)

### HTTP常见的Header

#### HTTP常见的Header：

- Content-Type：数据类型（text/html等）。
- Content-Length：正文的长度。
- Host：客户端告知服务器，所请求的资源是在哪个主机的哪个端口上。
- User-Agent：声明用户的操作系统和浏览器的版本信息。
- Referer：当前页面是哪个页面跳转过来的。
- Location：搭配3XX状态码使用，告诉客户端接下来要去哪里访问。
- Cookie：用于在客户端存储少量信息，通常用于实现会话（session）的功能。

#### Host

Host字段表明了客户端要访问的服务的IP和端口，比如当浏览器访问我们的服务器时，浏览器发来的HTTP请求当中的Host字段填的就是我们的IP和端口。但客户端不就是要访问服务器吗？为什么客户端还要告诉服务器它要访问的服务对应的IP和端口？

**因为有些服务器实际提供的是一种代理服务，也就是代替客户端向其他服务器发起请求，然后将请求得到的结果再返回给客户端。**在这种情况下客户端就必须告诉代理服务器它要访问的服务对应的IP和端口，此时Host提供的信息就有效了。

#### User-Agent

User-Agent代表的是客户端对应的操作系统和浏览器的版本信息。

比如当我们用电脑下载某些软件时，它会自动向我们展示与我们操作系统相匹配的版本，这实际就是因为我们在向目标网站发起请求的时候，User-Agent字段当中包含了我们的主机信息，此时该网站就会向你推送相匹配的软件版本。
![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/b305ac4a5f124263a9b3e7c69d78e20c-168085051276090.png)

#### Referer

Referer代表的是你当前是从哪一个页面跳转过来的。Referer记录上一个页面的好处一方面是方便回退，另一方面可以知道我们当前页面与上一个页面之间的相关性。

#### Keep-Alive（长连接）

HTTP/1.0是通过request&response的方式来进行请求和响应的，HTTP/1.0常见的工作方式就是客户端和服务器先建立链接，然后客户端发起请求给服务器，服务器再对该请求进行响应，然后立马断开连接。

但如果一个连接建立后客户端和服务器只进行一次交互，就将连接关闭，就太浪费资源了，因此现在主流的HTTP/1.1是支持长连接的。所谓的长连接就是建立连接后，客户端可以不断的向服务器一次写入多个HTTP请求，而服务器在上层依次读取这些请求就行了，此时一条连接就可以传送大量的请求和响应，这就是长连接。

如果HTTP请求或响应报头当中的Connect字段对应的值是Keep-Alive，就代表支持长连接。

#### Cookie和Session

**HTTP实际上是一种无状态协议，HTTP的每次请求/响应之间是没有任何关系的，但你在使用浏览器的时候发现并不是这样的。**

比如当你登录一次CSDN后，就算你把CSDN网站关了甚至是重启电脑，当你再次打开CSDN网站时，CSDN并没有要求你再次输入账号和密码，这实际上是通过cookie技术实现的，点击浏览器当中锁的标志就可以看到对应网站的各种cookie数据。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/b0cff89fffee4e3fac997e018bd3e59c.png)

这些cookie数据实际都是对应的服务器方写的，如果你将对应的某些cookie删除，那么此时可能就需要你重新进行登录认证了，因为你删除的可能正好就是你登录时所设置的cookie信息。

##### cookie是什么呢？

因为HTTP是一种无状态协议，如果没有cookie的存在，那么每当我们要进行页面请求时都需要重新输入账号和密码进行认证，这样太麻烦了。

比如你是某个视频网站的VIP，这个网站里面的VIP视频有成百上千个，你每次点击一个视频都要重新进行VIP身份认证。而HTTP不支持记录用户状态，那么我们就需要有一种独立技术来帮我们支持，这种技术目前现在已经内置到HTTP协议当中了，叫做cookie。

当我们第一次登录某个网站时，需要输入我们的账号和密码进行身份认证，此时如果服务器经过数据比对后判定你是一个合法的用户，那么为了让你后续在进行某些网页请求时不用重新输入账号和密码，此时服务器就会进行Set-Cookie的设置。（Set-Cookie也是HTTP报头当中的一种属性信息）

当认证通过并在服务端进行Set-Cookie设置后，服务器在对浏览器进行HTTP响应时就会将这个Set-Cookie响应给浏览器。而浏览器收到响应后会自动提取出Set-Cookie的值，将其保存在浏览器的cookie文件当中，此时就相当于我的账号和密码信息保存在本地浏览器的cookie文件当中。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/f385225b026846eda31884ab8f4ab1f9-1680851075791100.png)

从第一次登录认证之后，浏览器再向该网站发起的HTTP请求当中就会自动包含一个cookie字段，其中携带的就是我第一次的认证信息，此后对端服务器需要对你进行认证时就会直接提取出HTTP请求当中的cookie字段，而不会重新让你输入账号和密码了。

也就是在第一次认证登录后，后续所有的认证都变成了自动认证，这就叫做cookie技术。

##### 内存级别&文件级别

cookie就是在浏览器当中的一个小文件，文件里记录的就是用户的私有信息。cookie文件可以分为两种，一种是内存级别的cookie文件，另一种是文件级别的cookie文件。

- 将浏览器关掉后再打开，访问之前登录过的网站，如果需要你重新输入账号和密码，说明你之前登录时浏览器当中保存的cookie信息是内存级别的。
- 将浏览器关掉甚至将电脑重启再打开，访问之前登录过的网站，如果不需要你重新输入账户和密码，说明你之前登录时浏览器当中保存的cookie信息是文件级别的。

##### cookie被盗

如果你浏览器当中保存的cookie信息被非法用户盗取了，那么此时这个非法用户就可以用你的cookie信息，以你的身份去访问你曾经访问过的网站，我们将这种现象称为cookie被盗取了。

比如你不小心点了某个链接，这个链接可能就是一个下载程序，当你点击之后它就会通过某种方式把程序下载到你本地，并且自动执行该程序，该程序会扫描你的浏览器当中的cookie目录，把所有的cookie信息通过网络的方式传送给恶意方，当恶意方拿到你的cookie信息后就可以拷贝到它的浏览器对应的cookie目录当中，然后以你的身份访问你曾经访问过的网站。

##### SessionID

###### 工作方式

单纯的使用cookie是非常不安全的，因为此时cookie文件当中就保存的是你的私密信息，一旦cookie文件泄漏你的隐私信息也就泄漏。

所以当前主流的服务器还引入了SessionID这样的概念，当我们第一次登录某个网站输入账号和密码后，服务器认证成功后还会在服务端生成一个对应的SessionID，这个SessionID与用户信息是不相关的。系统会将所有登录用户的SessionID值统一维护起来。

此时当认证通过后服务端在对浏览器进行HTTP响应时，就会将这个生成的SessionID值响应给浏览器。浏览器收到响应后会自动提取出SessionID的值，将其保存在浏览器的cookie文件当中。后续访问该服务器时，对应的HTTP请求当中就会自动携带上这个SessionID。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/a293a590b52848f2a639c13ccbe25a96.png)

而服务器识别到HTTP请求当中包含了SessionID，就会提取出这个SessionID，然后再到对应的集合当中进行对比，对比成功就说明这个用户是曾经登录过的，此时也就自动就认证成功了，然后就会正常处理你发来的请求，这就是我们当前主流的工作方式。

###### 相对安全

引入SessionID之后，浏览器当中的cookie文件保存的是SessionID，此时这个cookie文件同样可能被盗取。此时用户的账号和密码虽然不会泄漏了，但用户对应的SessionID是会泄漏的，非法用户仍然可以盗取我的SessionID去访问我曾经访问过的服务器，相当于还是存在刚才的问题。

之前的工作方式就相当于把账号和密码信息在浏览器当中再保存一份，每次请求时都自动将账号和密码的信息携带上，但是账号和密码一直在网当中发送太不安全了。因此现在的工作方式是，服务器只有在第一次认证的时候需要在网络中传输账号和密码，此后在网络上发送的都是SessionID。

这种方法虽然没有真正解决安全问题，但这种方法是相对安全的。互联网上是不存在绝对安全这样的概念的，任何安全都是相对的，就算你将发送到网络当中的信息进行加密，也有可能被别人破解。

安全领域有一个准则：**如果破解某个信息的成本已经远远大于破解之后获得的收益（说明做这个事是赔本的），那么就可以说这个信息是安全的。**

###### 好处

- 在引入SessionID之前，用户登录的账号信息都是保存在浏览器内部的，此时的账号信息是由客户端去维护的。
- 而引入SessionID后，用户登录的账号信息是有服务器去维护的，在浏览器内部保存的只是SessionID。

此时虽然SessionID可能被非法用户盗取，但服务器也可以使用各种各样的策略来保证用户账号的安全。

- I**P是有归类的**，可以通过IP地址来判断登录用户所在的地址范围。如果一个账号在短时间内登录地址发送了巨大变化，此时服务器就会立马识别到这个账号发生异常了，进而在服务器当中清除对应的SessionID的值。这时当你或那个非法用户想要访问服务器时，就都需要重新输入账号和密码进行身份认证，而只有你是知道自己的密码的，当你重新认证登录后服务器就可以将另一方识别为非法用户，进而对该非法用户进行对应的黑名单/白名单认证。
- 当操作者想要进行某些高权限的操作时，会**要求操作者再次输入账号和密码信息，再次确认身份**。就算你的账号被非法用户盗取了，但非法用户在改你密码时需要输入旧密码，这是非法用户在短时间内无法做到的，因为它并不知道你的密码。这也就是为什么账号被盗后还可以找回来的原因，因为非法用户无法在短时间内修改你的账号密码，此时你就可以通过追回的方式让当前的SessionID失效，让使用该账号的用户进行重新登录认证。
- **SessionID也有过期策略**，比如SessionID是一个小时内是有效的。所以即便你的SessionID被非法用户盗取了，也仅仅是在一个小时内有效，而且在功能上受约束，所以不会造成太大的影响。

任何事情都有两面性，如果不是这些非法用户的存在，现在的服务器肯定是漏洞百出，只有双方不断进行对抗双方才能不断进步。

##### 实验演示

当浏览器访问我们的服务器时，如果服务器给浏览器的HTTP响应当中包含Set-Cookie字段，那么当浏览器再次访问服务器时就会携带上这个cookie信息。

因此我们可以在服务器的响应报头当中添加上一个Set-Cookie字段，看看浏览器第二次发起HTTP请求时是否会带上这个Set-Cookie字段。

~~~C++
#include <iostream>
#include <fstream>
#include <string>
#include <cstring>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
using namespace std;

int main()
{
	//创建套接字
	int listen_sock = socket(AF_INET, SOCK_STREAM, 0);
	if (listen_sock < 0){
		cerr << "socket error!" << endl;
		return 1;
	}
	//绑定
	struct sockaddr_in local;
	memset(&local, 0, sizeof(local));
	local.sin_family = AF_INET;
	local.sin_port = htons(8081);
	local.sin_addr.s_addr = htonl(INADDR_ANY);
	if (bind(listen_sock, (struct sockaddr*)&local, sizeof(local)) < 0){
		cerr << "bind error!" << endl;
		return 2;
	}
	//监听
	if (listen(listen_sock, 5) < 0){
		cerr << "listen error!" << endl;
		return 3;
	}
	//启动服务器
	struct sockaddr peer;
	memset(&peer, 0, sizeof(peer));
	socklen_t len = sizeof(peer);
	for (;;){
		int sock = accept(listen_sock, (struct sockaddr*)&peer, &len);
		if (sock < 0){
			cerr << "accept error!" << endl;
			continue;
		}
		if (fork() == 0){ //爸爸进程
			close(listen_sock);
			if (fork() > 0){ //爸爸进程
				exit(0);
			}
			//孙子进程
			char buffer[1024];
			recv(sock, buffer, sizeof(buffer), 0); //读取HTTP请求
			cout << "--------------------------http request begin--------------------------" << endl;
			cout << buffer << endl;
			cout << "---------------------------http request end---------------------------" << endl;

#define PAGE "index.html" //网站首页
			//读取index.html文件
			ifstream in(PAGE);
			if (in.is_open()){
				in.seekg(0, in.end);
				int len = in.tellg();
				in.seekg(0, in.beg);
				char* file = new char[len];
				in.read(file, len);
				in.close();

				//构建HTTP响应
				string status_line = "http/1.1 200 OK\n"; //状态行
				string response_header = "Content-Length: " + to_string(len) + "\n"; //响应报头
				response_header += "Set-Cookie: 2021dragon\n"; //添加Set-Cookie字段
				string blank = "\n"; //空行
				string response_text = file; //响应正文
				string response = status_line + response_header + blank + response_text; //响应报文
				
				//响应HTTP请求
				send(sock, response.c_str(), response.size(), 0);

				delete[] file;
			}
			close(sock);
			exit(0);
		}
		//爷爷进程
		close(sock);
		waitpid(-1, nullptr, 0); //等待爸爸进程
	}
	return 0;
}

~~~

运行服务器后，用浏览器访问我们的服务器，此时通过Fiddler可以看到我们的服务器发给浏览器的HTTP响应报头当中包含了这个Set-Cookie字段。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/b0772e875b5d4577bdbd6fbe065dd3e7-1680852794343106.png)

同时我们也可以在浏览器当中看到这个cookie，这个cookie的值就是我们设置的2021dragon，此时浏览器当中就写入了这样的一个cookie。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/84d9465d1a2f4a4cb2cceeead6aa9b33-1680852807275110.png)



## HTTPS协议

### HTTPS VS HTTP

早期很多公司刚起步的时候，使用的应用层协议都是HTTP，而HTTP无论是用GET方法还是POST方法传参，都是没有经过任何加密的，因此早期很多的信息都是可以通过抓包工具抓到的。

为了解决这个问题，于是出现了HTTPS协议，HTTPS实际就是在应用层和传输层协议之间加了一层加密层（SSL&TLS），这层加密层本身也是属于应用层的，它会对用户的个人信息进行各种程度的加密。HTTPS在交付数据时先把数据交给加密层，由加密层对数据加密后再交给传输层。

当然，通信双方使用的应用层协议必须是一样的，因此对端的应用层也必须使用HTTPS，当对端的传输层收到数据后，会先将数据交给加密层，由加密层对数据进行解密后再将数据交给应用层。
![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/0adf5ec617834531ac110b873828dfba.png)

此时数据只有在用户层（应用层）是没有被加密的，而在应用层往下以及网络当中都是加密的，这就叫做HTTPS。

### 加密方式

#### 对称加密

#### 非对称加密

### 加密方案

#### 对称加密：

服务端具有对称密钥

对称密钥传输时，可能会被获取

则C/S发送的数据都不安全

不保密

#### 非对称加密：

服务器具有公私密钥

持有公私密钥的一方，将公钥发给另一方，这个过程，公钥可能会被获取

则持有私钥的一方，其发送给公钥的数据，是不安全的

而持有公钥的一方，其发送给私钥的数据，是安全的

如果能够劫持数据，则劫持方还能伪造公钥和数据，C/S发送的数据都是不安全的

![image-20230407160544485](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230407160544485.png)

#### 双非对称加密：

双方都持有公私密钥，并都将公钥分给对方，这个过程中，双方的公钥可能会被获取

劫持方可以发送假的公钥给双方，则劫持方劫持到数据后，因为是假的公钥解读，能读取到真正内容，

而在修改后，用劫持到的公钥加密后，发给对应私钥，私钥还检测不出来

而且加密需要处理数据，两套非对称加密，速度很慢

![image-20230407160553540](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230407160553540.png)

#### 非对称+对称加密▲ ：

服务端具有非对称公私密钥，客户端具有对称密钥

服务器发送给客户端公钥，此时公钥报文可能会被劫持

劫持方，可以将这个公钥替换，发给客户端假的公钥

客户端使用这个假公钥加密对称密钥

劫持方能够解析到对称密钥

并使用真公钥进行加密，发送给服务端

服务端，客户端发现不了

![image-20230407161142672](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230407161142672.png)

#### CA认证 + 签名 + 非对称加密 + 对称加密

服务器向CA机构申请得到CA私钥加密后的证书，该证书里有服务器公钥

客户端链接服务器时会得到服务器的CA证书，使用公布的CA公钥来验证该证书的合法性

若证书合法，则证书里的服务器公钥要是合法的，此时客户端使用该公钥加密自己的对称密钥，返回给服务器

服务器得到后使用服务器私钥解密，这样CS都具有对称密钥，使用该密钥进行加密解密



![image-20230407161234503](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230407161234503.png)

![image-20230407161250983](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230407161250983.png)

![image-20230407161527045](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230407161527045.png)

## 传输层知识

在学习HTTP等应用层协议时，为了便于理解，可以简单的认为HTTP协议是将请求和响应直接发送到了网络当中。但实际应用层需要先将数据交给传输层，由传输层对数据做进一步处理后再将数据继续向下进行交付，该过程贯穿整个网络协议栈，最终才能将数据发送到网络当中。

传输层负责(可靠性)传输，确保数据能够可靠地传送到目标地址。为了方便理解，在学习传输层协议时也可以简单的认为传输层协议是将数据直接发送到了网络当中。

### 端口号的作用

#### 标识

**端口号（Port）标识一个主机上进行网络通信的不同的应用程序。**当主机从网络中获取到数据后，需要自底向上进行数据的交付，而这个数据最终应该交给上层的哪个应用处理程序，就是由该数据当中的目的端口号来决定的。

从网络中获取的数据在进行向上交付时，在传输层就会提取出该数据对应的目的端口号，进而确定该数据应该交付给当前主机上的哪一个服务进程。
![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/cfd4c794a7a5480998f20696c47004cd-1680855850422116.png)

因此端口号是属于传输层的概念的，在传输层协议的报头当中就会包含与端口相关的字段。

#### 五元组标识一个通信

**在TCP/IP协议中，用“源IP地址”，“源端口号”，“目的IP地址”，“目的端口号”，“协议号”这样一个五元组来标识一个通信**。

比如有多台客户端主机同时访问服务器，这些客户端主机上可能有一个客户端进程，也可能有多个客户端进程，它们都在访问同一台服务器。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/580ef51a21ce4735af6f11145525ea49-1680856088371120.png)

而这台服务器就是通过“源IP地址”，“源端口号”，“目的IP地址”，“目的端口号”，“协议号”来识别一个通信的。

- 先提取出数据当中的目的IP地址和目的端口号，确定该数据是发送给当前服务进程的。
- 然后提取出数据当中的协议号，为该数据提供对应类型的服务。
- 最后提取出数据当中的源IP地址和源端口号，将其作为响应数据的目的IP地址和目的端口号，将响应结果发送给对应的客户端进程。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/5a9200ae26bc4811bc7180bf6e4dbfcd.png)

通过`netstat`命令可以查看到这样的五元组信息。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/0db8f633ecee422e908f0b092e8e738d.png)

其中的Local Address表示的就是源IP地址和源端口号，Foreign Address表示的就是目的IP地址和目的端口号，而Proto表示的就是协议类型。

### 协议号VS端口号

- 协议号是存在于IP报头当中的，其长度是8位。协议号指明了数据报所携带的数据是使用的何种协议，以便让目的主机的IP层知道应该将该数据交付给传输层的哪个协议进行处理。
- 端口号是存在于UDP和TCP报头当中的，其长度是16位。端口号的作用是唯一标识一台主机上的某个进程。
- 协议号是作用于传输层和网络层之间的，而端口号是作用于应用层于传输层之间的。

### 端口号范围划分

端口号的长度是16位，因此端口号的范围是0 ~ 65535：

- 0 ~ 1023：知名端口号。比如HTTP，FTP，SSH等这些广为使用的应用层协议，它们的端口号都是固定的。
- 1024 ~ 65535：操作系统动态分配的端口号。客户端程序的端口号就是由操作系统从这个范围分配的。

### 知名端口号



![image-20230407161716532](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230407161716532.png)

我们可以查看`/etc/services`文件，该文件是记录网络服务名和它们对应使用的端口号及协议。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/992a900f51dd49bb85f5af171a1c45c2-1680856450270130.png)

**说明一下：** 文件中的每一行对应一种服务，它由4个字段组成，每个字段之间用TAB或空格分隔，分别表示“服务名称”、“使用端口”、“协议名称”以及“别名”。

### 两个问题

#### 一个端口号是否可以被多个进程绑定？

一个端口号绝对不能被多个进程绑定，因为端口号的作用就是唯一标识一个进程，如果绑定一个已经被绑定的端口号，就会出现绑定失败的问题。(端口复用允许同一个进程下的多个套接字绑定同一个端口)

#### 一个进程是否可以绑定多个端口号？

一个进程是可以绑定多个端口号的，这与“端口号必须唯一标识一个进程”是不冲突的，只不过现在这多个端口唯一标识的是同一个进程罢了。

我们限制的是从端口号到进程的唯一性，而没有要求从进程到端口号也必须满足唯一性，因此一个进程是可以绑定多个端口号的。

### netstat 和 iostat

#### netsata

netstat是一个用来查看网络状态的重要工具。

其常见的选项如下：

- n：拒绝显示别名，能显示数字的全部转换成数字。
- l：仅列出处于LISTEN（监听）状态的服务。
- p：显示建立相关链接的程序名。
- t(tcp)：仅显示tcp相关的选项。
- u(udp)：仅显示udp相关的选项。
- a(all)：显示所有的选项，默认不显示LISTEN相关。

查看TCP相关的网络信息时，一般选择使用`nltp`组合选项。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/73c98d5ce9bc4b98b40e178729320015.png)

而查看UDP相关的网络信息时，一般选择使用`nlup`组合选项。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/5c7f02d9f4704566b1c9bf55a83e151c.png)

如果想查看LISTEN状态以外的连接信息，可以去掉`l`选项，此时就会将处于其他状态的连接信息显示出来。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/7bd9709e0f5f46b48734165ba92d32d7-1680856620404138.png)

#### iostat

iostat主要用于输出磁盘IO和CPU的统计信息。

其常见的选项如下：

- c：显示CPU的使用情况。
- d：显示磁盘的使用情况。
- N：显示磁盘列阵（LVM）信息。
- n：显示NFS使用情况。
- k：以KB为单位显示。
- m：以M为单位显示。
- t：报告每秒向终端读取和写入的字符数和CPU的信息。
- V：显示版本信息。
- x：显示详细信息。
- p：显示磁盘分区的情况。

比如我们要查看磁盘IO和CPU的详细信息。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/686cbaf81ab2442a97f7ee611e01247a-1680856684888142.png)

CPU属性值说明：

- %user：CPU处在用户模式下的时间百分比。
- %nice：CPU处在带NICE值的用户模式下的时间百分比。
- %system：CPU处在系统模式下的时间百分比。
- %iowait：CPU等待输入输出完成时间的百分比。
- %steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。
- %idle：CPU空闲时间百分比。

### pidof

`pidof`命令可以通过进程名，查看进程id。

例如，我们用`pidof`命令查看我们自己编写的一个死循环进程。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/28a4e70e27cd44cbb005d28417010b2e.png)

`pidof`命令可以配合`kill`命令快速杀死一个进程。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/079987c77b8c48518df0c03bfc3360b7.png)

pidof myproc | **xargs** kill -9 

> xarge可以将标准输入转化成命令行参数交给kill -9

## UDP协议

网络套接字编程时用到的各种接口，是位于应用层和传输层之间的一层系统调用接口，这些接口是系统提供的，我们可以通过这些接口搭建上层应用，比如HTTP。我们经常说HTTP是基于TCP的，实际就是因为HTTP在TCP套接字编程上搭建的。

而socket接口往下的传输层实际就是由操作系统管理的，因此UDP是属于内核当中的，是操作系统本身协议栈自带的，其代码不是由上层用户编写的，UDP的所有功能都是由操作系统完成，因此网络也是操作系统的一部分。

### UDP协议格式

#### 协议格式

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/d78ead6367274d3696fbdc0ef0b24421-1680857244509150.png)

- 16位源端口号：表示数据从哪里来。
- 16位目的端口号：表示数据要到哪里去。
- 16位UDP长度：表示整个数据报（UDP首部+UDP数据）的长度。
- 16位UDP检验和：如果UDP报文的检验和出错，就会直接将报文丢弃。

我们在应用层看到的端口号大部分都是16位的，其根本原因就是因为传输层协议当中的端口号就是16位的。

#### UDP如何将报头与有效载荷进行分离？

UDP的报头当中只包含四个字段，每个字段的长度都是16位，总共8字节。

因此**UDP采用的实际上是一种定长报头**，UDP在读取报文时读取完前8个字节后剩下的就都是有效载荷了。

#### UDP如何决定将有效载荷交付给上层的哪一个协议？

UDP上层也有很多应用层协议，因此UDP必须想办法将有效载荷交给对应的上层协议，也就是交给应用层对应的进程。

应用层的每一个网络进程都会绑定一个端口号，服务端进程必须显示绑定一个端口号，客户端进程则是由系统动态绑定的一个端口号。**UDP就是通过报头当中的目的端口号来找到对应的应用层进程的**。

说明一下： **内核中用哈希的方式维护了端口号与进程ID之间的映射关系，因此传输层可以通过端口号得到对应的进程ID，进而找到对应的应用层进程**。

#### 如何理解报头？

操作系统是C语言写的，而UDP协议又是属于内核协议栈的，因此UDP协议也一定是用C语言编写的，UDP报头实际就是一个位段类型。

例如：

![**加粗样式**](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/9823e75222b24f388727c054aa439a2b-1680857379456154.png)

**UDP数据封装：**

- 当应用层将数据交给传输层后，在传输层就会创建一个UDP报头类型的变量，然后填充报头当中的各个字段，此时就得到了一个UDP报头。
- 此时操作系统再在内核当中开辟一块空间，将UDP报头和有效载荷拷贝到一起，此时就形成了UDP报文。

**UDP数据分用：**

- 当传输层从下层获取到一个报文后，就会读取该报文的前8个字节，提取出对应的目的端口号。
- 通过目的端口号找到对应的上层应用层进程，然后将剩下的有效载荷向上交付给该应用层进程。

### UDP协议的特点

UDP传输的过程就类似于寄信，其特点如下：

- **无连接**：知道对端的IP和端口号就直接进行数据传输，不需要建立连接。
- **不可靠**：没有确认机制，没有重传机制；如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息。
- **面向数据报**：一次读取对应一次发送，不能够灵活的控制读写数据的次数和数量。

注意： **报文在网络中进行路由转发时，并不是每一个报文选择的路由路径都是一样的，因此报文发送的顺序和接收的顺序可能是不同的。**

**面向数据报**

> 应用层交给UDP多长的报文，UDP就原样发送，既不会拆分，也不会合并，这就叫做面向数据报。
>
> 比如用UDP传输100个字节的数据：
>
> - 如果发送端调用一次sendto，发送100字节，那么接收端也必须调用对应的一次recvfrom，接收100个字节；而不能循环调用10次recvfrom，每次接收10个字节。
>

### UDP的缓冲区

#### 理论

- **UDP没有真正意义上的发送缓冲区**。调用sendto会直接交给内核，由内核将数据传给网络层协议进行后续的传输动作。
- **UDP具有接收缓冲区。但是这个接收缓冲区不能保证收到的UDP报的顺序和发送UDP报的顺序一致**；**如果缓冲区满了，再到达的UDP数据就会被丢弃**。
- UDP的socket既能读，也能写，读写不发生在同一位置，因此**UDP是全双工的**。

#### 为什么UDP要有接收缓冲区？

如果UDP没有接收缓冲区，那么就要求上层及时将UDP获取到的报文读取上去，如果一个报文在UDP没有被读取，那么此时UDP从底层获取上来的报文数据就会被迫丢弃。

一个报文从一台主机传输到另一台主机，在传输过程中会消耗主机资源和网络资源。如果UDP收到一个报文后仅仅因为上次收到的报文没有被上层读取，而被迫丢弃一个可能并没有错误的报文，这就是在浪费主机资源和网络资源。

因此UDP本身是会维护一个接收缓冲区的，当有新的UDP报文到来时就会把这个报文放到接收缓冲区当中，此时上层在读数据的时就直接从这个接收缓冲区当中进行读取就行了，而**如果UDP接收缓冲区当中没有数据那上层在读取时就会被阻塞**。因此UDP的接收缓冲区的作用就是，将接收到的报文暂时的保存起来，供上层读取。

### 其他

#### UDP使用注意事项

需要注意的是，UDP协议报头当中的UDP最大长度是16位的，因此**一个UDP报文的最大长度是64K（包含UDP报头的大小）**。

然而64K在当今的互联网环境下，是一个非常小的数字。如果需要传输的数据超过64K，就需要在应用层进行手动分包，多次发送，并在接收端进行手动拼装。

U**DP不能保证读取到的数据报是有序的，并且接收缓冲区满时，还会舍弃到来的数据报。**

#### 基于UDP的应用层协议

- NFS：网络文件系统。
- TFTP：简单文件传输协议。
- DHCP：动态主机配置协议。
- BOOTP：启动协议（用于无盘设备启动）。
- DNS：域名解析协议。



## TCP协议

**TCP全称为“传输控制协议（Transmission Control Protocol）**”，TCP协议是当今互联网当中使用最为广泛的传输层协议，没有之一。

TCP协议被广泛应用，其根本原因就是提供了详尽的可靠性保证，基于TCP的上层应用非常多，比如HTTP、HTTPS、FTP、SSH等，甚至MySQL底层使用的也是TCP。

### 可靠

#### 为什么网络中会存在不可靠？

现代的计算机大部分都是基于冯诺依曼体系结构的。

![image-20230408141444458](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230408141444458.png)

虽然这里的输入设备、输出设备、内存、CPU都在一台机器上，但这几个硬件设备是彼此独立的。如果它们之间要进行数据交互，就必须要想办法进行通信，因此这几个设备实际是用“线”连接起来的，其中连接内存和外设之间的“线”叫做IO总线，而连接内存和CPU之间的“线”叫做系统总线。由于这几个硬件设备都是在一台机器上的，因此这里传输数据的“线”是很短的，传输数据时出现错误的概率也非常低。

但如果要进行通信的各个设备相隔千里，那么连接各个设备的“线”就会变得非常长，传输数据时出现错误的概率也会大大增高，此时要保证传输到对端的数据无误，就必须引入可靠性。

**总之，网络中存在不可靠的根本原因就是，长距离数据传输所用的“线”太长了**，数据在长距离传输过程中就可能会出现各种各样的问题，而TCP就是在此背景下诞生的，TCP就是一种保证可靠性的协议。

思维扩展：

- 实际单独的一台计算机可以看作成一个小型的网络，计算机上的各种硬件设备之间实际也是在进行数据通信，并且它们在通信时也必须遵守各自的通信协议，只不过它们之间的通信协议更多是描述一些数据的含义。

#### 为什么会存在UDP协议？

TCP协议是一种可靠的传输协议，使用TCP协议能够在一定程度上保证数据传输时的可靠性，而UDP协议是一种不可靠的传输协议，那UDP协议这种不可靠的协议存在有什么意义呢？

不可靠和可靠是两个中性词，它们描述的都是协议的特点。

- TCP协议是可靠的协议，也就意味着TCP协议需要做更多的工作来保证传输数据的可靠，并且引起不可靠的因素越多，保证可靠的成本（时间+空间）就越高。
- 比如数据在传输过程中出现了丢包、乱序、检验和失败等，这些都是不可靠的情况。
- 由于TCP要想办法解决数据传输不可靠的问题，因此TCP使用起来一定比UDP复杂，并且维护成本特别高。
- UDP协议是不可靠的协议，也就意味着UDP协议不需要考虑数据传输时可能出现的问题，因此UDP无论是使用还是维护都足够简单。
- **需要注意的是，虽然TCP复杂，但TCP的效率不一定比UDP低**，TCP当中不仅有保证可靠性的机制，还有保证传输效率的各种机制。

UDP和TCP没有谁最好，只有谁最合适，网络通信时具体采用TCP还是UDP完全取决于上层的应用场景。如果应用场景严格要求数据在传输过程中的可靠性，那么就必须采用TCP协议，如果应用场景允许数据传输出现少量丢包，那么肯定优先选择UDP协议，因为UDP协议足够简单。

### TCP协议格式

#### 格式

TCP协议格式如下：

![image-20230408141706222](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230408141706222.png)

TCP报头当中各个字段的含义如下：

- 源/目的端口号：表示数据是从哪个进程来，到发送到对端主机上的哪个进程。
- 32位序号/32位确认序号：分别代表TCP报文当中每个字节数据的编号以及对方的确认，是TCP保证可靠性的重要字段。
- 4位TCP报头长度：表示该TCP报头的长度，以4字节为单位。
- 6位保留字段：TCP报头中暂时未使用的6个比特位。
- 16位窗口大小：保证TCP可靠性机制和效率提升机制的重要字段。
- 16位检验和：由发送端填充，采用CRC校验。接收端校验不通过，则认为接收到的数据有问题。（检验和包含TCP首部+TCP数据部分）
- 16位紧急指针：标识紧急数据在报文中的偏移量，需要配合标志字段当中的URG字段统一使用。
- 选项字段：TCP报头当中允许携带额外的选项字段，最多40字节。

TCP报头当中的6位标志位：

- URG：紧急指针是否有效。
- ACK：确认序号是否有效。
- PSH：提示接收端应用程序立刻将TCP接收缓冲区当中的数据读走。
- RST：表示要求对方重新建立连接。我们把携带RST标识的报文称为**复位报文段**。
- SYN：表示请求与对方建立连接。我们把携带SYN标识的报文称为**同步报文段**。
- FIN：通知对方，本端要关闭了。我们把携带FIN标识的报文称为**结束报文段**。

TCP报头在内核当中本质就是一个位段类型，给数据封装TCP报头时，实际上就是用该位段类型定义一个变量，然后填充TCP报头当中的各个属性字段，最后将这个TCP报头拷贝到数据的首部，至此便完成了TCP报头的封装。

#### TCP如何将报头与有效载荷进行分离？

当TCP从底层获取到一个报文后，虽然TCP不知道报头的具体长度，但报文的前20个字节是TCP的基本报头，并且这20字节当中涵盖了4位的首部长度。

因此TCP是这样分离报头与有效载荷的：

- 当TCP获取到一个报文后，首先读取报文的前20个字节，并从中提取出4位的首部长度，此时便获得了TCP报头的大小size。
- 如果size的值大于20字节，则需要继续从报文当中读取s i z e − 20字节的数据，这部分数据就是TCP报头当中的选项字段。
- 读取完TCP的基本报头和选项字段后，剩下的就是有效载荷了。

需要注意的是，**TCP报头当中的4位首部长度描述的基本单位是4字节**，这也恰好是报文的宽度。4为首部长度的取值范围是0000 ~ 1111，因此TCP报头最大长度为15 × 4 = 60字节，因为基本报头的长度是20字节，所以报头中选项字段的长度最多是40字节。

如果TCP报头当中不携带选项字段，那么TCP报头的长度就是20字节，此时报头当中的4位首部长度的值就为20 ÷ 4 = 5 ，也就是0101。

#### TCP如何决定将有效载荷交付给上层的哪一个协议？

应用层的每一个网络进程都必须绑定一个端口号。

- 服务端进程必须显示绑定一个端口号。
- 客户端进程由系统动态绑定一个端口号。

而TCP的报头中涵盖了目的端口号，因此TCP可以提取出报头中的目的端口号，找到对应的应用层进程，进而将有效载荷交给对应的应用层进程进行处理。

**说明一下：** 内核中用哈希的方式维护了端口号与进程ID之间的映射关系，因此传输层可以通过端口号快速找到其对应的进程ID，进而找到对应的应用层进程。

#### 序号与确认序号

##### 什么是真正的可靠？

在进行网络通信时，一方发出数据后，它不能保证该数据能够成功被对端收到，因为数据在传输过程中可能会出现各种各样的错误，只有当收到对端主机发来的响应消息后，该主机才能保证上一次发送的数据被对端可靠的收到了，这就叫做真正的可靠。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/7280761ff3054847b3813ae04255bbfd.png)

但TCP要保证的是双方通信的可靠性，虽然此时主机A能够保证自己上一次发送的数据被主机B可靠的收到了，但主机B也需要保证自己发送给主机A的响应数据被主机A可靠的收到了。因此主机A在收到了主机B的响应消息后，还需要对该响应数据进行响应，但此时又需要保证主机A发送的响应数据的可靠性…，这样就陷入了一个死循环。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/5f278778c2f0477483b090e10c3c7e23-16809354045305.png)

因为只有当一端收到对方的响应消息后，才能保证自己上一次发送的数据被对端可靠的收到了，但双方通信时总会有最新的一条消息，因此**无法百分之百保证可靠性**。

所以严格意义上来说，互联网通信当中是不存在百分之百的可靠性的，因为双方通信时总有最新的一条消息得不到响应。但实际没有必要保证所有消息的可靠性，我们只要保证双方通信时发送的每一个核心数据都有对应的响应就可以了。而对于一些无关紧要的数据（比如响应数据），我们没有必要保证它的可靠性。因为对端如果没有收到这个响应数据，会判定上一次发送的报文丢失了，此时对端可以将上一次发送的数据进行重传。
![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/100a0d05f53042e697d6118f19ce18a6-16809354497379.png)

这种策略在TCP当中就叫做确认应答机制。**需要注意的是，确认应答机制不是保证双方通信的全部消息的可靠性，而是只要一方收到了另一方的应答消息，就说明它上一次发送的数据被另一方可靠的收到了**。

##### 32位序号

如果双方在进行数据通信时，只有收到了上一次发送数据的响应才能发下一个数据，那么此时双方的通信过程就是串行的，效率可想而知。

因此双方在进行网络通信时，允许一方向另一方连续发送多个报文数据，只要保证发送的每个报文都有对应的响应消息就行了，此时也就能保证这些报文被对方收到了。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/987a893059ed46318f0266b293387c65-168093548762313.png)



但在连续发送多个报文时，由于各个报文在进行网络传输时选择的路径可能是不一样的，因此这些报文到达对端主机的先后顺序也就可能和发送报文的顺序是不同的。但报文有序也是可靠性的一种，因此**TCP报头中的32位序号的作用之一实际就是用来保证报文的有序性的。**

TCP将发送出去的每个字节数据都进行了编号，这个编号叫做序列号。

- 比如现在发送端要发送3000字节的数据，如果发送端每次发送1000字节，那么就需要用三个TCP报文来发送这3000字节的数据。
- 此时这三个TCP报文当中的32位序号填的就是发送数据中首个字节的序列号，因此分别填的是1、1001和2001。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/e3b709839c6b4ce9bf69d61d293fc7ba.png)

此时接收端收到了这三个TCP报文后，就可以根据TCP报头当中的32位序列号对这三个报文进行顺序重排（该动作在传输层进行），重排后将其放到TCP的接收缓冲区当中，此时接收端这里报文的顺序就和发送端发送报文的顺序是一样的了。

- 接收端在进行报文重排时，可以根据当前报文的32位序号与其有效载荷的字节数，进而确定下一个报文对应的序号。

##### 32位确认序号

TCP报头当中的32位确认序号是告诉对端，我当前已经收到了哪些数据，你的数据下一次应该从哪里开始发。

以刚才的例子为例，当主机B收到主机A发送过来的32位序号为1的报文时，由于该报文当中包含1000字节的数据，因此主机B已经收到序列号为1-1000的字节数据，于是主机B发给主机A的响应数据的报头当中的32位确认序号的值就会填成1001。

- 一方面是告诉主机A，序列号在1001之前的字节数据我已经收到了。
- 另一方面是告诉主机A，下次向我发送数据时应该从序列号为1001的字节数据开始进行发送。

之后主机B对主机A发来的其他报文进行响应时，发给主机A的响应当中的32为确认序号的填法也是类似的道理。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/b8de783c80a14deaaa0d3598f1f41552.png)

**注意：**

- 响应数据与其他数据一样，也是一个完整的TCP报文，尽管该报文可能不携带有效载荷，但至少是一个TCP报头。

##### 报文丢失怎么办？

还是以刚才的例子为例，主机A发送了三个报文给主机B，其中每个报文的有效载荷都是1000字节，这三个报文的32位序号分别是1、1001、2001。

如果这三个报文在网络传输过程中出现了丢包，最终只有序号为1和2001的报文被主机B收到了，那么当主机B在对报文进行顺序重排的时候，就会发现只收到了1-1000和2001-3000的字节数据。此时主机B在对主机A进行响应时，其响应报头当中的32位确认序号填的就是1001，告诉主机A下次向我发送数据时应该从序列号为1001的字节数据开始进行发送。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/1094e3c885124deca8e0fedf41bfe7ed-168093566490023.png)

**注意：**

- 此时主机B在给主机A响应时，其32位确认序号不能填3001，因为1001-2000是在3001之前的，如果直接给主机A响应3001，就说明序列号在3001之前的字节数据全都收到了。
- 因此主机B只能给主机A响应1001，当主机A收到该确认序号后就会判定序号为1001的报文丢包了，此时主机A就可以选择进行数据重传。

因此**发送端可以根据对端发来的确认序号，来判断是否某个报文可能在传输过程中丢失了**。

##### 为什么要用两套序号机制？

如果通信双方只是一端发送数据，另一端接收数据，那么只用一套序号就可以了。

- 发送端在发送数据时，将该序号看作是32位序号。
- 接收端在对发送端发来的数据进行响应时，将该序号看作是32位确认序号。

但实际TCP却没有这么做，根本原因就是**因为TCP是全双工的，双方可能同时想给对方发送消息**。

- 双方发出的报文当中，不仅需要填充32位序号来表明自己当前发送数据的序号。
- 还需要填充32位确认序号，对对方上一次发送的数据进行确认，告诉对方下一次应该从哪一字节序号开始进行发送。

因此在进行TCP通信时，双方都需要有确认应答机制，此时一套序号就无法满足需求了，因此需要TCP报头当中出现了两套序号。

**总结一下：**

- 32位序号的作用是，保证数据的按序到达，同时这个序号也是作为对端发送报文时填充32位确认序号的根据。
- 32位确认序号的作用是，告诉对端当前已经收到的字节数据有哪些，对端下一次发送数据时应该从哪一字节序号开始进行发送。
- **序号和确认序号是确认应答机制的数据化表示**，**确认应答机制就是由序号和确认序号来保证的**。
- 此外，通过序号和确认序号还可以判断某个报文是否丢失。



#### 窗口大小

##### 缓冲区

**TCP本身是具有接收缓冲区和发送缓冲区的：**

- 接收缓冲区用来暂时保存接收到的数据。

- 发送缓冲区用来暂时保存还未发送的数据。

- 这两个缓冲区都是在**TCP传输层内部实现的**。![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/158452990c2b438d8a7a353b8388c673-168093589885227.png)

- TCP发送缓冲区当中的数据由上层应用层进行写入。当上层调用write/send这样的系统调用接口时，**实际不是将数据直接发送到了网络当中，而是将数据从应用层拷贝到了TCP的发送缓冲区当中**。

- **TCP接收缓冲区当中的数据最终也是由应用层来读取的**。当上层调用read/recv这样的系统调用接口时，实际也不是直接从网络当中读取数据，而是将数据从TCP的接收缓冲区拷贝到了应用层而已。

- 就好比调用read和write进行文件读写时，并不是直接从磁盘读取数据，也不是直接将数据写入到磁盘上，而对文件缓冲区进行的读写操作。

    ![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/62277e29944743bc9a839b9cd94d9de3-168093593902831.png)

    当数据写入到TCP的发送缓冲区后，对应的write/send函数就可以返回了，至于发送缓冲区当中的数据具体什么时候发，怎么发等问题实际都是由TCP决定的。

    我们之所以称TCP为传输层控制协议，就是因为最终数据的发送和接收方式，以及传输数据时遇到的各种问题应该如何解决，都是由TCP自己决定的，用户只需要将数据拷贝到TCP的发送缓冲区，以及从TCP的接收缓冲区当中读取数据即可。

    ![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/ec1cb470e3d94857813dc98da3143938-168093608927335.png)

需要注意的是，通信双方的TCP层都是一样的，因此通信双方的TCP层都是既有发送缓冲区又有接收缓冲区。

​    

**TCP的发送缓冲区和接收缓冲区存在的意义**

> **发送缓冲区和接收缓冲区的作用：**
>
> - 数据在网络中传输时可能会出现某些错误，此时就可能要求发送端进行数据重传，因此TCP必须提供一个发送缓冲区来暂时保存发送出去的数据，在需要时进行数据重传。只有当发出去的数据被对端可靠的收到后，发送缓冲区中的这部分数据才可以被覆盖掉。
> - 接收端处理数据的速度是有限的，为了保证没来得及处理的数据不会被迫丢弃，因此TCP必须提供一个接收缓冲区来暂时保存未被处理的数据，因为数据传输是需要耗费资源的，我们不能随意丢弃正确的报文。此外，**TCP的数据重排也是在接收缓冲区当中进行的**。
>
> **经典的生产者消费者模型：**
>
> - 对于发送缓冲区来说，上层应用不断往发送缓冲区当中放入数据，下层网络层不断从发送缓冲区当中拿出数据准备进一步封装。此时上层应用扮演的就是生产者的角色，下层网络层扮演的就是消费者的角色，而发送缓冲区对应的就是“交易场所”。
> - 对于接收缓冲区来说，上层应用不断从接收缓冲区当中拿出数据进行处理，下层网络层不断往接收缓冲区当中放入数据。此时上层应用扮演的就是消费者的角色，下层网络层扮演的就是生产者的角色，而接收缓冲区对应的就是“交易场所”。
> - 因此引入发送缓冲区和接收缓冲区相当于引入了两个生产者消费者模型，该生产者消费者模型将上层应用与底层通信细节进行了解耦，此外，**生产者消费者模型的引入同时也支持了并发和忙闲不均**。
>     

##### 窗口大小

当发送端要将数据发送给对端时，本质是把自己发送缓冲区当中的数据发送到对端的接收缓冲区当中。但缓冲区是有大小的，如果接收端处理数据的速度小于发送端发送数据的速度，那么总有一个时刻接收端的接收缓冲区会被打满，这时发送端再发送数据过来就会造成数据丢包，进而引起丢包重传等一系列的连锁反应。

因此TCP报头当中就有了16位的窗口大小，**这个16位窗口大小当中填的是自身接收缓冲区中剩余空间的大小，也就是当前主机接收数据的能力**。

接收端在对发送端发来的数据进行响应时，就可以通过16位窗口大小告知发送端自己当前接收缓冲区剩余空间的大小，此时发送端就可以根据这个窗口大小字段来调整自己发送数据的速度。

- 窗口大小字段越大，说明接收端接收数据的能力越强，此时发送端可以提高发送数据的速度。
- 窗口大小字段越小，说明接收端接收数据的能力越弱，此时发送端可以减小发送数据的速度。
- 如果窗口大小的值为0，说明接收端接收缓冲区已经被打满了，此时发送端就不应该再发送数据了。

**理解现象**

- 在编写TCP套接字时，我们调用read/recv函数从套接字当中读取数据时，可能会因为**套接字当中没有数据而被阻塞住，本质是因为TCP的接收缓冲区当中没有数据了，我们实际是阻塞在接收缓冲区当中了**。
- 而我们调用write/send函数往套接字中写入数据时，可能会因为套接字已经写满而被阻塞住，本**质是因为TCP的发送缓冲区已经被写满了，我们实际是阻塞在发送缓冲区当中了**。
- 在生产者消费者模型当中，如果生产者生产数据时被阻塞，或消费者消费数据时被阻塞，那么一定是因为某些条件不就绪而被阻塞。

#### 六个标志位

为什么会存在标志位？

> - TCP报文的种类多种多样，除了正常通信时发送的普通报文，还有建立连接时发送的请求建立连接的报文，以及断开连接时发送的断开连接的报文等等。
>
> - 收到不同种类的报文时完美需要对应执行动作，比如正常通信的报文需要放到接收缓冲区当中等待上层应用进行读取，而建立和断开连接的报文本质不是交给用户处理的，而是需要让操作系统在TCP层执行对应的握手和挥手动作。
> - 也就是说不同种类的报文对应的是不同的处理逻辑，所以我们要能够区分报文的种类。而TCP就是使用报头当中的六个标志字段来进行区分的，**这六个标志位都只占用一个比特位，为0表示假，为1表示真。**

SYN

> - **报文当中的SYN被设置为1，表明该报文是一个连接建立的请求报文**。
> - 只有在连接建立阶段，SYN才被设置，正常通信时SYN不会被设置。

ACK

> - **报文当中的ACK被设置为1，表明该报文可以对收到的报文进行确认**。
> - 一般除了第一个请求报文没有设置ACK以外，其余报文基本都会设置ACK，因为发送出去的数据本身就对对方发送过来的数据具有一定的确认能力，因此双方在进行数据通信时，可以顺便对对方上一次发送的数据进行响应

FIN

> - **报文当中的FIN被设置为1，表明该报文是一个连接断开的请求报文**。
> - 只有在断开连接阶段，FIN才被设置，正常通信时FIN不会被设置。

URG

> 双方在进行网络通信的时候，由于TCP是保证数据按序到达的，即便发送端将要发送的数据分成了若干个TCP报文进行发送，最终到达接收端时这些数据也都是有序的，因为TCP可以通过序号来对这些TCP报文进行顺序重排，最终就能保证数据到达对端接收缓冲区中时是有序的。
>
> TCP按序到达本身也是我们的目的，此时对端上层在从接收缓冲区读取数据时也必须是按顺序读取的。但是有时候发送端可能发送了一些“紧急数据”，这些数据需要让对方上层提取进行读取，此时应该怎么办呢？
>
> ![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/959fa40617434a30920cd336b7aae127-168093631439139.png)
>
> **此时就需要用到URG标志位，以及TCP报头当中的16位紧急指针**。
>
> - **当URG标志位被设置为１时，需要通过TCP报头当中的16位紧急指针来找到紧急数据，否则一般情况下不需要关注TCP报头当中的16位紧急指针**。
> - **16位紧急指针代表的就是紧急数据在报文中的偏移量**。
> - 因为紧急指针只有一个，它只能标识数据段中的一个位置，因此紧急数据只能发送一个字节，而至于这一个字节的具体含义这里就不展开讨论了。
>
> recv函数的第四个参数flags有一个叫做MSG_OOB的选项可供设置，其中OOB是带外数据（out-of-band）的简称，带外数据就是一些比较重要的数据，因此上层如果想读取紧急数据，就可以在使用recv函数进行读取，并设置MSG_OOB选项。
>
> ![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/379cf71c1bcc45dca273f3738c1cf054-168093639478643.png)
>
> 与之对应的send函数的第四个参数flags也提供了一个叫做MSG_OOB的选项，上层如果想发送紧急数据，就可以使用send函数进行写入，并设置MSG_OOB选项。
>
> ![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/d5f6bb9b6bfd48f39dc8b9c7dbb62dcf-168093640049047.png)

PSH

> **报文当中的PSH被设置为1，是在告诉对方尽快将你的接收缓冲区当中的数据交付给上层**。
>
> 我们一般认为：
>
> - 当使用read/recv从缓冲区当中读取数据时，如果缓冲区当中有数据read/recv函数就能够读到数据进行返回，而如果缓冲区当中没有数据，那么此时read/recv函数就会阻塞住，直到当缓冲区当中有数据时才会读取到数据进行返回。
>
> **实际这种说法是不太准确的，其实接收缓冲区和发送缓冲区都有一个水位线的概念。**
>
> ![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/36298a1a6a5c4f2d888582d0e8f87aaf-168093645760051.png)
>
> - 比如我们假设TCP接收缓冲区的水位线是100字节，那么只有当接收缓冲区当中有100字节时才让read/recv函数读取这100字节的数据进行返回。
> - 如果接收缓冲区当中有一点数据就让read/recv函数读取返回了，此时read/recv就会频繁的进行读取和返回，进而影响读取数据的效率（在内核态和用户态之间切换也是有成本的）。
> - 因此不是说接收缓冲区当中只要有数据，调用read/recv函数时就能读取到数据进行返回，**而是当缓冲区当中的数据量达到一定量时才能进行读取。**
>
> 当报文当中的PSH被设置为1时，实际就是在告知对方操作系统，尽快将接收缓冲区当中的数据交付给上层，**尽管接收缓冲区当中的数据还没到达所指定的水位线**。这也就是为什么我们使用read/recv函数读取数据时，期望读取的字节数和实际读取的字节数是不一定吻合的。

RST

> - **报文当中的RST被设置为1，表示需要让对方重新建立连接。**
> - 在通信双方在连接未建立好的情况下，一方向另一方发数据，此时另一方发送的响应报文当中的RST标志位就会被置1，表示要求对方重新建立连接。
> - 在双方建立好连接进行正常通信时，如果通信中途发现之前建立好的连接出现了异常也会要求重新建立连接。

### 确认应答机制(ACK)

**TCP保证可靠性的机制之一就是确认应答机制。**

**确认应答机制就是由TCP报头当中的，32位序号和32位确认序号来保证的**。需要再次强调的是，**确认应答机制不是保证双方通信的全部消息的可靠性，而是通过收到对方的应答消息，来保证自己曾经发送给对方的某一条消息被对方可靠的收到了**。

**确认应答机制通过确认序号告诉对方，我已经收到了序号之前的所有数据。**![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/987a893059ed46318f0266b293387c65-168093731874153-168093732125656.png)


**如何理解TCP将每个字节的数据都进行了编号？**

> TCP是面向字节流的，我们可以将TCP的发送缓冲区和接收缓冲区都想象成一个字符数组。
>
> ![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/f87a5d13e1b94b20897f8d3f95a0dffa-168093739455166.png)
>
> - 此时上层应用拷贝到TCP发送缓冲区当中的每一个字节数据天然有了一个序号，这个序号就是字符数组的下标，只不过这个下标不是从0开始的，而是从1开始往后递增的。
> - 而双方在通信时，本质就是将自己发送缓冲区当中的数据拷贝到对方的接收缓冲区当中。
> - 发送方发送数据时报头当中所填的序号，实际就是发送的若干字节数据当中，首个字节数据在发送缓冲区当中对应的下标。
> - 接收方接收到数据进行响应时，响应报头当中的确认序号实际就是，接收缓冲区中接收到的最后一个有效数据的下一个位置所对应的下标。
> - 当发送方收到接收方的响应后，就可以从下标为确认序号的位置继续进行发送了。
>     

### 超时重传机制

#### 理论

**双方在进行网络通信时，发送方发出去的数据在一个特定的事件间隔内如果得不到对方的应答，此时发送方就会进行数据重发，这就是TCP的超时重传机制。**

需要注意的是，**TCP保证双方通信的可靠性，一部分是通过TCP的协议报头体现出来的，还有一部分是通过实现TCP的代码逻辑体现出来的。**

比如超时重传机制实际就是发送方在发送数据后开启了一个定时器，若是在这个时间内没有收到刚才发送数据的确认应答报文，则会对该报文进行重传，这就是通过TCP的代码逻辑实现的，而在TCP报头当中是体现不出来的。

#### 丢包的两种情况

丢包分为两种情况，一**种是发送的数据报文丢失了**，此时发送端在一定时间内收不到对应的响应报文，就会进行超时重传。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/97d1739edc564d2e8e689390f98a91e6.png)

丢包的另一种情况其实不是发送端发送的数据丢包了，而是**对方发来的响应报文丢包了**，此时发送端也会因为收不到对应的响应报文，而进行超时重传。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/aacac01f9b974d41b007af5a1cd16bdb.png)

- 当出现丢包时，发送方是无法辨别是发送的数据报文丢失了，还是对方发来的响应报文丢失了，因为这两种情况下发送方都收不到对方发来的响应报文，此时发送方就只能进行超时重传。
- 如果是对方的响应报文丢失而导致发送方进行超时重传，此时接收方就会再次收到一个重复的报文数据，但此时也不用担心，接收方可以根据报头当中的32位序号来判断曾经是否收到过这个报文，从而达到报文去重的目的。
- 需要注意的是，当发送缓冲区当中的数据被发送出去后，操作系统不会立即将该数据从发送缓冲区当中删除或覆盖，而会让其保留在发送缓冲区当中，以免需要进行超时重传，直到收到该数据的响应报文后，发送缓冲区中的这部分数据才可以被删除或覆盖。
- ACK报文丢失可能不会造成影响，比如确认1001的报文丢失了，但确认2001的报文收到了，此时发送端仍然知道1001之前的报文是正确发送出去了。

#### 超时重传的等待时间

超时重传的时间不能设置的太长也不能设置的太短。

- 超时重传的时间设置的太长，会导致丢包后对方长时间收不到对应的数据，进而影响整体重传的效率。
- 超时重传的时间设置的太短，会导致对方收到大量的重复报文，可能对方发送的响应报文还在网络中传输而并没有丢包，但此时发送方就开始进行数据重传了，并且发送大量重复报文会也是对网络资源的浪费。

因此超时重传的时间一定要是合理的，最理想的情况就是找到一个最小的时间，保证“确认应答一定能在这个时间内返回”。但这个时间的长短，是与网络环境有关的。网好的时候重传的时间可以设置的短一点，网卡的时候重传的时间可以设置的长一点，也就是说超时重传设置的等待时间一定是上下浮动的，因此这个时间不可能是固定的某个值。

TCP为了保证无论在任何环境下都能有比较高性能的通信，因此**会动态计算这个最大超时时间**。

- Linux中（BSD Unix和Windows也是如此），超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。
- 如果重发一次之后，仍然得不到应答，下一次重传的等待时间就是2×500ms。
- 如果仍然得不到应答，那么下一次重传的等待时间就是4×500ms。以此类推，以指数的形式递增。
- **当累计到一定的重传次数后，TCP就会认为是网络或对端主机出现了异常，进而强转关闭连接**。

### 连接管理机制▲

#### TCP是面向连接的

**TCP的各种可靠性机制实际都不是从主机到主机的，而是基于连接的，与连接是强相关的。**比如一台服务器启动后可能有多个客户端前来访问，如果TCP不是基于连接的，也就意味着服务器端只有一个接收缓冲区，此时各个客户端发来的数据都会拷贝到这个接收缓冲区当中，此时这些数据就可能会互相干扰。

而**我们在进行TCP通信之前需要先建立连接，就是因为TCP的各种可靠性保证都是基于连接的，要保证传输数据的可靠性的前提就是先建立好连接。**

#### 操作系统对连接的管理

面向连接是TCP可靠性的一种，只有在通信建立好连接才会有各种可靠性的保证，而一台机器上可能会存在大量的连接，此时操作系统就不得不对这些连接进行管理。

- 操作系统在管理这些连接时需要“先描述，再组织”，在操作系统中一定有一个描述连接的结构体，该结构体当中包含了连接的各种属性字段，所有定义出来的连接结构体最终都会以某种数据结构组织起来，此时操作系统对连接的管理就变成了对该数据结构的增删查改。
- **建立连接，实际就是在操作系统中用该结构体定义一个结构体变量，然后填充连接的各种属性字段，最后将其插入到管理连接的数据结构当中即可。**
- **断开连接，实际就是将某个连接从管理连接的数据结构当中删除，释放该连接曾经占用的各种资源。**
- **因此连接的管理也是有成本的**，这个成本就是管理连接结构体的时间成本，以及存储连接结构体的空间成本。

#### 三次握手

[TCP第三次握手能携带数据吗？做个实验就知道！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/373422503)

##### 过程

双方在进行TCP通信之前需要先建立连接，建立连接的这个过程我们称之为三次握手。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/0c221ce71a9d4f37b1536dd8c34272fc.png)

以服务器和客户端为例，当客户端想要与服务器进行通信时，需要先与服务器建立连接，此时客户端作为主动方会先向服务器发送连接建立请求，然后双方TCP在底层会自动进行三次握手。

- 第一次握手：客户端向服务器发送的报文当中的**SYN位被设置为1**，表示请求与服务器建立连接。
- 第二次握手：服务器收到客户端发来的连接请求报文后，紧接着向客户端发起连接建立请求并对客户端发来的连接请求进行响应，此时服务器向客户端发送的报文当中的**SYN位和ACK位均被设置为1**。
- 第三次握手：客户端收到服务器发来的报文后，得知服务器收到了自己发送的连接建立请求，并请求和自己建立连接，最后客户端再向服务器发来的报文进行响应**ACK置为1**。

需要注意的是，客户端向服务器发起的连接建立请求，是请求建立从客户端到服务器方向的通信连接，而TCP是全双工通信，因此服务器在收到客户端发来的连接建立请求后，服务器也需要向客户端发起连接建立请求，请求建立从服务器到客户端方法的通信连接。

##### 为什么三次

首先我们需要知道，连接建立不是百分之百能成功的，通信双方在进行三次握手时，其中前两次握手能够保证被对方收到，因为前两次握手都有对应的下一次握手对其进行响应，但第三次握手是没有对应的响应报文的，如果第三次握手时客户端发送的ACK报文丢失了，那么连接建立就会失败。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/f82abd3ab4c1459e8a91dcb8e05823a5-168093770259676.png)

虽然客户端发起第三次握手后就完成了三次握手，但服务器却没有收到客户端发来的第三次握手，此时服务器端就不会建立对应的连接。所以建立连接时不管采用几次握手，最后一次握手的可靠性都是不能保证的。

既然连接的建立都不是百分之百成功的，因此建立连接时具体采用几次握手的依据，实际是看几次握手时的优点更多。

**三次握手是验证双方通信信道的最小次数：**

- 因为TCP是全双工通信的，因此连接建立的核心要务实际是，验证双方的通信信道是否是连通的。
- 而三次握手恰好是验证双方通信信道的最小次数，通过三次握手后双方就都能知道自己和对方是否都能够正常发送和接收数据。
- 在客户端看来，当它收到服务器发来第二次握手时，说明自己发出的第一次握手被对方可靠的收到了，证明自己能发以及服务器能收，同时当自己收到服务器发来的第二次握手时，也就证明服务器能发以及自己能收，此时就证明自己和服务器都是能发能收的。
- 在服务器看来，当它收到客户端发来第一次握手时，证明客户端能发以及自己能收，而当它收到客户端发来的第三次握手时，说明自己发出的第二次握手被对方可靠的收到了，也就证明自己能发以及客户端能收，此时就证明自己和客户端都是能发能收的。
- 既然三次握手已经能够验证双方通信信道是否正常了，那么三次以上的握手当然也是可以验证的，但既然三次已经能验证了就没有必要再进行更多次的握手了。

**三次握手能够保证连接建立时的异常连接挂在客户端：**

- 当客户端收到服务器发来的第二次握手时，客户端就已经证明双方通信信道是连通的了，因此当客户端发出第三次握手后，这个连接就已经在客户端建立了。
- 而只有当服务器收到客户端发来的第三次握手后，服务器才知道双方通信信道是连通的，此时在服务器端才会建立对应的连接。
- 因此双方在进行三次握手建立连接时，双方建立连接的时间点是不一样的。**如果客户端最后发出的第三次握手丢包了，此时在服务器端就不会建立对应的连接，而在客户端就需要短暂的维护一个异常的连接。**
- 而维护连接是需要时间成本和空间成本的，因此**三次握手还有一个好处就是能够保证连接建立异常时，这个异常连接是挂在客户端的，而不会影响到服务器。**
- 虽然此时客户端也需要短暂维护这个异常，但客户端的异常连接不会特别多，不像服务器，一旦多个客户端建立连接时都建立失败了，此时服务器端就需要耗费大量资源来维护这些异常连接。
- **此外，建立连接失败时的异常连接不会一直维护下去。如果服务器端长时间收不到客户端发来的第三次握手，就会将第二次握手进行超时重传，此时客户端就有机会重新发出第三次握手。**或者当客户端认为连接建立好后向服务器发送数据时，此时服务器会发现没有和该客户端建立连接而要求客户端重新建立连接。

**因此，这里给出两个建立连接时采用三次握手的理由：**

- 三次握手是验证双方通信信道的**最小次数**，能够让能建立的连接尽快建立起来。
- 三次握手能够保证连接建立时的异常连接挂在客户端（**风险转移**）。
- 一次握手：**SYN洪泛**
- 二次握手：**风险在服务器上**

##### 三次握手时的状态变化

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/2a4d4b4dff624b72958406bf33e6cb29-168093853335580.png)

**三次握手时的状态变化如下：**

- 最开始时客户端和服务器都处于CLOSED状态。
- 服务器为了能够接收客户端发来的连接请求，**需要由CLOSED状态变为LISTEN状态**。
- 此时客户端就可以向服务器发起三次握手了，**当客户端发起第一次握手后，状态变为SYN_SENT状态**。
- 处于LISTEN状态的服务器收到客户端的连接请求后，将该连接放入内核等待队列中，并向客户端发起第二次握手，**此时服务器的状态变为SYN_RCVD**。
- 当客户端收到服务器发来的第二次握手后，紧接着向服务器发送最后一次握手，**此时客户端的连接已经建立，状态变为ESTABLISHED。**
- 而服务器收到客户端发来的最后一次握手后，连接也建立成功，**此时服务器的状态也变成ESTABLISHED**。

至此三次握手结束，通信双方可以开始进行数据交互了。

##### 套接字和三次握手之间的关系

> - 在客户端发起连接建立请求之前，服务器需要先进入LISTEN状态，**此时就需要服务器调用对应listen函数**。
> - 当服务器进入LISTEN状态后，客户端就可以向服务器发起三次握手了，**此时客户端对应调用的就是connect函数**。
> - 需要注意的是，**connect函数不参与底层的三次握手，connect函数的作用只是发起三次握手**。当connect函数返回时，要么是底层已经成功完成了三次握手连接建立成功，要么是底层三次握手失败。
> - 如果服务器端与客户端成功完成了三次握手，此时在服务器端就会建立一个连接，但这个连接在内核的等待队列当中，**服务器端需要通过调用accept函数将这个建立好的连接获取上来**。
> - 当服务器端将建立好的连接获取上来后，双方就可以通过调用read/recv函数和write/send函数进行数据交互了。
>     

#### 四次挥手

##### 过程

由于双方维护连接都是需要成本的，因此当双方TCP通信结束之后就需要断开连接，断开连接的这个过程我们称之为四次挥手。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/6e525ea32ee34371b0a732ae61ada0e3-168093871849984.png)

是以服务器和客户端为例，当客户端与服务器通信结束后，需要与服务器断开连接，此时就需要进行四次挥手。

- 第一次挥手：客户端向服务器发送的报文当中的FIN位被设置为1，表示请求与服务器断开连接。
- 第二次挥手：服务器收到客户端发来的断开连接请求后对其进行响应。
- 第三次挥手：服务器收到客户端断开连接的请求，且已经没有数据需要发送给客户端的时候，服务器就会向客户端发起断开连接请求。
- 第四次挥手：客户端收到服务器发来的断开连接请求后对其进行响应。

四次挥手结束后双方的连接才算真正断开。

##### why四次

> - 由于TCP是全双工的，建立连接的时候需要建立双方的连接，断开连接时也同样如此。在断开连接时不仅要断开从客户端到服务器方向的通信信道，也要断开从服务器到客户端的通信信道，**其中每两次挥手对应就是关闭一个方向的通信信道，因此断开连接时需要进行四次挥手。**
> - **需要注意的是，四次挥手当中的第二次和第三次挥手不能合并在一起**，因为第三次握手是服务器端想要与客户端断开连接时发给客户端的请求，而当服务器收到客户端断开连接的请求并响应后，服务器不一定会马上发起第三次挥手，因为服务器可能还有某些数据要发送给客户端，只有当服务器端将这些数据发送完后才会向客户端发起第三次挥手。

##### 状态变化

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/020f1018a3824b3e850bef83681e5011-168093884755188.png)

四次挥手时的状态变化如下：

- 在挥手前客户端和服务器都处于连接建立后的ESTABLISHED状态。
- 客户端为了与服务器断开连接主动向服务器发起连接断开请求，**此时客户端的状态变为FIN_WAIT_1**。
- 服务器收到客户端发来的连接断开请求后对其进行响应，**此时服务器的状态变为CLOSE_WAIT**。
- 当服务器没有数据需要发送给客户端的时，服务器会向客户端发起断开连接请求，等待最后一个ACK到来，**此时服务器的状态变为LASE_ACK。**
- 客户端收到服务器发来的第三次挥手后，会向服务器发送最后一个响应报文，**此时客户端进入TIME_WAIT状态**。
- 当服务器收到客户端发来的最后一个响应报文时，**服务器会彻底关闭连接，变为CLOSED状态**。
- 而**客户端则会等待一个2MSL（Maximum Segment Lifetime，报文最大生存时间）才会进入CLOSED状态**(等待超时重传)。

至此四次挥手结束，通信双方成功断开连接。

##### 套接字和四次挥手之间的关系

> - 客户端发起断开连接请求，对应就是客户端主动调用close函数。
> - 服务器发起断开连接请求，对应就是服务器主动调用close函数。
> - 一个close对应的就是两次挥手，双方都要调用close，因此就是四次挥手。

###### CLOSE_WAIT

> - 双方在进行四次挥手时，**如果只有客户端调用了close函数，而服务器不调用close函数，此时服务器就会进入CLOSE_WAIT状态，而客户端则会进入到FIN_WAIT_2状态**。
> - 但只有完成四次挥手后连接才算真正断开，此时双方才会释放对应的连接资源。如果服务器没有主动关闭不需要的文件描述符，此时在服务器端就会存在大量处于CLOSE_WAIT状态的连接，而每个连接都会占用服务器的资源，最终就会导致服务器可用资源越来越少。
> - 因此如果不及时关闭不用的文件描述符，除了会造成文件描述符泄漏以外，可能也会导致连接资源没有完全释放，这其实也是一种内存泄漏的问题。
> - 因此在编写网络套接字代码时，如果发现服务器端存在大量处于CLOSE_WAIT状态的连接，此时就可以检查一下是不是服务器没有及时调用close函数关闭对应的文件描述符。

###### TIME_WAIT

> 四次挥手中前三次挥手丢包时的解决方法：
>
> - 第一次挥手丢包：客户端收不到服务器的应答，进而进行超时重传。
> - 第二次挥手丢包：客户端收不到服务器的应答，进而进行超时重传。
> - 第三次挥手丢包：服务器收不到客户端的应答，进而进行超时重传。
> - 第四次挥手丢包：服务器收不到客户端的应答，进而进行超时重传。
>
> 如果客户端在发出第四次挥手后立即进入CLOSED状态，此时服务器虽然进行了超时重传，但已经得不到客户端的响应了，因为客户端已经将连接关闭了。
>
> ![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/644d24be32b941628a22bd806aabe2da-168093905744592.png)
>
> **服务器在经过若干次超时重发后得不到响应，最终也一定会将对应的连接关闭，但在服务器不断进行超时重传期间还需要维护这条废弃的连接，这样对服务器是非常不友好的。**
>
> 为了避免这种情况，因此客户端在四次挥手后没有立即进入CLOSED状态，而是进入到了TIME_WAIT状态进行等待，此时要是第四次挥手的报文丢包了，客户端也能收到服务器重发的报文然后进行响应。
>
> TIME_WAIT状态存在的必要性：
>
> - 客户端在进行四次挥手后进入TIME_WAIT状态，如果第四次挥手的报文丢包了，客户端在一段时间内仍然能够接收服务器重发的FIN报文并对其进行响应，能够较大概率保证最后一个ACK被服务器收到。
> - 客户端发出最后一次挥手时，双方历史通信的数据可能还没有发送到对方。因此客户端四次挥手后进入TIME_WAIT状态，还可以保证双方通信信道上的数据在网络中尽可能的消散。
>
> 实际第四次挥手丢包后，可能双方网络状态出现了问题，尽管客户端还没有关闭连接，也收不到服务器重发的连接断开请求，此时客户端TIME_WAIT等若干时间最终会关闭连接，而服务器经过多次超时重传后也会关闭连接。这种情况虽然也让服务器维持了闲置的连接，但毕竟是少数，**引入TIME_WAIT状态就是争取让主动发起四次挥手的客户端维护这个成本**。
>
> 因此**TCP并不能完全保证建立连接和断开连接的可靠性，TCP保证的是建立连接之后，以及断开连接之前双方通信数据的可靠性。**

###### TIME_WAIT的等待时长是多少？

> IME_WAIT的等待时长既不能太长也不能太短。
>
> - 太长会让等待方维持一个较长的时间的TIME_WAIT状态，在这个时间内等待方也需要花费成本来维护这个连接，这也是一种浪费资源的现象。
> - 太短可能没有达到我们最初目的，没有保证ACK被对方较大概率收到，也没有保证数据在网络中消散，此时TIME_WAIT的意义也就没有了。
>
> **TCP协议规定，主动关闭连接的一方在四次挥手后要处于TIME_WAIT状态，等待两个MSL（Maximum Segment Lifetime，报文最大生存时间）的时间才能进入CLOSED状态。**
>
> MSL在RFC1122中规定为两分钟，但是各个操作系统的实现不同，比如在Centos7上默认配置的值是60s。我们可以通过`cat /proc/sys/net/ipv4/tcp_fin_timeout`命令来查看MSL的值。
>
> ![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/766a1df9f40d495eb96154acc3d69c26.png)
>
> TIME_WAIT的等待时长设置为两个MSL的原因：
>
> - MSL是TCP报文的最大生存时间，因此TIME_WAIT状态持续存在2MSL的话，就能保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失。
> - 同时也是在理论上保证最后一个报文可靠到达的时间。

### 流量控制

**TCP支持根据接收端的接收数据的能力来决定发送端发送数据的速度，这个机制叫做流量控制（Flow Control）。**

接收端处理数据的速度是有限的，如果发送端发的太快，导致接收端的缓冲区被打满，此时发送端继续发送数据，就会造成丢包，进而引起丢包重传等一系列连锁反应。

因此接收端可以将自己接收数据的能力告知发送端，让发送端控制自己发送数据的速度。

- 接收端将自己可以接收的缓冲区大小放入TCP首部中的“窗口大小”字段，通过ACK通知发送端。
- 窗口大小字段越大，说明网络的吞吐量越高。
- 接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端。
- 发送端接收到这个窗口之后，就会减慢自己发送的速度。
- **如果接收端缓冲区满了，就会将窗口值设置为0，这时发送方不再发送数据，但需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端。**

**当发送端得知接收端接收数据的能力为0时会停止发送数据，此时发送端会通过以下两种方式来得知何时可以继续发送数据。**

- **等待告知**。接收端上层将接收缓冲区当中的数据读走后，接收端向发送端发送一个TCP报文，主动将自己的窗口大小告知发送端，发送端得知接收端的接收缓冲区有空间后就可以继续发送数据了。
- **主动询问**。发送端每隔一段时间向接收端发送报文，该报文不携带有效数据，只是为了询问发送端的窗口大小，直到接收端的接收缓冲区有空间后发送端就可以继续发送数据了。

**16为数字最大表示65535，那TCP窗口最大就是65535吗？**

> 理论上确实是这样的，但实际上TCP报头当中40字节的选项字段中包含了一个窗口扩大因子M，实际窗口大小是窗口字段的值左移M位得到的。

**第一次向对方发送数据时如何得知对方的窗口大小？**

> 双方在进行TCP通信之前需要先进行三次握手建立连接，而双方在握手时除了验证双方通信信道是否通畅以外**，还进行了其他信息的交互**，其中就包括告知对方自己的接收能力，因此**在双方还没有正式开始通信之前就已经知道了对方接收数据能力**，所以双方在发送数据时是不会出现缓冲区溢出的问题的。

### 滑动窗口

#### 连续发送多个数据

双方在进行TCP通信时可以一次向对方发送多条数据，这样可以将等待多个响应的时间重叠起来，进而提高数据通信的效率。
![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/6a8c070ad0bd49b180eef8213e26cd01.png)
需要注意的是，虽然双方在进行TCP通信时可以一次向对方发送大量的报文，但不能将自己发送缓冲区当中的数据全部打包发送给对端，在发送数据时还要考虑对方的接收能力。

#### 滑动窗口

发送方可以一次发送多个报文给对方，此时也就意味着发送出去的这部分报文当中有相当一部分数据是暂时没有收到应答的。

其实可以将发送缓冲区当中的数据分为三部分：

- 已经发送并且已经收到ACK的数据。
- 已经发送还但没有收到ACK的数据。
- 还没有发送的数据。

这里发送缓冲区的第二部分就叫做滑动窗口。（也有人把这三部分整体称之为滑动窗口，而将其中的第二部分称之为窗口大小）

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/7d29c1931ffd41a7910d289e9b1b6a4a.png)

而**滑动窗口描述的就是，发送方不用等待ACK一次所能发送的数据最大量。**

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/258d8d20ab1547a0888aaebbe85adad2.png)

**滑动窗口存在的最大意义就是可以提高发送数据的效率**：

- **滑动窗口的大小等于对方窗口大小与自身拥塞窗口大小的较小值**，因为发送数据时不仅要考虑对方的接收能力，还要考虑当前网络的状况。
- 我们这里先不考虑拥塞窗口，并且假设对方的窗口大小一直固定为4000，此时发送方不用等待ACK一次所能发送的数据就是4000字节，因此滑动窗口的大小就是4000字节。（四个段）
- 现在连续发送1001-2000、2001-3000、3001-4000、4001-5000这四个段的时候，不需要等待任何ACK，可以直接进行发送。
- 当收到对方响应的确认序号为2001时，说明1001-2000这个数据段已经被对方收到了，此时该数据段应该被纳入发送缓冲区当中的第一部分，而由于我们假设对方的窗口大小一直是4000，因此滑动窗口现在可以向右移动，继续发送5001-6000的数据段，以此类推。
- 滑动窗口越大，则网络的吞吐率越高，同时也说明对方的接收能力很强。

当发送方发送出去的数据段陆陆续续收到对应的ACK时，就可以将收到ACK的数据段归置到滑动窗口的左侧，并根据当前滑动窗口的大小来决定，是否需要将滑动窗口右侧的数据归置到滑动窗口当中。

**TCP的重传机制要求暂时保存发出但未收到确认的数据**，而这部分数据实际就位于滑动窗口当中，只有滑动窗口左侧的数据才是可以被覆盖或删除的，因为这部分数据才是发送并被对方可靠的收到了，所以滑动窗口除了限定不收到ACK而可以直接发送的数据之外，滑动窗口也可以支持TCP的重传机制。

#### 滑动窗口一定会整体右移吗？

滑动窗口不一定会整体右移的，以刚才的例子为例，假设对方已经收到了1001-2000的数据段并进行了响应，但对方上层一直不从接收缓冲区当中读取数据，此时当对方收到1001-2000的数据段时，对方的窗口大小就由4000变为了3000。

当发送端收到对方的响应序号为2001时，就会将1001-2000的数据段归置到滑动窗口的左侧，但此时由于对方的接收能力变为了3000，而当1001-2000的数据段归置到滑动窗口的左侧后，滑动窗口的大小刚好就是3000，因此滑动窗口的右侧不能继续向右进行扩展。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/a311ef5811d64e96ab95a499b08b1d84.png)

**因此滑动窗口在向右移动的过程中并不一定是整体右移的，因为对方接收能力可能不断在变化，从而滑动窗口也会随之不断变宽或者变窄。**

#### 如何实现滑动窗口

TCP接收和发送缓冲区都可看作一个字符数组，而滑动窗口实际就可以看作是两个指针限定的一个范围，比如我们用sstart指向滑动窗口的左侧，end指向的是滑动窗口的右侧，此时在sstart和end区间范围内的就可以叫做滑动窗口。

当发送端收到对方的响应时，如果响应当中的确认序号为x，窗口大小为win，此时就可以将start更新为x，而将end更新为start+win。

环形数组

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/3df481c805274e5da3a4bce6b25b0298.png)

#### 丢包问题

当发送端一次发送多个报文数据时，此时的丢包情况也可以分为两种。

**情况一：** 数据包已经抵达，ACK丢包。

> ![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/bd62d554744c49788fe163218d9cec4b.png)
>
> **在发送端连续发送多个报文数据时，部分ACK丢包并不要紧，此时可以通过后续的ACK进行确认。**
>
> 比如图中2001-3000和4001-5000的数据包对应的ACK丢失了，但只要发送端收到了最后5001-6000数据包的响应，此时发送端也就知道2001-3000和4001-5000的数据包实际上被接收端收到了的，因为如果接收方没有收到2001-3000和4001-5000的数据包是设置确认序号为6001的，确认序号为6001的含义就是序号为1-6000的字节数据我都收到了，你下一次应该从序号为6001的字节数据开始发送。
> 

**情况二：** 数据包丢了

> ![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/2e633b3e60ec402297388ff6be0fb660.png)
>
> - 当1001-2000的数据包丢失后，发送端会一直收到确认序号为1001的响应报文，就是在提醒发送端“下一次应该从序号为1001的字节数据开始发送”。
> - 如果发送端连续收到三次确认序号为1001的响应报文，此时就会将1001-2000的数据包重新进行发送。
> - 此时当接收端收到1001-2000的数据包后，就会直接发送确认序号为6001的响应报文，因为2001-6000的数据接收端其实在之前就已经收到了。

**这种机制被称为“高速重发控制”，也叫做“快重传”。**

需要注意的是，**快重传需要在大量的数据重传和个别的数据重传之间做平衡**，实际这个例子当中发送端并不知道是1001-2000这个数据包丢了，当发送端重复收到确认序号为1001的响应报文时，理论上发送端应该将1001-7000的数据全部进行重传，但这样可能会导致大量数据被重复传送，所以发送端可以尝试先把1001-2000的数据包进行重发，然后根据重发后的得到的确认序号继续决定是否需要重发其它数据包。

#### 滑动窗口中的数据一定都没有被对方收到吗？

滑动窗口当中的数据是可以暂时不用收到对方确认的数据，而不是说滑动窗口当中的数据一定都没有被对方收到，滑动窗口当中可能有一部分数据已经被对方收到了，但可能因为滑动窗口内靠近滑动窗口左侧的一部分数据，在传输过程中出现了丢包等情况，导致后面已经被对方收到的数据得不到响应。

例如图中的1001-2000的数据包如果在传输过程中丢包了，此时虽然2001-5000的数据都被对方收到了，此时对方发来的确认序号也只能是1001，当发送端补发了1001-2000的数据包后，对方发来的确认序号就会变为5001，此时发送缓冲区当中1001-5000的数据也会立马被归置到滑动窗口的左侧。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/bd54d8fe6d2541b18e0ebe5f802ad91d-1680940026334112.png)

#### 快重传 VS 超时重传

快重传是能够快速进行数据的重发，当发送端连续收到三次相同的应答时就会触发快重传，而不像超时重传一样需要通过设置重传定时器，在固定的时间后才会进行重传。

**虽然快重传能够快速判定数据包丢失，但快重传并不能完全取待超时重传，因为有时数据包丢失后可能并没有收到对方三次重复的应答，此时快重传机制就触发不了，而只能进行超时重传。**

**因此快重传虽然是一个效率上的提升，但超时重传却是所有重传机制的保底策略，也是必不可少的。**

### 拥塞控制

#### why

两个主机在进行TCP通信的过程中，出现个别数据包丢包的情况是很正常的，此时可以通过快重传或超时重发对数据包进行补发。但如果双方在通信时出现了大量丢包，此时**就不能认为是正常现象了**。

TCP不仅考虑了通信双端主机的问题，同时也考虑了网络的问题。

- **流量控制**：考虑的是对端接收缓冲区的接收能力(即窗口大小)，进而控制发送方发送数据的速度，避免对端接收缓冲区溢出。
- **滑动窗口**：考虑的是发送端不用等待ACK一次所能发送的数据最大量，进而提高发送端发送数据的效率。
- **拥塞窗口**：考虑的是双方通信时网络的问题，如果发送的数据超过了拥塞窗口的大小就可能会引起网络拥塞。

双方网络通信时出现少量的丢包TCP是允许的，但一旦出现大量的丢包，此时量变引起质变，这件事情的性质就变了，此时TCP就不再推测是双方接收和发送数据的问题，而判断是双方通信信道网络出现了拥塞问题。

#### 如何解决网络拥塞问题？

网络出现大面积瘫痪时，通信双方作为网络当中两台小小的主机，看似并不能为此做些什么，但“雪崩的时候没有一片雪花是无辜的”，网络出现问题一定是网络中大部分主机共同作用的结果。

- 如果网络中的主机在同一时间节点都大量向网络当中塞数据，此时位于网络中某些关键节点的路由器下就可能排了很长的报文，最终导致报文无法在超时时间内到达对端主机，此时也就导致了丢包问题。
- 当网络出现拥塞问题时，通信双方虽然不能提出特别有效的解决方案，但双方主机可以做到不加重网络的负担。
- 双方通信时如果出现大量丢包，不应该立即将这些报文进行重传，而应该少发数据甚至不发数据，等待网络状况恢复后双方再慢慢恢复数据的传输速率。

需要注意的是，**网络拥塞时影响的不只是一台主机，而几乎是该网络当中的所有主机，此时所有使用TCP传输控制协议的主机都会执行拥塞避免算法。**

因此拥塞控制看似只是谈论的一台主机上的通信策略，实际这个策略是所有主机在网络崩溃后都会遵守的策略。一旦出现网络拥塞，该网络当中的所有主机都会受到影响，此时所有主机都要执行拥塞避免，这样才能有效缓解网络拥塞问题。通过这样的方式就能保证雪崩不会发生，或雪崩发生后可以尽快恢复。

#### 拥塞控制

虽然滑动窗口能够高效可靠的发送大量的数据，但如果在刚开始阶段就发送大量的数据，就可能会引发某些问题。因为网络上有很多的计算机，有可能当前的网络状态就已经比较拥塞了，因此在不清楚当前网络状态的情况下，贸然发送大量的数据，就可能会引起网络拥塞问题。

因此TCP引入了**慢启动机制**，在刚开始通信时先发少量的数据探探路，摸清当前的网络拥堵状态，再决定按照多大的速度传输数据。
![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/75a1522626dc4de9ba4e16e6f81ef286-1680940182012116.png)

- TCP除了有窗口大小和滑动窗口的概念以外，还有一个窗口叫做拥塞窗口。**拥塞窗口是可能引起网络拥塞的阈值**，如果一次发送的数据超过了拥塞窗口的大小就可能会引起网络拥塞。
- 刚开始发送数据的时候拥塞窗口大小定义以为1，每收到一个ACK应答拥塞窗口的值就增加。
- 每次发送数据包的时候，将拥塞窗口和接收端主机反馈的窗口大小做比较，取较小的值作为实际发送数据的窗口大小，即滑动窗口的大小。

每收到一个ACK应答拥塞窗口的值就加一，此时拥塞窗口就是以指数级别进行增长的，如果先不考虑对方接收数据的能力，那么滑动窗口的大小就只取决于拥塞窗口的大小，此时拥塞窗口的大小变化情况如下：

![image-20230408155007431](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230408155007431.png)

但指数级增长是非常快的，因此“慢启动”实际只是初始时比较慢，但越往后增长的越快。如果拥塞窗口的值一直以指数的方式进行增长，此时就可能在短时间内再次导致网络出现拥塞。

- 为了避免短时间内再次导致网络拥塞，因此不能一直让拥塞窗口按指数级的方式进行增长。
- 此时就引入了**慢启动的阈值**，当拥塞窗口的大小超过这个阈值时，就不再按指数的方式增长，而按线性的方式增长。
- 当TCP刚开始启动的时候，慢启动阈值设置为对方窗口大小的最大值。
- 在每次超时重发的时候，**慢启动阈值会变成当前拥塞窗口的一半，同时拥塞窗口的值被重新置为1**，如此循环下去。

如下图：

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/8db3d256379941ac907c1ee327307b36.png)

图示说明：

- **指数增长**。刚开始进行TCP通信时拥塞窗口的值为1，并不断按指数的方式进行增长。
- **加法增大**。慢启动的阈值初始时为对方窗口大小的最大值，图中慢启动阈值的初始值为16，因此当拥塞窗口的值增大到16时就不再按指数形式增长了，而变成了的线性增长。
- **乘法减小**。拥塞窗口在线性增长的过程中，在增大到24时如果发生了网络拥塞，此时慢启动的阈值将变为当前拥塞窗口的一半，也就是12，并且拥塞窗口的值被重新设置为1，所以下一次拥塞窗口由指数增长变为线性增长时拥塞窗口的值应该是12。

主机在进行网络通信时，实际就是在不断进行指数增长、加法增大和乘法减小。

需要注意的是，**不是所有的主机都是同时在进行指数增长、加法增大和乘法减小的**。每台主机认为拥塞窗口的大小不一定是一样的，即便是同区域的两台主机在同一时刻认为拥塞窗口的大小也不一定是完全相同的。因此**在同一时刻，可能一部分主机正在进行正常通信，而另一部分主机可能已经发生网络拥塞了。**

### 延迟应答/捎带应答

#### 延迟应答

如果接收数据的主机收到数据后立即进行ACK应答，此时返回的窗口可能比较小。

- 假设对方接收端缓冲区剩余空间大小为1M，对方一次收到500K的数据后，如果立即进行ACK应答，此时返回的窗口就是500K。
- 但实际接收端处理数据的速度很快，10ms之内就将接收缓冲区中500K的数据消费掉了。
- 在这种情况下，接收端处理还远没有达到自己的极限，即使窗口再放大一些，也能处理过来。
- 如果接收端稍微等一会再进行ACK应答，比如等待200ms再应答，那么这时返回的窗口大小就是1M。

需要注意的是，**延迟应答的目的不是为了保证可靠性，而是留出一点时间让接收缓冲区中的数据尽可能被上层应用层消费掉，此时在进行ACK响应的时候报告的窗口大小就可以更大，从而增大网络吞吐量，进而提高数据的传输效率。**

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/83cb3017be314719a85bb07a927d67ba-1680940314621122.png)

此外，**不是所有的数据包都可以延迟应答。**

- 数量限制：每N个包就应答一次。
- 时间限制：最大延迟时间就应答一次（这个时间不会导致误超时重传）。

延迟应答具体的数量和超时时间，依操作系统不同也有差异，一般N取2，超时时间取200ms。

#### 捎带应答

捎带应答其实是TCP通信时最常规的一种方式，就好比主机A给主机B发送了一条消息，当主机B收到这条消息后需要对其进行ACK应答，但如果主机B此时正好也要给主机A发生消息，此时这个ACK就可以搭顺风车，而不用单独发送一个ACK应答，此时主机B发送的这个报文既发送了数据，又完成了对收到数据的响应，这就叫做捎带应答。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/2cf0d39837354326900c2d545f9a4c27-1680940356676126.png)

捎带应答最直观的角度实际也是发送数据的效率，此时双方通信时就可以不用再发送单纯的确认报文了。

此外，由于捎带应答的报文携带了有效数据，因此对方收到该报文后会对其进行响应，当收到这个响应报文时不仅能够确保发送的数据被对方可靠的收到了，同时也能确保捎带的ACK应答也被对方可靠的收到了。

### 面向字节流▲

当创建一个TCP的socket时，同时在内核中会创建一个发送缓冲区和一个接收缓冲区。

- 调用write函数就可以将数据写入发送缓冲区中，此时write函数就可以进行返回了，接下来发送缓冲区当中的数据就是由TCP自行进行发送的。
- 如果发送的字节数太长，TCP会将其拆分成多个数据包发出。如果发送的字节数太短，TCP可能会先将其留在发送缓冲区当中，等到合适的时机再进行发送。
- 接收数据的时候，数据也是从网卡驱动程序到达内核的接收缓冲区，可以通过调用read函数来读取接收缓冲区当中的数据。
    而调用read函数读取接收缓冲区中的数据时，也可以按任意字节数进行读取。

由于缓冲区的存在，TCP程序的读和写不需要一一匹配，例如：

- 写100个字节数据时，可以调用一次write写100字节，也可以调用100次write，每次写一个字节。
- 读100个字节数据时，也完全不需要考虑写的时候是怎么写的，既可以一次read100个字节，也可以一次read一个字节，重复100次。

实际对于TCP来说，它并不关心发送缓冲区当中的是什么数据，在TCP看来这些只是一个个的字节数据，它的任务就是将这些数据准确无误的发送到对方的接收缓冲区当中就行了，而至于如何解释这些数据完全由上层应用来决定，这就叫做面向字节流。

### 粘包问题

#### 什么是粘包？

- 首先要明确，**粘包问题中的“包”，是指的应用层的数据包**。
- 在TCP的协议头中，没有如同UDP一样的“报文长度”这样的字段。
- 站在传输层的角度，TCP是一个一个报文过来的，按照序号排好序放在缓冲区中。
- 但站在应用层的角度，看到的只是一串连续的字节数据。
- 那么应用程序看到了这么一连串的字节数据，就不知道从哪个部分开始到哪个部分，是一个完整的应用层数据包。
- 所以，应用层读取到的数据，不能保证正好是一个应用层数据包，称之为粘包。

#### 如何解决粘包问题

要解决粘包问题，本**质就是要明确报文和报文之间的边界**。

- 对于定长的包，保证每次都**按固定大小读取**即可。
- 对于变长的包，可以在报头的位置，**约定一个包总长度的字段**，从而就知道了包的结束位置。比如HTTP报头当中就包含Content-Length属性，表示正文的长度。
- 对于变长的包，还可以在包和包之间**使用明确的分隔符**。因为应用层协议是程序员自己来定的，只要保证分隔符不和正文冲突即可。

#### UDP是否存在粘包问题？

- 对于UDP，如果还没有向上层交付数据，UDP的报文长度仍然在，同时，UDP是一个一个把数据交付给应用层的，有很明确的数据边界。
- 站在应用层的角度，使用UDP的时候，要么收到完整的UDP报文，要么不收，不会出现“半个”的情况。

因此UDP是不存在粘包问题的，根本原因就是UDP报头当中的16位UDP长度记录的UDP报文的长度，因此**UDP在底层的时候就把报文和报文之间的边界明确了，而TCP存在粘包问题就是因为TCP是面向字节流的，TCP报文之间没有明确的边界**。

### TCP异常情况

#### 进程终止

当客户端正常访问服务器时，如果客户端进程突然崩溃了，此时建立好的连接会怎么样？

当一个进程退出时，该进程曾经打开的文件描述符都会自动关闭，因此当客户端进程退出时，相当于自动调用了close函数关闭了对应的文件描述符，此时双方操作系统在底层会正常完成四次挥手，然后释放对应的连接资源。也就是说，**进程终止时会释放文件描述符，TCP底层仍然可以发送FIN，和进程正常退出没有区别。**

#### 机器重启

当客户端正常访问服务器时，如果将客户端主机重启，此时建立好的连接会怎么样？

当我们选择重启主机时，操作系统会先杀掉所有进程然后再进行关机重启，**因此机器重启和进程终止的情况是一样的**，此时双方操作系统也会正常完成四次挥手，然后释放对应的连接资源。

#### 机器掉电/网线断开

当客户端正常访问服务器时，如果将客户端突然掉线了，此时建立好的连接会怎么样？

**当客户端掉线后，服务器端在短时间内无法知道客户端掉线了，因此在服务器端会维持与客户端建立的连接，但这个连接也不会一直维持，因为TCP是有保活策略的。**

- 服务器会定期检查客户端的存在状况，检查对方是否在线，如果**连续多次都没有收到ACK应答，此时服务器就会关闭这条连接**。
- 此外，客户端也可能会定期向服务器“报平安”，如果**服务器长时间没有收到客户端的消息，此时服务器也会将对应的连接关闭**。

其中服务器定期询问客户端的存在状态的做法，叫做**基于保活定时器的一种心跳机制**，是由TCP实现的。此外，应用层的某些协议，也有一些类似的检测机制，例如基于长连接的HTTP，也会定期检测对方的存在状态。

### 总结

#### 理解

可靠性：

> - 检验和。
> - 序列号。
> - 确认应答。
> - 超时重传。
> - 连接管理。
> - 流量控制。
> - 拥塞控制。

提高性能：

> - 滑动窗口。
> - 快速重传。
> - 延迟应答。
> - 捎带应答。

其他：

> TCP可以保证数据的可靠传输，但面向字节流的特性，数据需要应用层进程自己区分
>
> ACK机制
>
> 全双工理解
>
> 滑动窗口
>
> 6个标记位
>
> 三次握手四次挥手 
>
> 一次握手太容易链接(SYN洪水)，二次握手服务器代价高于客户端，三次握手既不容易链接，代价也小于客户端
>
> 高于三次的连接代价太大
>
> 四次挥手的状态
>
> 存在大量CLOSE_WAIT状态链接：应用层存在bug，没有关闭对应链接的sockfd
>
> 先退出的通信方，在四次挥手后，会维持一会儿的等待状态TIME_WAIT，此时它申请的系统资源还未释放：setsockopt函数可以使进程绑定时，忽略TIME_WAIT状态。等待时间为2MSL，即最大传输时间的2倍

传输控制：

> 1. TCP发送缓冲区的抽象理解
> 2. 重复报文的识别和去重
> 3. 超时重传的时间设置 --- 不长不短，动态设置
> 4. 流量控制：流量窗口控制着流量传输，在三次握手阶段，就交换了各自的缓冲区承受能力
> 5. 滑动窗口：
> 6. 快重传机制：三次重复的确认序号，就重传确认序号开头的报文。快重传有条件，超时重传是最基本的重传机制
>

拥塞控制：

> 慢启动 慢启动阈值
>
> 拥塞窗口 拥塞避免 网络拥塞
>
> 初值 -》指数增长(慢开始但快发展) -》 阈值 -》加法增大 -》网络拥塞 -》乘法减小 -》ssthresh值 -》加法增大
>
> 滑动窗口 = min(接收方接受能力，拥塞窗口)
>
> 

### TCP相关实验

[TCP相关实验](https://blog.csdn.net/chenlong_cxy/article/details/125215957)

## IP协议

IP协议全称为“网际互连协议（Internet Protocol）”，IP协议是TCP/IP体系中的网络层协议。

### 基本概念

#### 网络层解决的问题

TCP作为传输层控制协议，其保证的是数据传输的可靠性和传输效率，但**TCP提供的仅仅是数据传输的策略，而真正负责数据在网络中传输的则传输层之下的网络层和链路层。**

- 双方在进行网络通信时，发送的数据并不是直接从一方的传输层直接发送到了另一方的传输层，而是需要传输层将数据继续向下进行交付，在网络层和链路层经过数据封装后再通过网络发送到对方主机，对方主机收到数据后也同样需要在链路层和网络层进行数据解包，此时对方的传输层才拿到了发送过来的数据，然后再继续将该数据向上进行交付。

网络通信的过程，就像两个人在送互相送数据，这两个人分别在两栋楼的四楼，如果一个人要将数据交给对方，那么这个人就必须先从四楼走到一楼，然后再在路上经过路径选择到达对方楼下，最后再上到四楼将数据交给对方。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/d3d45890320c4d09ad372b0d28203ca6.png)

其中，送数据的这个人从四楼下来的过程就是数据封装的过程，这个人在路上经过路径选择到达对方楼下的过程就是数据路由的过程，而这个人再上到四楼将数据交给对方的过程就是数据解包的过程。

- 而网络层要解决的问题就是，将数据从一台主机送到另一台主机，也就是数据的路由。

#### 保证数据可靠的从一台主机送到另一台主机的前提

当双方在进行基于TCP的网络通信时，要保证将数据可靠的从一台主机送到另一台主机，前提是发送方要有将数据送到对方主机的能力，要是发送方连将数据发送给对方的能力都没有，那就更不用谈可靠的将数据送给对方主机了。

- 需要注意的是，发送方有将数据送到对方主机的能力，并不意味着发送方每次发送的数据都能够成功的发送到对方，但如果发送方连将数据发送给对方的能力都没有，那发送方基本就不可能将数据发送给对方。
- 一旦发送方有了将数据发送给对方的能力，就算发送方某次发送的数据没有成功到达对方，此时上层TCP由于没有收到对应数据的应答，此时上层TCP会要求进行数据重发，直到数据成功发送到对方主机为止。

也就是说，在网络层有能力将数据送到对方主机的情况下，虽然网络层不能保证每次都能将数据成功送到对方主机，但在TCP提供的可靠性策略的保证下，最终网络层就一定能够将数据可靠的发送到对方主机。

**说明一下：**

- 网络层解决的问题是，将数据从一台主机送到另一台主机，因此网络层解决的是主机到主机的问题。
- 传输层从上方进程拿到数据后，该数据贯穿网络协议栈进行封装和解包，最终到达对方传输层，此时对方传输层也会将数据向上交给对应的进程，因此传输层解决的是进程到进程的问题。



#### 路径选择

数据进行的网络传输一般都是跨网络的，而路由器就是连接多个网络的硬件设备，因此数据在进行跨网络传输时一定需要经过多个路由器。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/744bbe4123f94490ac330c4fff17a139.png)

数据路由就像我们旅游一样，当确定了要到达的目标主机后，就需要寻找最短的路径到达该目的地。

- 目的地的确定是非常重要的，因为目的地直接决定了数据路由时的路径选择，这也是跨网络找到目标主机的根本。
- 只有数据经过了较为正确的路径选择，最终才可能慢慢趋近于目标网络或目标主机。

确定数据路由的目的地后，数据就可以在网络中进行路由了，但数据在路由时无法自行进行路径选择，因为这个数据本身是“不认识路”的，因此数据在路由的过程中需要不断“找路人问路”，而这里所谓的“路人”就是网络当中的一台台路由器。

网络当中的路由器是“认识路的”，它们将自己的“认路经验”都记录到路由表当中，因此路由器可以通过查路由表找到去特定点的最短路径。因此数据在路由时，会不断通过路由器来进行路径选择，以此来一步步靠近目标网络或目标主机。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/16ca94d37e7f4121a68811d085af4808.png)

#### 主机和路由器

- **主机：配有IP地址，但是不进行路由控制的设备。但实际现在几乎不存在不进行路由控制的设备了，就连你的笔记本也会进行路由控制。**
- **路由器：既配有IP地址，又能进行路由控制。实际现在主流的路由器已经不仅仅具有路由的功能了，它甚至具备某些应用层的功能。**
- **节点：主机和路由器的统称。**

### IP协议格式

#### IP协议格式如下：

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/cb78e7a4a25a4b75a9e2aa1ec04c9ea8-1680941620073139.png)

- 4位版本号（version）：指定IP协议的版本（IPv4/IPv6），对于IPv4来说，就是4。
- 4位首部长度（header length）：**表示IP报头的长度，以4字节为单位**。
- 8位服务类型（Type Of Service）：**3位优先权字段（已经弃用），4位TOS字段，和1位保留字段（必须置为0）。**4位TOS分别表示：最小延时，最大吞吐量，最高可靠性，最小成本。这**四者相互冲突，只能选择一个**。比如对于ssh/telnet这样的应用程序，最小延时比较重要，而对于ftp这样的程序，最大吞吐量比较重要。
- 16位总长度（total length）：IP报文（IP报头+有效载荷）的总长度，用于将各个IP报文进行分离。
- 16位标识（id）：**唯一的标识主机发送的报文，如果数据在IP层进行了分片，那么每一个分片对应的id都是相同的**。
- 3位标志字段：**第一位保留，表示暂时没有规定该字段的意义。第二位表示禁止分片，表示如果报文长度超过MTU，IP模块就会丢弃该报文。第三位表示“更多分片”，如果报文没有进行分片，则该字段设置为0，如果报文进行了分片，则除了最后一个分片报文设置为0以外，其余分片报文均设置为1**。
- 13位片偏移（framegament offset）：**分片相对于原始数据开始处的偏移，表示当前分片在原数据中的偏移位置，实际偏移的字节数是这个值×8得到的。**因此除了最后一个报文之外，其他报文的长度必须是8的整数倍，否则报文就不连续了。
- 8位生存时间（Time To Live，TTL）：**数据报到达目的地的最大报文跳数，一般是64，每经过一个路由，TTL -= 1，一直减到0还没到达，那么就丢弃了，这个字段主要是用来防止出现路由循环。**
- 8位协议：表示上层协议的类型。
- 16位首部检验和：使用CRC进行校验，来鉴别数据报的首部是否损坏，但不检验数据部分。
- 32位源IP地址和32位目的IP地址：表示发送端和接收端所对应的IP地址。
- 选项字段：不定长，最多40字节。

IP报头在内核当中本质就是一个位段类型，给数据封装IP报头时，实际上就是用该位段类型定义一个变量，然后填充IP报头当中的各个属性字段，最后将这个IP报头拷贝到数据的首部，至此便完成了IP报头的封装。

#### IP如何将报头与有效载荷进行分离？

IP分离报头与有效载荷的方法与TCP是一模一样的，当IP从底层获取到一个报文后，虽然IP不知道报头的具体长度，但IP报文的前20个字节是IP的基本报头，并且这20字节当中涵盖4位首部长度。

**因此IP是这样分离报头与有效载荷的：**

当IP从底层获取到一个报文后，首先读取报文的前20个字节，并从中提取出4位的首部长度，此时便获得了IP报头的大小size。
如果size的值大于20字节，则需要继续从报文当中读取ssize−20字节的数据，这部分数据就是IP报头当中的选项字段。
读取完IP的基本报头和选项字段后，剩下的就是有效载荷了。
IP就是通过这种“定长报头+自描述字段”的方式进行报头和有效载荷的分离的。但需要注意的是，IP报头当中的4位首部长度描述的基本单位与TCP报头当中的4位首部长度一样，都是以4字节为单位进行描述的，这也恰好是报文的宽度。

4位二进制的取值范围是0000 ~ 1111，因此IP报头的最大长度为15×4=60字节，因为基本报头的长度是20字节，所以IP报头中选项字段的长度最多是40字节。如果IP报头当中不携带选项字段，那么IP报头的长度就是20字节，此时报头当中的4位首部长度字段所填的值就是20÷4=5，即0101。

#### IP如何决定将有效载荷交付给上层的哪一个协议？

基于IP协议的传输层协议不止一种，因此当IP从底层获取到一个报文并对其进行解包后，IP需要知道应该将分离后得到的有效载荷交付给上层的哪一个协议。

在IP报头当中有一个字段叫做8位协议，该字段表示的就是上层协议的类型，IP就是根据该字段判定应该将分离出来的有效载荷交付给上层的哪一个协议的。该字段是发送方的IP层从上层传输层获取到数据后填充的，比如是上层TCP交给IP层的数据，那么该数据在封装IP报头时的8位协议填充的就是TCP对应的编号。

#### 32位源IP地址和32位目的IP地址

IP报头当中的32位源IP地址和32位目的IP地址，分别代表的就是该报文的发送端和接收端对应的IP地址。

数据在网络传输过程中会遇到一个个的路由器，这些路由器会帮助网络当中的数据进行路由转发，使得网络中的数据慢慢趋近于目标主机。路由器在帮助数据进行路由转发时，会提取出该数据的IP报头当中的目的IP地址，并以此作为数据路由转发的重要依据。

当接收端收到了发送端发来的数据后，接收端可能也想要给发送端发送数据，因此发送端在发送数据时除了需要指明该数据的目的IP地址，还需要指明该数据的源IP地址，也就是发送端的IP地址。即便接收端收到数据后没有数据想要发送给发送端，但至少接收端需要向发送端发送一个响应报文，表明发送端发送的数据已经被接收端可靠的收到了，因此发送出去的数据除了需要指明该数据的目的IP地址，还需要指明该数据的源IP地址。

**理解socket编程：**

> - 在进行socket编程的时候，当一端想要发送数据给另一端时，必须要指明对端的IP地址和端口号，也就是发送数据的目的IP地址和目的端口号。
> - 其中这里的IP地址就是给网络层的IP用的，用于数据在网络传输过程中的路由转发，而这里的端口号就是给传输层的TCP或UDP用的，用于指明该数据应该交给上层的哪一个进程。
> - **发送数据时我们不需要指明发送数据的源IP地址和源端口号，因为传输层和网络层都是在操作系统内核当中实现的，数据在进行封装时操作系统会自行填充上对应的源IP地址和源端口号。**

#### 8位生存时间

报文在网络传输过程中，可能因为某些原因导致报文无法到达目标主机，比如报文在路由时出现了环路路由的情况，或者目标主机已经异常离线了，此时这个报文就成了一个废弃的游离报文。

为了避免网络当中出现大量的游离报文，于是在IP的报头当中就出现了一个字段，叫做8位生存时间（Time To Live，TTL）。8位生存时间代表的是报文到达目的地的最大报文跳数，每当报文经过一次路由，这里的生存时间就会减一，**当生存时间减为0时该报文就会被自动丢弃，此时这个报文就会在网络中消散。**

### 分片与组装

#### 数据链路层解决的问题

IP能够将数据跨网络从一台主机送到另一台主机，而数据在进行跨网络传送时，需要经过一个个的路由器进行路由转发，最终才能到达目标主机。

比如要将数据从主机B跨网络传送到主机C，那么主机B需要先将数据交给路由器F，路由器F再将数据交给路由器G，…，最终由路由器D将数据交给主机C。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/16ca94d37e7f4121a68811d085af4808-1680941943907141-1680941950460144.png)

因此IP进行数据跨网络传送的前提是，需要先将数据从一个节点传送到和自己相连的下一个节点，这个问题实际就是由IP之下的数据链路层解决的，其中**数据链路层最典型的代表协议就是MAC帧**。

而两个节点直接相连也就意味着这两个节点是在同一个局域网当中的，因此要讨论两个相邻节点的数据传送时，实际讨论的就是局域网通信的问题。

#### 最大传输单元 MTU

MAC帧作为数据链路层的协议，它会将IP传下来的数据封装成数据帧，然后发送到网络当中。但MAC帧携带的有效载荷的最大长度是有限制的，也就是说IP交给MAC帧的报文不能超过某个值，这个值就叫做**最大传输单元（Maximum Transmission Unit，MTU），这个值的大小一般是1500字节。**

在Linux下使用ifconfig命令可以查看对应的MTU。
![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/f354ae9fbb1246b2ba361ef8b0db6d69-1680941978572148.png)

由于MAC帧无法发送大于1500字节的数据，因此IP层向下交付的数据的长度不能超过1500字节，这里所说的数据包括IP的报头和IP的有效载荷。

#### 分片与组装

如果IP层要传送的数据超过了1500字节，那么就需要先在IP层对该数据进行分片，然后再将分片后的数据交给下层MAC帧进行发送。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/26951bd6cee8488181ab4b56c56d342a.png)

如果发送数据时在IP层进行了分片，那么当这些分片数据到达对端主机的IP层后就需要先进行组装，然后再将组装好的数据交付给上层传输层。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/4c080dea345342ffbdc2e90384e512b7-1680942021956154.png)

注意：

- **数据的分片不是经常需要做的，实际在网络通信过程中不分片才是常态**，因为数据分片会存在一些潜在的问题，比如分片可能会增加丢包的概率。
- **数据的分片发生在IP层，不仅源端主机可能会对数据进行分片，数据在路由过程中的路由器也可能对数据进行分片**。因为不同网络的MTU是不一样的，如果传输路径上的某个网络的MTU比源端网络的MTU小，那么路由器就可能对IP数据报再次进行分片。
- **分片数据的组装只会发生在目的端的IP层**。
- **在分片的数据中，每一个分片在IP层都会被添加上对应的IP报头，而传输层添加的报头只会出现在第一个分片中，因此网络中传输的数据包可能没有传输层的报头。**

#### 数据的分片和组装都是由IP层完成的

数据的分片和组装都是在IP层完成的，上层的传输层和下层的链路层并不关心。

**传输层只负责为数据传送提供可靠性保证，比如当数据传送失败后，传输层的TCP协议可以组织进行数据重传。**

- 当TCP将待发送的数据交给IP后，TCP并不关心该数据是否会在IP层进行分片，即TCP并不关心数据具体的发送过程。
- 当TCP从IP获取到数据后，TCP也不关心该数据是否在IP层经过了组装。

**而链路层的MAC帧只负责，将数据从一个节点传送到和自己相连的下一个节点。**

- 当IP将待发送的数据交给MAC帧后，MAC帧并不知道该数据是IP经过分片后的某个分片数据，还是一个没有经过分片的数据，MAC帧只知道它一次最多只能发送MTU大小的数据，如果IP交给MAC帧大于MTU字节的数据，那MAC帧就无法进行发送。
- 当MAC帧从网络中获取到数据后，MAC帧也不关心这个数据是否需要进行组装，MAC帧只需要将该数据的MAC帧报头去掉后直接上交给上层IP就行了，而至于该数据的组装问题则是IP需要解决的。

因此，**数据的分片和组装完全是由IP协议自己完成的，传输层和链路层不必关心也不需要关心**。

#### 分片的过程

假设IP层要发送4500字节的数据，由于该数据超过了MAC帧规定的MTU，因此IP需要先将该数据进行分片，然后再将一个个的分片交给MAC帧进行发送。

IP报头如果不携带选项字段，那么其大小就是20字节，假设IP层添加的IP报头的长度就是20字节，并按下列方式将数据分片后形成了四个分片报文：

![image-20230408162217484](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230408162217484.png)

**需要注意的是，分片后的每一个分片数据都需要封装上对应的IP报头，因此4500字节的数据至少需要分为四个分片报文进行发送。**

分片报文到达对方的IP层后需要被重新组装起来，因此IP层在对数据进行分片时需要记录分片的信息，而I**P报头当中的16位标识、3位标志和13位片偏移实际就是与数据分片相关的字段。**

- 16位标识：唯一标识主机发送的报文，如果数据在IP层进行了分片，那么每一个分片报文的16位标识是相同的。
- 3位标志：第一位保留，表示暂时没有规定该字段的意义。第二位表示禁止分片，表示如果报文长度超过MTU，IP模块就会丢弃该报文。第三位表示“更多分片”，如果报文没有进行分片，则该字段设置为0，如果报文进行了分片，则除了最后一个分片报文设置为0以外，其余分片报文均设置为1。
- 13位片偏移：分片相对于原始数据开始处的偏移，表示当前分片在原数据中的偏移位置，实际偏移的字节数是这个值× 8 得到的。因此除了最后一个报文之外，其他报文的长度必须是8的整数倍，否则报文就不连续了。

因此上述四个分片报文对应的16位标识都是一样的，假设四个分片报文的16位标识都是123，则这四个报文对应的16位标识、3位标志中的“更多分片”和13位片偏移分别如下：
![image-20230408162247817](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230408162247817.png)

**需要注意的是，13位片偏移当中记录的字节数是当前分片在原数据开始处的偏移字节数的值÷8得到的**，比如分片报文2在原始数据开始处的偏移字节数是1480，其对应的13位片偏移的值就是1480÷8=185。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/50afd2738bb44c1c820beb44a9768981.png)

#### 组装的过程

MAC帧交给IP层的数据可能来自世界各地，这些数据可能是经过分片后发送的，也可能是没有经过分片直接发送的，因此IP必须要通过某种方式来区分收到的各个数据。

- IP报头当中有32位源IP地址，源IP地址记录了发送端所对应的IP地址，因此**通过IP报头当中的32位源IP地址就可以区分来自不同主机的数据。**
- IP报头当中有16位标识，未分片的数据各自的16位标识都是不同的，而由同一个数据分片得到的各个分片报文所对应的16位标识都是相同的，因此**通过IP报头当中16位标识就可以判断哪些报文是没有经过分片的独立报文，哪些报文是经过分片后的分片报文。**

因此IP可以通过IP报头当中的32位源IP地址和16位标识，将经过分片的数据各自聚合在一起，聚合在一起后就可以开始进行组装了。

对于各个分片报文来说：

- 第一个分片报文中的13位片偏移的值一定为0。
- 最后一个分片报文中的“更多分片”标志位一定为0。
- 对于每一个分片报文来说，当前报文的13位片偏移加上当前报文的数据字节数 ÷ 8所得到的值，就是下一个分片报文的所对应的13位片偏移。

根据分片报文的这三个特点就能够将分片报文合理的组装起来。

- **先找到分片报文中13位片偏移为0的分片报文，然后提取出其IP报头当中的16位总长度字段，通过计算即可得出下一个分片报文所对应的13位片偏移，按照此方式依次将各个分片报文拼接起来。**
- **直到拼接到一个“更多分片”标志位为0的分片报文，此时表明分片报文组装完毕。**

#### 分片报文丢包的问题

分片后的报文在网络传输过程中也可能会出现丢包问题，但接收端有能力判断是否收到了全部分片报文，比如假设某组分片报文对应的16位标识值为x：

- 如果分片报文中的第一个分片报文丢包了，那么接收端收到的分片报文中就找不到对应16位标识为x，并且13位片偏移为0的分片报文。
- 如果分片报文中的最后一个分片报文丢包了，那么接收端收到的分片报文中就找不到对应16为标识为x，并且“更多分片”标志位为0的分片报文。
- 如果分片报文中的其它分片报文丢包了，那么接收端在进行分片报文的组装时就会找不到对应13位片偏移为特定值的分片报文。

需要注意的是，未分片报文的“更多分片”标志位为0，最后一个分片报文的“更多分片”标志位也为0，但当接收端只收到分片报文中的最后一个分片报文时，接收端不会将其识别成一个未分片的报文，因为**未分片的报文所对应的13位片偏移的值也应该是0，而最后一个分片报文所对应的13位片偏移的值不为0。**

因此只有当一个报文的13位片偏移为0，并且该报文的“更多分片”标志位也为0时，该报文才会被识别成一个没有被分片的独立报文，否则该报文就会被识别成一个分片报文。

#### 为什么不建议进行分片？

**虽然传输层并不关心IP层的分片问题，但分片对传输层也是有影响的。**

- 如果一个数据在网络传输过程中没有经过分片，那么只要接收端收到了这一个报文，我们就可以认为该数据被对方可靠的收到了。
- 而如果一个数据在网络传输过程中进行了分片，那么只有当接收端收到了全部的分片报文并将其成功组装起来，这时我们才认为该数据被对方可靠的收到了。但如果众多的分片报文当中有一个报文出现了丢包，就会导致接收端就无法将报文成功组装起来，这时接收端会将收到的分片报文全部丢弃，此时传输层TCP会因为收不到对方应答而进行超时重传。
- 假设在网络传输时丢包的概率是万分之一，如果将数据拆分为一百份进行发送，那么此时丢包的概率就上升到了百分之一。因为只要有一个分片报文丢包了也就等同于这个报文整体丢失了，因此分片会增加传输层重传数据的概率。

需要注意的是，**只要分片报文当中的某一个出现了丢包，此时传输层都需要将数据整体进行重传，因为传输层并不知道底层IP对数据进行了分片，当传输层发送出去的数据得不到应答时传输层就只能将数据整体进行重传，因此数据在发送时不建议进行分片**。

#### 如何尽可能避免分片？

**实际数据分片的根本原因在于传输层一次向下交付的数据太多了，导致IP无法直接将数据向下交给MAC帧，如果传输层控制好一次交给IP的数据量不要太大，那么数据在IP层自然也就不需要进行分片。**

- 因此TCP作为传输控制协议，它**需要控制一次向下交付数据不能超过某一阈值，这个阈值就叫做MSS（Maximum Segment Size，最大报文段长度）。**
- 通信双方在建立TCP连接时，除了需要协商自身窗口大小等概念之外，**还会协商**后续通信时每一个报文段所能承载的最大报文段长度MSS。

**MAC帧的有效载荷最大为MTU，TCP的有效载荷最大为MSS，由于TCP和IP常规情况下报头的长度都是20字节，因此一般情况下 MSS = MTU - 20 - 20，而MTU的值一般是1500字节，因此MSS的值一般就是1460字节。**

所以一般建议TCP将发送的数据控制在1460字节以内，此时就能够降低数据分片的可能性。之所以说是降低数据分片的可能性，是因为每个网络的链路层对应的MTU可能是不同的，如果数据在传输过程中进入到了一个MTU较小的网络，那么该数据仍然可能需要在路由器中进行分片。

### 网段划分

#### IP地址的构成

IP地址由网络号和主机号两部分构成：

- 网络号：保证相互连接的两个网段具有不同的标识。
- 主机号：同一网段内，主机之间具有相同的网络号，但是必须有不同的主机号。

可以在IP地址的后面加一个 /，并在 / 后面加上一个数字，这就表示从头数到第几位为止属于网络标识。

例如，下图中路由器连接了两个网段。对于网络标识来讲，同一网段内主机的网络标识是相同的，不同网段内主机的网络标识是不同的。而对于主机标识来讲，同一网段内主机的主机标识是不同的，不同网段内主机的主机标识是可以相同的。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/15f6674881194687a007a9c6d3dd1606-1680945642168160.png)

- 不同的子网其实就是把网络号相同的主机放到一起。
- 如果在子网中新增一台主机，则这台主机的网络号和这个子网的网络号一致，但是主机号必须不能和子网中的其他主机重复。

#### DHCP协议

实际手动管理IP地址是一个非常麻烦的事情，当子网中新增主机时需要给其分配一个IP地址，当子网当中有主机断开网络时又需要将其IP地址进行回收，便于分配给后续新增的主机使用。

- 因此对于IP地址的分配和回收一般不会手动进行，而是采用**DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）技术。**
- DHCP通常被应用在大型的局域网环境中，其主要作用就是集中地址管理、分配IP地址，使网络环境中的主机动态获得IP地址、Gateway地址、DNS服务器地址等信息，并能够提升地址的使用率。
- **DHCP是一个基于UDP的应用层协议**，一般的路由器都带有DHCP功能，因此路由器也可以看作一个DHCP服务器。

当我们连接WiFi时需要输入密码，本质就是因为路由器需要验证你的账号和密码，如果验证通过，那么路由器就会给你动态分配了一个IP地址，然后你就可以基于这个IP地址进行各种上网动作了。

#### 先找目标网络，再找目标主机

当IP要将数据跨网络从一台主机发送到另一台主机时，其实不是直接将数据发送到了目标主机，而是先将数据发送到目标主机所在的网络，然后再将数据发送到目标主机。

因此数据在路由时的第一目的并不是找到目标主机，而是找到目标网络所在的网络，然后再在目标网络当中找到目标主机。

数据路由时之所以不一开始就以找目标主机为目的，因为这样效率太低了。

- 找主机的过程本质是排除的过程，如果一开始就以找目标主机为目的，那么在查找的过程中一次只能排除一个主机。
- 而如果一开始先以找目标网络为目的，那么在查找过程中就能一次排除大量和目标主机不在同一网段的主机，这样就可以大大提高检索的效率。

因此，为了提高数据路由的效率，我们对网络进行了网段划分。

#### 网段划分

过去曾经提出一种划分网络号和主机号的方案，就是把所有IP地址分为五类，如下图所示：

![image-20230408172256588](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230408172256588.png)

因此，各类IP地址的取值范围如下：

- A类：0.0.0.0到127.255.255.255。
- B类：128.0.0.0到191.255.255.255。
- C类：192.0.0.0到223.255.255.255。
- D类：224.0.0.0到239.255.255.255。
- E类：240.0.0.0到247.255.255.255。

当要判断一个IP地址是属于哪一类时，只需要遍历IP地址的前五个比特位，第几个比特位最先出现0值，那么这个IP地址对应就属于A、B、C、D、E类地址。

#### 子网划分

但随着网络的飞速发展，这种划分方案的局限性很快就显现出来了。

- 比如一些学校、公司、实验室等组织想要申请自己的局域网，由于A类地址的网络号只占7个比特位，因此A类地址可申请的网络只有2^7个，于是大多数组织都选择申请B类地址。
- 由于B类地址的主机号占16个比特位，因此理论上一个B类网络当中允许有65536台主机。
- 但实际网络架设中，一般不会存在一个局域网当中有这么多主机的情况，也就意味着大量的IP地址实际都被浪费掉了。

为了避免这种情况，于是又提出了新的划分方案，称为**CIDR（Classless Interdomain Routing）**：

- 在原有的五类网络的基础上继续进行子网划分，这也就意味着**需要借用主机号当中的若干位来充当网络号**，此时为了区分IP地址中的网络号和主机号，于是引入了**子网掩码（subnet mask）**的概念。
- 每一个子网都有自己的子网掩码，子网掩码实际就是一个32位的正整数，通常用一串“0”来结尾。
- 将IP地址与当前网络的子网掩码**进行“按位与”操作，就能够得到当前所在网络的网络号**。

此时一个网络就被更细粒度的划分成了一个个更小的子网，通过不断的子网划分，子网中IP地址对应的主机号就越来越短，因此子网当中可用IP地址的个数也就越来越少，这也就避免了IP地址被大量浪费的情况。

- 比如在某一子网中将IP地址的前24位作为网络号，那么该网络对应的子网掩码的32个比特位中的前24位就为1，剩下的8个比特位为0，将其用点分十机制表示就是255.255.255.0。
- 假设该子网当中有一台主机对应的IP地址是192.168.128.10，那么将这个IP地址与该网络对应的子网掩码进行“按位与”操作后得到的就是192.168.128.0，这就是这个子网对应的网络号。
- 实际在用子网掩码与子网当中主机的IP地址进行“按位与”操作时，本质就是保留了主机IP地址中前24个比特位的原貌，将剩下的8个比特位的值清0了而已，也就是将主机号清0了，所以“按位与”后的结果就是该网络对应的网络号。

**需要注意的是，子网划分不是只能进行一次，我们可以在划分出来的子网的基础上继续进行子网划分。**

因此一个数据在路由的时候，随着数据不断路由进入更小的子网，其网络号的位数是在不断变化的，准确来说其网络号的位数是在不断增加的，这也就意味着IP地址当中的主机号的位数在不断减少。最终当数据路由到达目标主机所在的网络时，就可以在该网络当中找到对应的目标主机并将数据交给该主机，此时该数据的路由也就结束了。

### 特殊的IP地址

并不是所有的IP地址都能够作为主机的IP地址，有些IP地址本身就是具有特殊用途的。

- **将IP地址中的主机地址全部设为0，就成为了网络号，代表这个局域网。**
- **将IP地址中的主机地址全部设为1，就成为了广播地址，用于给同一个链路中相互连接的所有主机发送数据包。**
- 1**27.*的IP地址用于本机环回（loop back）测试，通常是127.0.0.1。**

也就是说，**IP地址中主机号为全0的代表的是当前局域网的网络号，IP地址中主机号为全1的代表的是广播地址**，这两个IP地址都是不能作为主机的IP地址的。因此在**某个局域网中最多能存在的主机个数是 2^主机号位数 − 2**。

#### 本机环回基本原理

本机环回会将数据贯穿网络协议栈，但最终并不会将数据发送到网络当中，相当于本机环回时不会将数据写到网卡上面。

**本机环回的目的就是将数据自顶向下贯穿协议栈，进行一次数据封装的过程的过程，然后再自底向上贯穿协议栈，进行一次数据的解包和分用，用于测试本地的网络功能是否正常。**

本机环回的基本原理：

- 当数据到达IP层需要继续向下交付时，如果是环回程序，那么IP输出函数会将该数据放入到IP输入队列当中，然后再由IP输入函数读取上去。
- 而IP输入函数将数据读取上去的本应该是链路层交付上来的数据，因此该数据后续就会被当作从网络中读取上来的数据看待，各层协议会对该数据依次进行解包和分用。
- 如果不是环回程序的话，那么接下来就会判断该数据对应的目的IP地址是否为广播或多播地址(多个目标)，或者目的IP地址是否与本主机的IP地址相同，如果是则也会将该数据放入到IP输入队列当中，等待IP输入函数将其读走。
- 只有判断程序不是环回程序，并且也不是广播或多播，或发给本主机的数据后，才会用ARP获取该数据目的主机的以太网地址并进行后续数据发送的操作。

**oopback设备：**

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/7022cc71ac6441999b15e6b3fc751ee0.png)

### IP地址的数量限制

#### IP地址数量不足问题

我们知道，IP地址（IPv4）是一个4字节32位的正整数，因此一共有2^32个IP地址，也就是将近43亿个IP地址。但TCP/IP协议规定，每个主机都需要有一个IP地址。

- 现在全世界人口已经有70多亿了，就算有一半的人没有智能手机，算下来也有30多亿台智能手机需要IP地址。
- 随着科技的发展，我们使用的电脑、智能手表、智能冰箱、智能洗衣机等设备如果要入网也是需要IP地址的。
- 另外，IP地址并不是按照主机台数来配置的，因此一个主机可能需要多个IP地址，更别谈还有很多组网的路由设备也需要IP地址，以及一些特殊的IP地址不能使用的问题。

所以43亿个IP地址其实早就不够用了，因此才提出了CIDR的方案对已经划分好的五类网络继续进行子网划分，其目的就是为了减少IP地址的浪费，根本原因就是IP地址本来就不够了，所以不能够再浪费了。

CIDR在一定程度上缓解了IP地址不够用的问题，因为CIDR提高了IP地址的利用率，减少了浪费，但IP地址的绝对上限并没有增加。

#### 如何解决IP地址不足问题

解决IP地址不足有以下几种方式：

- **动态分配IP地址**：只给接入网络的设备分配IP地址，因此同一个MAC地址的设备，每次接入互联网中，得到的IP地址不一定是相同的，避免了IP地址强绑定于某一台设备。
- **NAT技术**：能够让不同局域网当中同时存在两个相同的IP地址，NAT技术不仅能解决IP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。
- **IPv6**：IPv6用16字节128位来表示一个IP地址，能够大大缓解IP地址不足的问题。但IPv6并不是IPv4的简单升级版，它们是互不相干的两个协议，彼此并不兼容，因此目前IPv6还没有普及。

### 私网IP地址和公网IP地址

#### 私网IP地址的种类

如果一个组织内部组建局域网，IP地址只用于局域网内的通信，而不直接连到Internet上，理论上使用任意的IP地址都可以，但是**RFC 1918规定了用于组建局域网的私有IP地址**。

- 10.*，前8位是网络号，共16,777,216个地址。
- 172.16.\*到172.31.*，前12位是网络号，共1,048,576个地址。
- 192.168.\*，前16位是网络号，共65,536个地址。

**包含在这个范围中的，都称为私网IP，其余的则称为公网IP（或全局IP）**。

我们连接云服务器时，连接的这个IP地址就是云服务器的公网IP地址。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/f9f39804490046b887fd2ad338641768-1680946175489166-1680946202614168.png)

我们可以通过`ifconfig`命令来查看我们这台机器的私网IP，其中网络接口lo（loop）代表的是本地环回，而eth0代表的就是我这台机器的网络接口，可以看到我的私网IP地址是172.21.0.15。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/39502351f8d4460692b5c5e3eaa07f0f-1680946208311172.png)

需要注意的是，这里连接云服务器时的IP地址49.232.66.206，是云服务器的公网IP，由于我使用的是腾讯云，因此这里的172.21.0.15是我这个云服务器在腾讯内部的私网IP，可以看到这个IP正好在第二种私网IP范围内。

此外，打开Windows当中的cmd窗口，通过ipconfig命令可以看到大量以192.168开头的私网IP。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/24da1d53a86c432d88f8d218d9b87133-1680946232631176-1680946235387178.png)

#### 我们为什么要给运营商交钱？

我们享受的是互联网公司提供服务，但为什么需要向运营商交钱呢？

- 实际网络通信的基础设施都是运营商搭建的，我们访问服务器的数据并不是直接发送到了对应的服务器，而是需要经过运营商建设的各种基站以及各种路由器，最终数据才能到达对应的服务器。
- 因为运营商为我们提供了通信的基础设施，所以我们交网费实际就相当于购买入网许可一样。
- 没有运营商提供的这些基础设施，就不会诞生所谓的互联网公司，因为互联网公司是诞生在网络通信基础之上的。

也就是说，用户上网的数据首先必须经过运营商的相关网络设备，然后才能发送到互联网公司对应的服务器。因此所谓的网段划分、子网划分等工作实际都是运营商做的。

#### 数据是如何发送到服务器的

路由器是连接两个或多个网络的硬件设备，在路由器上有两种网络接口，分别是LAN口和WAN口：

- **LAN口（Local Area Network）：表示连接本地网络的端口，主要与家庭网络中的交换机、集线器或PC相连。**
- **WAN口（Wide Area Network）：表示连接广域网的端口，一般指互联网。**

我们将LAN口的IP地址叫做LAN口IP，也叫做子网IP，将WAN口的IP地址叫做WAN口IPO，也叫做外网IP。

我们使用的电脑、家用路由器、运营商路由器、广域网以及我们要访问的服务器之间的关系大致如下：
![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/997dc9f37de846cf92b09cb142a9fd2d-1680946317405182.png)

- **不同的路由器，子网IP其实都是一样的（通常都是192.168.1.1），子网内的主机IP地址不能重复，但是子网之间的IP地址就可以重复了。**
- 每一个家用路由器，其实又作为运营商路由器的子网中的一个节点，这样的运营商路由器可能会有很多级，最外层的运营商路由器的WAN口IP就是一个公网IP了。
- 如果希望我们自己实现的服务器程序，能够在公网上被访问到，就需要把程序部署在一台具有外网IP的服务器上，这样的服务器可以在阿里云/腾讯云上进行购买。

由于私网IP不能出现在公网当中，因此子网内的主机在和外网进行通信时，路由器会不断将数据包IP首部中的源IP地址替换成路由器的WAN口IP，这样逐级替换，最终数据包中的源IP地址成为一个公网IP，这种技术成为**NAT（Network Address Translation，网络地址转换）。**

#### 为什么私网IP不能出现在公网当中？

- 不同的局域网中主机的IP地址可能是相同的，所以私网IP无法唯一标识一台主机，因此不能让私网IP出现在公网上，因为IP地址要能唯一标识公网上的一台主机。
- 但由于IP地址不足的原因，我们不能让主机直接使用公网IP而让主机使用私网IP，因为私网IP可以重复也就意味着我们可以在不同的局域网使用相同的IP地址，缓解了IP的不足。
- 此外，我们不能直接使用公网IP还有一个原因就是，因为我们的数据包必须要经过运营商的路由器，如果我们发送的数据直接到了公网，那也就意味着我们再也不用交网费了，这是不现实的。

#### 两个局域网当中的主机不能不跨公网进行通信

- **两个局域网当中的主机理论上是不能不跨公网进行通信的**，因为一个主机要将数据发送给另一台主机的前提是得先知道另一台主机的IP地址。
- 即便现在这个主机知道了另一台主机的IP地址，但有可能这两台主机的IP地址是一样的，因为它们的IP地址都是私网IP地址。
- 当这一台主机发送数据时将目的IP地址填成和自己相同的IP地址，操作系统就会认为这个数据就是要发给自己的，而不会向外进行发送了。

所以数据要从一个局域网发送到另一个局域网，如果不经过公网是基本上不可能的。我们在和别人聊天的时候，也不是直接将数据从一个局域网直接发送到了另一个局域网，而是先将数据经过公网发送到了服务器，然后再由服务器将数据经过公网转发到了另一个局域网。

但实际确实**存在一些技术能够使数据包在发送过程中不进行公网IP的替换，而将数据正确送到目标主机，这种技术叫做内网穿透，也叫做NAT穿透。**

### 路由

#### 数据“问路”的过程

数据在路由的过程中，实际就是一跳一跳（Hop by Hop）“问路”的过程。所谓“一跳”就是数据链路层中的一个区间，具体在以太网中指从源MAC地址到目的MAC地址之间的帧传输区间。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/544d4039601b44b593e51138cbc03dae-1680946614413186.png)

IP数据包的传输过程中会遇到很多路由器，这些路由器会帮助数据包进行路由转发，每当数据包遇到一个路由器后，对应路由器都会查看该数据的目的IP地址，并告知该数据下一跳应该往哪跳。

路由器的查找结果可能有以下三种：

- 路由器经过路由表查询后，**得知该数据下一跳应该跳到哪一个子网**。
- 路由器经过路由表查询后**，没有发现匹配的子网，此时路由器会将该数据转发给默认路由**。
- 路由器经过路由表查询后，**得知该数据的目标网络就是当前所在的网络，此时路由器就会将该数据转给当前网络中对应的主机**。

#### 路由表查询的具体过程

每个路由器内部会维护一个路由表，我们可以通过`route`命令查看云服务器上对应的路由表。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/1c7d1bb6d2f844339ded271b49827997.png)

- Destination代表的是目的网络地址。
- Gateway代表的是下一跳地址。
- Genmask代表的是子网掩码。
- Flags中，U标志表示此条目有效（可以禁用某些条目）G标志表示此条目的下一跳地址是某个路由器的地址，没有G标志的条目表示目的网络地址是与本机接口直接相连的网络，不必经路由器转发。
- Iface代表的是发送接口。

当IP数据包到达路由器时，路由器就会用该数据的目的IP地址，依次与路由表中的子网掩码 Genmask进行“按位与”操作，然后将结果与子网掩码对应的目的网络地址Destination进行比对，如果匹配则说明该数据包下一跳就应该跳去这个子网，此时就会将该数据包通过对应的发送接口Iface发出。

如果将该数据包的目的IP地址与子网掩码进行“按位与”后，没有找到匹配的目的网络地址，此时路由器就会将这个数据包发送到默认路由，也就是路由表中目标网络地址中的default。可以看到默认路由对应的Flags是UG，实际就是将该数据转给了另一台路由器，让该数据在另一台路由器继续进行路由。

数据包不断经过路由器路由后，最终就能到达目标主机所在的目标网络，此时就不再根据该数据包目的IP地址当中的网络号进行路由了，而是根据目的IP地址当中的主机号进行路由，最终根据该数据包对应的主机号就能将数据发送给目标主机了。

### 路由表生成算法

路由可分为静态路由和动态路由：

- 静态路由：是指由网络管理员手工配置路由信息。
- 动态路由：是指路由器能够通过算法自动建立自己的路由表，并且能够根据实际情况进行调整。

路由表相关生成算法：距离向量算法、LS算法、Dijkstra算法等。

### 小结

分片

组装

避免分片 MTU  MSS

则TCP协议，单词可以发送的最大数据为 min(MTU-20-20， MSS， 滑动窗口，拥塞窗口)，滑动窗口+拥塞窗口控制着发送方可以同时发送的最大数据，MTU+MSS控制着单次最大数据

网段划分

- 网络号，主机号
- ABCDE类网络
- 子网掩码：增加网段的数量

特殊IP

- 广播地址
- 本地换回

私有IP地址

路由转发 

- 私网 公网	
- NAT

## 数据链路层协议

### 链路层解决的问题

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/16ca94d37e7f4121a68811d085af4808-16810179077501-16810179104334.png)

- IP拥有将数据跨网络从一台主机送到另一台主机的能力，但IP并不能保证每次都能够将数据可靠的送到对端主机，因此IP需要上层TCP为其提供可靠性保证，比如数据丢包后TCP可以让IP重新发送数据，最终在TCP提供的可靠性机制下IP就能够保证将数据可靠的发送到对端主机。
- TCP除了对下层IP提供可靠性机制之外，TCP对上还提供进程到进程的服务，我们在进行socket编程时，本质就是在使用TCP或UDP为我们提供的进程到进程的服务。
- 但数据在网络传输时需要一跳一跳的从一台主机跳到另一台主机，最终才能将数据转发到目标主机，因此要将数据发送到目标主机的前提是，需要先将数据转发给与当前主机直接相连的下一跳主机，而两台主机直接相连也就意味着这两台主机属于同一网段，因此**将数据转发到下一跳主机实际是属于局域网通信范畴的，而这实际就是链路层需要解决的问题**。
- 也就是说，**网络层IP提供的是跨网络发送数据的能力，传输层TCP是为数据发送提供可靠性保证的，而链路层解决的则是两台相连主机之间的通信**问题。

- 数据链路层协议中最著名也是使用最广泛的是以太网协议。

### 认识以太网

#### 局域网技术

不同局域网所采用的通信技术可能是不同的，常见的局域网技术有以下三种：

- 以太网：以太网是一种计算机局域网技术，一种应用最普遍的局域网技术。
- 令牌环网：令牌环网常用于IBM系统中，在这种网络中有一种专门的帧称为“令牌”，在环路上持续地传输来确定一个节点何时可以发送包。
- 无线LAN/WAN：无线局域网是有线网络的补充和扩展，现在已经是计算机网络的一个重要组织部分。

虽然网络中各个局域网所采用的通信技术可能的不同的，但是IP屏蔽了底层网络的差异，对于网络通信双方的IP层及其往上的协议来说，它们并不需要关心底层具体使用的是哪种局域网技术。

- 数据在发送之前会先进行数据封装，此时链路层会给数据封装上对应的局域网的报头。
- 如果数据要进行跨网络传输，那么就需要经过路由器转发。
- 当数据在路由器进行向上交付时，会将该数据对应的局域网报头去掉。
- 而当路由器该数据转发给下一跳之前，又会给该数据封装上下一跳网络所对应的局域网报头。

也就是说，**网络中的路由器会不断去掉数据旧的局域网报头，并添加上新的局域网报头，因此数据在进行跨网络传输时，就算所需跨越的网络采用的是不同的局域网技术，最终也能够正确实现跨越**。

#### 以太网通信原理

- “以太网”不是一种具体的网络，而是一种技术标准，它既包含了数据链路层的内容，也包含了一些物理层的内容。例如，以太网规定了网络拓扑结构，访问控制方式，传输速率等。
- 以太网中的网线必须使用双绞线，传输速率有10M，100M，1000M等。

**以太网中所有的主机共享一个通信信道，当局域网中的一台主机发出数据后，该局域网中的所有主机都能够收到该数据**。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/6e177649b6144b3abb9ae05f526cf53f-16810180779238.png)

- 比如当局域网中的主机A想要发送数据给主机B时，其实局域网当中的每一台主机都能收到主机A发出去的数据，只不过最终只有主机B会将主机A发来的数据向上进行交付。
- 局域网当中的其他主机虽然也收到了主机A发出的数据，但经过识别后发现这个数据不是发送给自己的，于是就会直接将该数据丢弃而不会向上进行交付。

也就是说，在进行局域网通信的时候，局域网当中的所有主机都能够看到局域网中传输的任何数据，只不过每个主机都只关心发送给自己的数据罢了。

**扩展：**

- 网络抓包不仅能够抓到发送给自己的报文数据，也能抓取到发给别人的报文数据，实际就是因为在进行网络抓包时，主机将从局域网中收到的所有报文数据都向上交付了而已。
- 网卡有一种模式叫做混杂模式，被设置为混杂模式的网卡能够接收所有经过它的数据流，而不论其目的地址是否是它。

#### 碰撞避免算法

由于以太网中的所有的主机共享一个通信信道，因此在同一时刻只允许有一台主机发送数据，否则各个主机发送的数据就会相互干扰。站在系统的角度来看，这里**各个主机所共享的通信信道就是一种临界资源**，这个临界资源同一时刻只允许一台主机使用。

- 对于这个问题，以太网的做法就是先不限制各个主机发送数据的能力，局域网中的每个主机想发数据的时候直接发就行了，但是只要发送出去的数据与其他主机发送的数据产生了碰撞，那就得执行碰撞避免算法。
- 所谓的碰撞避免算法就是，当主机发送出去的数据产生碰撞时，该主机需要等待一段时间后再进行数据重发，在主机等待的时候就能够就能够尽可能让局域网当中的数据消散。
- 以太网通信的原理就像现实生活中开会一样，在开会过程中同一时刻只允许一个人发言，如果两个人突然同时说话，那么双方都会有礼貌的等待别人先说。

也就是说，以太网中主机发送的数据产生碰撞后该主机会执行碰撞避免算法，所以我们说**以太网是基于碰撞域和碰撞检测的局域网通信标准**。

碰撞避免算法就是主机等待一段时间后重新发送数据，因此以太网底层也有重传机制，只不过以太网的重传机制只是为了保证将数据从局域网中的一台主机发送到另一台主机。

#### 令牌环网

- 令牌环网（Token-ring network）的传输方法在物理上采用了星形拓扑结构，但逻辑上是环形拓扑结构。
- 令牌环网的通信传输介质可以是无屏蔽双绞线、屏蔽双绞线和光纤等。
- 令牌环网中各节点间采用多站访问部件（Multistation Access Unit，MAU）连接在一起，MAU是一种专业化集线器，用来围绕工作站计算机的环路进行传输。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/7cefbf7ae2c74ba1941d10e607e3c960-168101841236312.png)

**在令牌环网中有一种专门的帧称为“令牌”，这个“令牌”会在环路上持续地传输，只有拿到“令牌”的主机才能发送数据，因此发送出去的数据不会发生碰撞。**

- **令牌环网当中的“令牌”就像系统当中用于保护临界资源的互斥锁一样**，“令牌”与互斥锁一样也有“忙”和“闲”两种状态，“忙”表示令牌已经被占用，而“闲”则表示令牌没有被占用。
- 想要发送数据的计算机必须首先检测到“闲”令牌，并将其置为“忙”状态，然后才可以发送数据，这就和申请互斥锁的过程很像。
- 此外，由于“令牌”在网环上是按顺序依次传递的，因此对于所有入网的计算机而言，它们获取令牌的机会都是相等的，因此**不会造成某台主机发送数据的饥饿问题**。

### 以太网帧格式

#### 格式

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/29aaed9618c74acda925cc954a997916.png)

- 源地址和目的地址是指网卡的硬件地址（也叫MAC地址），长度是48位，是在网卡出厂时固化的。
- **帧协议类型字段有三种值，分别对应IP协议、ARP协议和RARP协议**。
- 帧末尾是CRC校验码。

#### MAC帧如何将报头与有效载荷进行分离？

以太网MAC帧的帧头和帧尾都是固定长度的，因此当底层收到一个MAC帧后，直接提取出MAC帧当中固定长度的帧头和帧尾，此时剩下的就是有效载荷了。

#### MAC帧如何决定将有效载荷交付给上层的哪一个协议？

以太网MAC帧对应的上层协议不止一种，因此在将MAC帧的报头和有效载荷分离后，还需要确定应该将分离出来的有效载荷交付给上层的哪一个协议。

在MAC帧的帧头当中有2个字节的类型字段，因此在分离出报头和有效载荷后，根据该字段将有效载荷交付给对应的上层协议即可。

**举个例子**

> 假设局域网当中的主机A想要将IP数据报发送给同一局域网当中的主机B，那么主机A封装MAC帧当中的目的地址就是主机B的MAC地址，源地址就是主机A的MAC地址，而帧协议的类型对应就是0800，紧接着就是要发送的IP数据报，帧尾部分对应就是CRC校验。
>
> ![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/e582def7f62b43c5848292e11aaccd54-168101866554518.png)
>
> 当主机A将该MAC帧发送到局域网当中后，局域网当中的所有主机都可以收到这个MAC帧，包括主机A自己。
>
> - 主机A收到该MAC帧后，可以对收到的MAC帧**进行CRC校验**，如果校验失败则说明数据发送过程中产生了碰撞，此时主机A就会执行碰撞避免算法，后续进行MAC帧重发。
> - 主机B收到该MAC帧后，**提取出MAC帧当中的目的地址，发现该目的地址与自己的MAC地址相同**，于是在CRC校验成功后就会将有效载荷交付给上层IP层进行进一步处理。
> - 局域网中的其他主机收到该MAC帧后，也会提取出MAC帧当中的目的地址，但发现该目的地址与自己的MAC地址**不匹配，于是就会直接将这个MAC帧丢弃掉**。
>
> 也就是说，当底层收到一个MAC帧后，会根据MAC帧当中的目的地址来判断该MAC帧是否是发给自己的，如果是发送给自己的则会再对其进行CRC校验，如果校验成功则会根据该MAC帧的帧协议类型，将该MAC交付给对应的上层协议进行处理。



### 认识MAC地址

#### MAC地址

- MAC地址用来识别数据链路层中相连的节点。
- 长度为48位，及6个字节，一般用16进制数字加上冒号的形式来表示，例如：08:00:27:03:fb:19。
- 在网卡出厂时就确定了，不能修改，**MAC地址通常是唯一的**（虚拟机中的MAC地址不是真实的MAC地址，可能会冲突；也有些网卡支持用户配置MAC地址）。

我们可以通过ifconfig命令来查看我们的MAC地址。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/d9aa7637248c4a0ab0e337af5747ae84-168101874079922.png)

注：MAC地址前面的单词ether就是“以太”的意思。

#### 对比理解MAC地址和IP地址

实际数据在路由过程中会存在两套地址，一套是源IP地址和目的IP地址，还有一套是源MAC地址和目的MAC地址。

- **IP地址描述的是路途总体的起点和终点。**
- **MAC地址描述的是路途上的每一个区间的起点和终点。**

比如做公交车时，源IP地址就是我们上车的站点，目的IP地址就是我们最终要下车的站点，而源MAC地址就是公交车上一个已经到达的站点，目的MAC地址就是公交车下一个将要到达的站点。

因此数据在路由过程中，源IP地址和目的IP地址可以理解成是不会变化的，而数据每进行一跳后其源MAC地址和目的MAC地址都会变化。

注：实际数据在路由过程中，源IP地址和目的IP地址也可能会发生变化。（NAT技术）

### 认识MTU

#### MTU

**MTU（Maximum Transmission Unit，最大传输单元）描述的是底层数据帧一次最多可以发送的数据量，这个限制是不同的数据链路层对应的物理层产生的。**

- 以太网对应MTU的值一般是1500字节，不同的网络类型有不同的MTU，如果一次要发送的数据超过了MTU，则需要在IP层对数据进行分片（fragmentation）。
- 此外，**以太网规定MAC帧中数据的最小长度为46字节，如果发送数据量小于46字节，则需要在数据后面补填充位，比如ARP数据包的长度就是不够46字节的**。

#### MUT对IP协议的影响

因为数据链路层规定了最大传输单元MTU，所以如果IP层一次要发送的数据量超过了MTU，此时IP层就需要先对该数据进行分片，然后才能将分片后的数据向下交付。

- IP层会将较大的数据进行分片，并给每个分片数据包进行标记，具体就是通过设置IP报头当中的16位标识、3位标志和13位片偏移来完成的。
- 由同一个数据分片得到的各个分片报文，所对应的IP报头当中的16位标识（id）都是相同的。
- 每一个分片报文的IP报头当中的3位标志字段中，第2位设置为0，表示允许分片，第3位用作结束标记（最后一个分片报文设置为0，其余分片报文设置为1）。
- 当对端IP层收到这些分片报文后，需要先将这些分片报文按顺序进行组装，拼装到一起后再向上交付给传输层。
- 如果分片后的某个报文在网络传输过程中丢包了，那么对端在进行数据组装时就会失败，此时就需要上层传输层进行数据重传。

数据的分片和组装发生在IP层，不仅源端主机可能会对数据进行分片，数据在路由过程中的路由器也可能对数据进行分片。因为不同网络的MTU是不一样的，如果传输路径上的某个网络的MTU比源端网络的MTU小，那么路由器就可能对IP数据报再次进行分片。

#### MTU对UDP协议的影响

IP报头当中如果不携带选项字段，那么IP报头的长度就是20字节，而UDP采用的是定长的8字节报头，因此如果UDP一次携带的数据超过了 1500 − 20 − 8 = 1472字节，此时数据就需要在IP层进行分片。

- 分片后得到的多个IP数据报中有任意一个在传输过程中丢失，都会引起接收端IP层重组失败。
- 假设在网络传输时丢包的概率是万分之一，如果将数据拆分为一百份进行发送，那么此时丢包的概率就上升到了百分之一。
- 因为只要有一个分片报文丢包了也就等同于这个报文整体丢失了，因此分片会增加UDP报文丢包的概率。
- UDP报文丢失不会重传

#### MTU对TCP协议的影响

对于TCP来说，分片也会增加TCP报文丢包的概率，但与UDP不同的是TCP丢包后还需要进行重传，因此TCP应该尽量减少因为分片导致的数据重传。

- TCP发送的数据报不能无限大，还是应该受制于MTU，我们将TCP的单个数据报的最大报文长度，称为MSS（Max Segment Size）。
- TCP通信双方在建立连接的过程中，就会进行MSS协商，最终选取双方支持的MSS值当中的较小值作为最终MSS。
- MSS的值实际就是在TCP首部的40字节的选项字段当中的（kind=2）。
- 最理想的情况下，MSS的值正好就是在数据不会在IP层进行分片的最大长度。

MSS和MTU的关系如下：

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/dddfcb7dd79f44b285b0dfac69edc559-168101896132826.png)

### 数据跨网络传输的过程

#### 过程

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/544d4039601b44b593e51138cbc03dae-168101903594028-168101903777231.png)

以主机A将数据跨网络传输给主机B为例，数据路由的过程如下：

- 主机A要想将数据跨网络传输给主机B，需要先将数据交给同局域网当中的路由器A，因此主机A需要将封装好的MAC帧发送到当前局域网当中，此时MAC帧当中的源MAC地址和目的MAC地址，对应就是主机A的MAC地址和路由器A的MAC地址。
- 此时主机A所在局域网当中的所有主机都能收到这个MAC帧，但最终只有路由器A发现该MAC帧当中的目的MAC地址与自己的MAC地址相同，于是才会对该MAC帧进行解包，并将解包后剩下的IP数据报交付给IP层。
- 路由器A的IP层拿到解包后的IP数据报后，会提取出IP报头当中的目的IP地址，然后通过查询路由表后确定需要将该数据转发给路由器B，于是路由器A再将数据向下进行交付，重新封装MAC帧的帧头和帧尾，但此时封装后的MAC帧当中的源MAC地址和目的MAC地址，就变成了路由器A的MAC地址和路由器B的MAC地址。
- 与路由器A直接相连的主机虽然也可能有很多，但最终只有路由器B发现该MAC帧当中的目的MAC地址与自己的MAC地址相同，于是才会对该MAC帧进行解包，并将解包后剩下的IP数据报交付给IP层。
- 路由器B的IP层拿到解包后的IP数据报后，同样会提取出IP报头当中的目的IP地址，并通过查询路由表后确定需要将该数据转发给路由器C，于是路由器B再将数据向下进行交付，重新封装MAC帧的帧头和帧尾，但此时封装后的MAC帧当中的源MAC地址和目的MAC地址又变了，变成了路由器B的MAC地址和路由器C的MAC地址。
- …
- 不断重复上述过程，直到最终数据转发至主机B。

因此**数据在进行跨网络传输时，其对应的源IP地址和目的IP地址一般是不会变化的，而该数据的源MAC地址和目的MAC地址却是一直在变化的，根本原因就是因为该数据对应的上一跳主机和下一跳主机在不断变化**。

#### IP网络

数据跨网络传输的过程就像现实生活中运输包裹的过程一样。

- 数据每到一个新的局域网就需要封装上对应局域网标准的报头，就像包裹在运输的不同阶段可能会使用不同的交通工具，比如火车、汽车、自行车
- 但站在IP层看到的数据内容始终是一样的，就像我们最终看到的始终是同一个包裹一样。
- 包裹运输时使用的不同的交通工具，对应就是数据路由经过不同局域网时所添加的MAC帧报头，而包裹对应就是MAC帧的有效载荷，即IP数据报。

也就是说，数据在跨网络传输过程中，其对应的MAC帧的报头是不断在变化的，而MAC帧当中的IP数据报当中的内容是不变的，所以站在IP层看到的数据内容都是一样的，这就是为什么现在主流的网络叫做“IP网络”的原因。

### 小结

数据帧格式

MTU及对IP/TCP/UDP的影响

以太网发送原理：广播

以太网数据碰撞：交换机原理

在整条传输路线中，有很多路由器，及存在很多下三层协议栈，那么如果对应的MTU/MSS不相同，也有可能发生IP切片

## 其他协议

### ARP

**地址解析协议（Address Resolution Protocol，ARP）协议，是根据IP地址获取MAC地址的一个TCP/IP协议**。

**数据链路层协议，在以太网协议上面**。

#### 为什么会存在ARP这样的协议？

以刚才的例子为例，当数据从主机A经过各种路由转发到达路由器D，此时路由器D就需要将数据转发给主机B完成数据的路由。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/544d4039601b44b593e51138cbc03dae-168101950096733-168101950790036.png)

- 由于路由器D和主机B是属于同一个局域网的，因此路由器D能够直接将数据交给主机B，但要给同局域网中的一台主机发送数据，前提是得先知道对方的MAC地址。
- 但路由器D此时只知道主机B的IP地址，因此路由器D必须通过某种方式得到主机B的MAC地址。

也就是说，在同一个局域网中要给对方发消息，就必须得知道对方的MAC地址，而实际大部分情况下我们只知道对方的IP地址，因此需要通过ARP协议来根据IP地址来获取目标主机的MAC地址。

#### ARP协议的定位

在TCP/IP四层模型中，网络协议栈自顶向下分为应用层、传输层、网络层和数据链路层。

其中应用层最典型的协议有HTTP、HTTPS和DNS等，传输层最典型的协议有TCP和UDP，网络层最典型的协议就是IP，数据链路层最典型的协议就是MAC帧协议，但实际数据链路层还有两种协议叫做ARP和RARP。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/a43fa77dd53a4758a9ebe280ee4771e1-168101954113340.png)

ARP、RARP和MAC帧协议虽然都属于数据链路层的协议，但ARP协议和RARP协议属于MAC帧的上层协议

- 也就是说，**MAC帧的上层协议不一定就直接是网络层的协议**，MAC帧的上层协议有可能也属于数据链路层的协议，但就是位于MAC帧的上层。
- 与之类似的，网络层当中的ICMP协议和IGMP协议，这两个协议虽然与IP协议都属于网络层，但这两个协议属于IP的上层协议。

#### ARP数据的格式

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/7b31f29e08b04c368f639f9b178ce87c-168101957896144.png)

- **硬件类型指链路层的网络类型**，1为以太网。
- **协议类型指要转换的地址类型**，0x0800为IP地址。
- **硬件地址长度对于以太网地址为6字节**，因为MAC地址是48位的。
- **协议地址长度对于IP地址为4字节**，因为IP地址是32位的。
- **op字段为1表示ARP请求，op字段为2表示ARP应答**。

从ARP的数据格式也可以看出，ARP是MAC帧协议的上层协议，ARP数据格式中的前3个字段和最后一个字段对应的就是以太网首部，但由于ARP数据包的长度不足46字节，因此ARP数据包在封装成为MAC帧时还需要补上18字节的填充字段。

#### ARP协议的工作流程

还是以刚才的例子为例，路由器D要将数据转发给同一局域网当中的主机B，前提是路由器D必须知道主机B的MAC地址，而现在路由器D只知道主机B的IP地址，因此路由器D现在需要向主机B发起ARP请求，然后等待主机B发送ARP应答得知主机B的MAC地址。

##### ARP请求的过程

**首先路由器D需要先构建ARP请求。**

- 首先，因为路由器D构建的是ARP请求，因此ARP请求当中的**op字段设置为1**。
- ARP请求当中的**硬件类型字段设置为1**，因为当前使用的是以太网通信。
- ARP请求当中的**协议类型设置为0800**，因为路由器是要根据主机B的IP地址来获取主机B的MAC地址。
- ARP请求当中的**硬件地址长度和协议地址长度分别设置为6和4**，因为MAC地址的长度是48位，IP地址的长度是32位。
- ARP请求当中的**发送端以太网地址和发送端IP地址，对应就是路由器D的MAC地址和IP地址**。
- ARP请求当中的目的以太网地址和目的IP地址，对应就是主机B的MAC地址和IP地址，但**由于路由器D不知道主机B的MAC地址，因此将目的以太网地址的二进制序列设置为全1**，表示在局域网中进行广播。

此时ARP请求构建完成，如下：

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/6088b2061f7e4de7807c5e826c559f43-168101966685648.png)

ARP请求构建完成后，为了能将ARP请求发送到以太网当中，还**需要将ARP数据包向下交付给MAC帧协议，封装成MAC帧**。

- 封装MAC帧报头时，以太网目的地址和以太网源地址，对应分别是主机B和路由器D的MAC地址，但由于路由器D不知道主机B的MAC地址，因此MAC帧报头当中的以太网目的地址的二进制序列也只能设置为全1，表示在局域网中进行广播。
- 因为这里封装的是一个ARP请求数据包，因此MAC帧当中的帧类型字段设置为0806。
- 由于ARP请求数据包的长度只有28字节，不足46字节，因此还需要在MAC帧的有效载荷当中补上18字节的填充字段，最后再对MAC帧进行CRC校验即可。

此时ARP请求就被封装成MAC帧了，如下：

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/34fe2ea150cb4c78b9b6f526504f9303-168101970018652.png)

MAC帧封装完毕后，路由器D就可以将封装好的MAC帧以广播的方式发送到局域网当中了。

- 因为这个MAC帧是以广播的方式发出的，因此局域网当中的每台主机收到这个MAC帧后，都会对该MAC帧进行解包。当这些主机**识别到MAC帧当中的帧类型字段为0800后**，便知道这是一个ARP的请求或应答的数据包，于是会**将MAC帧的有效载荷向上交付给ARP层**。
- 当ARP层收到这个数据包后，**发现ARP数据包当中的op字段为1，于是判定这是一个ARP请求**，然后再提取出ARP数据包当中的目的IP地址字段，**虽然局域网当中的所有主机都会将该数据包交给自己的ARP层，但最终只有主机B发现ARP数据包当中的目的IP地址与自己相同，因此只有主机B会对该ARP请求进行应答**，而局域网当中的其他主机在识别到ARP数据包当中的目的IP地址与自己不匹配后，就会直接将这个ARP请求报文丢弃。

需要注意的是，局域网当中其他不相干的主机在收到这个ARP请求报文后，**不是在MAC帧层丢弃的，而是在ARP层发现该ARP数据包的目的IP与自己的IP不匹配后丢弃的**。

总结：

- 发起方构建ARP请求，以广播的方式发送给每一个主机。
- 每台主机都能识别接收，然后根据MAC帧的帧类型字段将有效载荷交付给每个主机的ARP层。
- 其他不相关主机立马根据目的IP，在自己的ARP协议内部丢弃ARP请求，只有目标主机会处理请求。

##### ARP应答的过程

**主机B在应答时首先需要构建ARP应答。**

- 首先，因为主机B构建的是ARP应答，因此ARP应答当中的**op字段设置为2**。
- **ARP应答当中的硬件类型、协议类型、硬件地址长度、协议地址长度的值与ARP请求当中设置的值相同**。
- ARP应答当中的**发送端以太网地址和发送端IP地址，对应就是主机B的MAC地址和IP地址**。
- ARP应答当中的目的以太网地址和目的IP地址，对应就是路由器D的MAC地址和IP地址，因为路由器D发来的ARP请求当中告知了主机B它的MAC地址和IP地址，因此主机B是知道的。

此时ARP应答构建完成，如下：

![**加粗样式**](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/2cc73b3ca3c64c9fa2fdda7446895264-168101978753256-168101979040258.png)

ARP应答构建完成后，为了能将ARP应答发送到以太网当中，也需要将ARP数据包向下交付给MAC帧协议，封装成MAC帧。

- 封装MAC帧报头时，以太网目的地址和以太网源地址，对应分别是路由器D和主机B的MAC地址。
- 因为这里封装的是一个ARP应答数据包，因此MAC帧当中的帧类型字段设置为0806。
- 由于ARP应答数据包的长度也只有28字节，不足46字节，因此也需要在MAC帧的有效载荷当中补上18字节的填充字段，最后再对MAC帧进行CRC校验。

此时ARP应答就被封装成MAC帧了，如下：

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/5b8aaeba6f7c40978ce65200cfe65b67-168101982564962.png)

MAC帧封装完毕后，主机B就可以将封装好的MAC帧发送到局域网当中了。

- 此时局域网当中的每台主机在底层都能收到这个MAC帧，但局域网当中的不相干的主机，在发现该MAC帧对应的以太网目的地址与自己不同后，就会将该MAC帧丢弃，而不会交付给上层ARP层，**最终只有路由器D会将解包后MAC帧的有效载荷向上交付给自己的ARP层。**
- 当路由器D的ARP层收到这个数据包后，发现ARP数据包当中的op字段为2，于是判定这是一个ARP应答，然后就会提取出ARP数据包当中的发送端以太网的地址和发送端IP地址，此时路由器D就拿到了主机B的MAC地址。

需要注意的是，局域网当中其他不相干的主机在收到这个ARP应答报文后，直接在MAC帧层就丢弃了，并没有将其交付给自己的ARP层。

**广播ARP请求，在ARP协议层丢包；单播ARP响应，在MAC协议层丢包**。

#### ARP缓存表

实际不是每次要获取对方的MAC地址时都需要发起ARP请求，每次发起ARP请求后都会建立对应主机IP地址和MAC地址的映射关系，每台主机都维护了一个ARP缓存表，我们可以用`arp -a`命令进行查看。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/372c776d014f48958db67fad41891710-168102001107166.png)

需要注意的是，**缓存表中的表项有过期时间**，这个时间一般为20分钟，如果20分钟内没有再次使用某个表项，那么该表项就会失效，下次使用时就需要重新发起ARP请求来获得目的主机的硬件地址。

**MAC帧的报头当中已经涵盖了源和目的MAC地址，为什么ARP的报头当中还要有这两个字段？**

> - 需要注意的是，MAC帧和ARP虽然都在数据链路层，但毕竟是上下层的关系，因此它们不会互相关心彼此报头当中的数据。
> - 此外，如果底层网络采用的不是以太网，而是其他类型的网络，此时ARP层的MAC地址就是必要的了。

**在进行局域网通信时，为什么不直接以广播的方式发送数据？**

> 在进行局域网通信时，就算只知道对方的IP地址，而不知道对方的MAC地址，也可以以广播的方式将数据发送到局域网当中，此时局域网当中的主机也能够**在IP层比对目的IP地址与自己是否相符，来判断收到的这个数据是否是发送给自己的**。
>
> 理论上确实可以这样，但这种方式是不妥的。
>
> - 对于局域网当中的大多数主机来说，收到的这个报文其实早就应该被丢弃，而现在这个报文却交付到了IP层，我们都知道IP层是属于操作系统管控的，因此**这对网络资源和系统资源来说都是一种浪费**。
> - 因此在底层MAC帧层就应该判定这个报文是不是发送给当前主机的，而不是当数据向上交付到了IP层再来判断。
>
> 此外，如果无脑使用广播的方式来进行数据的发送，会使得广播和单播的概念变得模糊不清，你明明是想发送数据给局域网当中的一台主机，但你却采用了广播的方式，这显然是不合理的。

**什么时候需要发起ARP请求？**

> 我们刚才说的只是路由器D要将数据发送给主机B的时候，需要通过ARP获得主机B的MAC地址，但实际数据在路由过程中的每一跳可能都需要发起ARP请求，询问下一跳主机对应的MAC地址，因为在每一跳时我们一般都是只知道下一跳的IP地址，而并不知道其对应的MAC地址的。
>
> 注意： **ARP属于局域网通信的协议标准**，因此一台主机不能跨网络向另一台主机发起ARP请求。

#### 小结

MAC帧被广播给局域网的所有主机，因为是ARP协议类型，提交给ARP协议，ARP判断是应答还是请求。如果是请求，ARP对比目的IP，是就返回给源MAC一个一对一的应答，不是就丢弃。应答是一对一的，是应答就提取发送端的IP/MAC保存下来

ARP缓存表

路由器之间需要ARP

ARP欺骗

### RARP协议

**RARP**（Reverse Address Resolution Protocol，反向地址转换协议），是根据MAC地址获取IP地址的一个TCP/IP协议。

也就是说，某些情况下我们可能只知道一台主机的MAC地址，此时要得知该主机的IP地址就可以使用RARP协议。

理论上来说，RARP协议一定比ARP协议简单，因为既然我们已经知道一台主机的MAC地址了，那么我们就已经可以直接向给主机发送消息了，因此我们可以直接发消息询问对方的IP地址就行了。

### DNS

#### 理论

**DNS（Domain Name System，域名系统）协议**，是一个用来将域名转化为IP地址的应用层协议。

TCP/IP中通过IP地址和端口号的方式，来确定网络中一个主机上的一个程序。但IP地址是一长串数字，并不便于人们记忆，于是人们发明了一种叫做主机名的东西，并用hosts文件夹来描述主机名和IP地址之间的对应关系。

最初，这个hosts文件是由互联网信息中心（SRI-NIC）来管理的。

- 如果一个新计算机要接入网络，或者某个计算机IP变更，都需要到信息中心申请变更hosts文件。
- 其他计算机也需要定期下载更新新版本的hosts文件才能正确上网。
- 当用户通过域名访问互联网服务时，会先通过域名在本地的hosts文件中找到其对应的IP地址，然后再用这个IP地址去访问对应的服务。

但这样太麻烦了，于是产生了DNS系统。

- 由一个组织的系统管理机构，维护系统内的每个主机的IP和主机名的对应关系。
- 如果新计算机要接入网络，或者某个计算机IP变更，就需要将对应信息注册到数据库中。
- 当用户通过域名访问互联网服务时，会自动查询DNS服务器，由DNS服务器检索数据库，得到对应的IP地址。

至今，我们的计算机上仍然保留了hosts文件，这个hosts文件当中一般存储的是主机名与IP地址之间的映射，用户也可以在hosts文件中自主添加域名和IP映射关系，在域名解析的过程中会优先查找hosts文件的内容。

通过cat /etc/hosts可以查看hosts文件当中的内容。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/8b1068da58ca45be8cbe8effac167df7-168102039515870.png)

#### 域名简介

域名是用来识别主机名称和主机所属的组织机构的一种分层结构的名称，例如`www.baidu.com`。

- com：一级域名，表示这是一个工商企业域名。同级的还有.net（网络提供商）和.org（开源组织或非盈利组织）等。
- baidu：二级域名，一般对应的就是公司名。
- www：只是一种习惯用法，之前人们在使用域名时，往往命名成类似于`ftp.xxx.xxx/www.xxx.xxx`这样的格式，来表示主机支持的协议。

#### 域名解析过程

在浏览器中输入url后，如果url当中包含域名，则需要进行域名解析。

- 首先会在**浏览器的DNS缓存**中去查询是否有对应的记录，如果查询到记录就可以直接得到对应的IP地址，则完成解析。
- 如果在浏览器的DNS缓存中没有找到，就会去查询**操作系统中的DNS缓存**，如果查询到对应的IP地址，则完成解析。
- 如果在操作系统的DNS缓存中没有找到，就会去查找**本地的hosts文件**，如果查询到对应的IP地址，则完成解析。
- 如果在本地的hosts文件中也没有找到，就会去**本地DNS服务器**中查找。本地DNS服务器IP地址一般由本地网络服务商提供，如电信、移动等公司，一般通过DHCP自动分配。目前使用的比较多的是谷歌提供的公用NDS 8.8.8.8和国内公用DNS 114.114.114.114。如果在本地DNS服务器中有对应域名的缓存，直接返回对应的IP地址，则完成解析。
- 如果本地DNS服务器中仍然没有找到，那么本地DNS服务器就会拿着域名去**根DNS服务器**中询问，根DNS服务器会告诉本地DNS顶级域名服务器的IP地址。
- 本地DNS拿到顶级域名服务器的IP地址后，就会拿着域名去找**顶级DNS服务器**，顶级域名服务器会告诉本地DNS权威域名服务器的IP地址。
- 本地DNS服务器拿着域名去**权威域名服务器**中，查询域名对应的IP地址，最终将该域名对应的IP地址返回给浏览器，此时整个域名解析过程就完成了。
- ![image-20230409140944720](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230409140944720-168102058647174.png)
    ![image-20230723103754423](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230723103754423.png)

#### 使用dig工具分析DNS过程

我们可以使用dig工具来查看域名解析的过程，例如查看百度域名`www.baidu.com`的解析过程。

dig工具的分析结果如下：

![dig www.baidu.com](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/b11c3f6770084016a58729abaf91c315.png)

结果解释：

- 开头位置是dig工具的版本号。
- 第二部分是服务器返回的详情，其中status参数为NOERROR表示查询成功。
- QUESTION SECTION表示待查询的域名。
- ANSWER SECTION表示查询的结果，首先`www.baidu.com`被查询成了`www.a.shifen.com`，而最终`www.a.shifen.com`被查询成了两个具体的IP地址。
- 最下面是一些结果统计，包含查询时间和DNS服务器的地址等。

#### 小结

**应用层**的域名解析协议

域名 -- IP  的映射关系

域名解析过程

在浏览器中输入url后，如果url当中包含域名，则需要进行域名解析。

**浏览器输入url后发生的事儿：一次点击背后的故事▲** 

dig工具

### ICMP

**ICMP（Internet Control Message Protoco）Internet控制报文协议**，用于在IP主机、路由器之间传递控制信息，是一个TCP/IP协议。

#### ICMP协议的定位

在TCP/IP四层模型中，网络协议栈自顶向下分为应用层、传输层、网络层和数据链路层。

其中应用层最典型的协议有HTTP、HTTPS和DNS等，传输层最典型的协议有TCP和UDP，网络层最典型的协议就是IP，数据链路层最典型的协议就是MAC帧协议，但实际网络层还有两种协议叫做ICMP和IGMP。
![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/a43fa77dd53a4758a9ebe280ee4771e1-168102082080476-168102082672879.png)

ICMP、IGMP和IP协议虽然都属于网络层的协议，但ICMP协议和IGMP协议属于IP的上层协议。

- 也就是说，**IP的上层协议不一定就直接是传输层的协议**，IP的上层协议有可能也属于网络层的协议，但就是位于IP的上层。
- 与之类似的，数据链路层当中的ARP协议和RARP协议，这两个协议虽然与MAC帧协议都属于数据链路层，但这两个协议属于MAC帧的上层协议。

#### ICMP功能

**ICMP的主要功能包括：**

- **确认IP包是否成功到达目标地址。**
- **通知在发送过程中IP包丢弃的原因。**
- **ICMP只能搭配IPv4使用，如果是IPv6的情况下，需要使用ICMPv6。**

**举个例子**

> 比如当主机A在向主机B发送数据的过程中，主机B因为某些原因已经离线了。
>
> ![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/7b9cc5b0093c40ae94a299cad95319eb-168102090118983.png)
>
> 当发送的数据包到达主机B所在局域网的入口路由器时，入口路由器为了获得主机B的MAC地址，于是会向主机B发送ARP请求包，但由于主机B已经离线了，因此路由器在多次发送ARP请求包而得不到响应后，就会返回一个ICMP Destination Unreachable的包给主机A，此时主机A就知道自己发送的数据无法到达主机B。

#### ICMP协议格式

ICMP协议格式如下：
![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/87dca313a19e49738d06a4957503ae1f.png)

ICMP大概分为两类报文。

- 一类是通知出错原因的。
- 一类是用于诊断查询的。

ICMP包常见类型如下：

![image-20230409141539995](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230409141539995-168102094196587.png)

#### ping命令

**ping命令是基于ICMP协议实现的**，通常用于测试本地主机与另一台主机之间的通信信道是否正常。

例如，使用`ping www.baidu.com`命令，测试本地主机与百度服务器之间的通信信道是否正常。
![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/a214c53ffbf3452881a4f00e91fc6384-168102095772991.png)

- 注意，此处ping的是百度的域名，该域名会由DNS解析成IP地址。
- ping命令不仅能验证网络的连通性，同时也会统计响应时间和TTL（IP包中的Time To Live，生存时间）。
- ping命令会先发送一个ICMP Echo Request给对端。
- 对端接收到之后，会返回一个ICMP Echo Reply。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/e238aa8f91994c4997288cb09482aa8c-168102098426695.png)

#### 一个值得注意的坑

**telnet对应的端口号是23，ssh对应的端口号是22，那ping对应的端口号是多少？**

> 这是问问题的人设的一个圈套，ping命令是基于网络层的ICMP协议，而端口号是属于传输层的内容，因此ICMP协议根本就不关心端口号这样的信息。
>
> ![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/8ad5251b83b44a3ca9b1cf4b15c968aa-1681021255899101.png)
>
> 因此，ping命令实际是绕过了传输层的（没有经过传输层，使用的是IP协议），在Linux当中实际也有绕过传输层的一套网络编程接口，叫做原生套接字。
>
> [][(3条消息) Ping 命令详解_hebbely的博客-CSDN博客][ping详解](https://blog.csdn.net/hebbely/article/details/54965989)

#### traceroute命令

traceroute命令也是基于ICMP协议实现的，traceroute命令可以遍历数据包传送到目标主机所经过的所有路由器。

例如，使用`traceroute www.baidu.com`命令，遍历数据包传送到百度服务器所经过的所有路由器。

![---](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/9c8d4bbcab784a66aeb4ab02f5cdc730-1681021432683105.png)

原理简述：

- traceroute命令底层实际是通过增加存活时间（TTL）值来实现的。
- 因为每当数据包经过一个路由器，其TTL值就会减1，当TTL值减为0时对应路由设备就会将该数据包丢弃，并传送一个ICMP TTL数据包给发送主机。
- 因此traceroute命令底层可以发出多个数据包，并给这些数据包设置不同的TTL值，最后该主机就能够得到一连串的数据包路径。

### NAT

> NAT（Network Address Translation，网络地址转换）技术，是**解决IP地址不足的主要手段**，
>
> 并且能够**有效地避免来自网络外部的攻击**，隐藏并保护网络内部的计算机。

#### NAT技术背景

在IPv4协议中，IP地址数量不足是一个大问题，而NAT技术就是当前解决IP地址不够用的主要手段，是路由器的一个重要功能。

- 在进行对外通信时，NAT能够将私有IP经过一系列替换操作最终转为全局IP，也就是说，NAT是一种将私有IP和全局IP相互转化的技术方法。
- 装有NAT软件的路由器叫做NAT路由器，所有使用私有IP的主机在和外界通信时，都要在NAT路由器上将其私有IP转换成全局IP。
- 很多学校、家庭、公司内部每个终端设置的IP都是私有IP，而只在路由器或必要的服务器上设置全局IP。
- 全局IP要求唯一，但是私有IP不需要，在不同的局域网中出现相同的私有IP是完全不影响的。

#### NAT IP转换过程

假设某个局域网当中有A、B、C三台主机，在公网当中有一台服务器，以主机A访问公网中的这台服务器为例，我们来看看数据包在传输过程中IP地址的转换过程。

##### 数据包从局域网到公网的过程

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/76712783e9494fdfb363d14b5a29da30-1681021693603109-1681021812930111.png)

主机A向服务器发起数据请求的过程中，数据包中IP地址的转换过程如下：

- 刚开始，该数据包当中的源IP地址就是主机A的私有IP地址，目的IP地址就是服务器的公网IP地址。
- 当数据包经过NAT路由器时，**路由器会将该数据包的源IP地址替换成自己的WAN口IP地址**，此时该数据包的源和目的IP地址就都是公网IP了。
- 该数据包在互联网中经过各种路由转发，最终到达服务器主机。

服务器收到主机A的数据请求并处理后，就会对主机A发来的请求进行响应。

##### 数据包从公网到局域网的过程

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/8ef0da244d5e4559ab8993335ced72ba-1681021851913115.png)

服务器向主机A进行响应的过程中，数据包中IP地址的转换过程如下：

- 刚开始，该数据包当中的源IP地址就是服务器的公网IP地址，目的IP地址就是路由器的WAN口IP地址。
- 数据包在互联网中经过各种路由转发，到达主机A所在局域网的NAT路由器，此时路由器会将该数据包的目的IP地址替换成主机A的私有IP地址。
- 最终路由器就会将该数据包转发给局域网中的主机A。

需要注意的是，因为主机A向服务器发起数据请求时，该数据包当中的源IP地址被替换成了NAT路由器的WAN口IP地址，相当于是该路由器代替主机A向服务器发起了数据请求，因此服务器发出的响应数据包的目的IP地址应该是NAT路由器的WAN口IP地址。

#### NAPT

##### 地址转换表

- 当局域网当中的主机要访问外网时，NAT路由器会将这些数据包的源IP地址替换成自己的WAN口IP地址。
- 当外网发来响应数据时，NAT路由器又会将响应数据包的目的IP地址替换成局域网中对应主机的IP地址。

那NAT路由器是如何判断，应该将从外网收到的响应数据包转发给局域网中的哪一台主机呢？

- 实际在NAT路由器内部，有一张自动生成的，用于地址转换的表。
- 该转换表中维护的就是局域网中主机的私有IP，与其对应访问的外网当中的某个公网IP之间的映射关系。
- 局域网中的主机第一次向外网发起数据请求时，就会生成表中的映射关系。
- 比如在TCP建立连接时，会建立对应的映射关系，在TCP断开连接后，就会删除对应的映射关系。

在刚才的例子中，主机A第一次向服务器发起数据请求时，路由器中就会建立以下映射关系。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/ee33dcfdec134002b52f633386a9b255-1681022281725119.png)

当NAT路由器收到服务器向主机A发来的响应数据时，就可以通过查表得知该响应数据是发送给局域网当中的主机A的。

但如果转换表中维护的只是局域网中主机的私有IP，与其对应访问的外网当中的某个公网IP之间的映射关系，那么就会出现某些问题。

如果局域网中的主机A和主机B同时都在访问该服务器，那么此时转换表中就会建立如下两对映射关系：

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/0e1e6dc2212e4903b24f06a407a42e32-1681022304855123-1681022307716125.png)

此时这张转换表只能保证从左到右的唯一性，而不能保证从右到左的唯一性，当服务器发来响应数据时，该数据包中的目的IP地址都是路由器的WAN口IP，此时NAT路由器就无法判断该数据包应该转发给主机A还是主机B，此时就需要用到NAPT技术。

##### NAPT

**NAPT（Network Address Port Translation，网络地址端口转换），可以将多个内部地址映射为一个合法公网地址。**

- 当局域网中的主机向外网发送数据时，路由器会将该数据包的源IP地址替换为自己的WAN口IP地址，并建立该主机私有IP与其对应访问的公网IP之间的映射关系。
- 但如果局域网中的多台主机同时访问同一个外网服务，当路由器收到外网发来的响应数据时，路由器无法判断该响应数据应该转发给局域网中的哪台主机，因为该局域网中所有主机的数据包都由路由器代替发送了，因此发来的响应数据包的目的IP地址都是路由器的WAN口IP地址。
- 于是NAPT在建立转换表的映射关系时，除了建立局域网中私有IP与其对应访问的公网IP之间的映射关系外，还会加上一个由NAT路由器选定的端口号。
- 此时当局域网中的多台主机同时访问同一个外网服务时，虽然外网发来的响应数据的目的IP地址都是路由器的WAN口IP，但发给局域网中不同主机的响应数据对应的目的端口号是不同的，此时路由器就能通过IP+Port的方式来区分发给不同主机的数据包。

比如局域网中的主机A和主机B都在访问同一个服务器，并且它们访问服务器时采用的端口号都是1025。

- 假设主机A发送的数据包先到达路由器，此时路由器将数据包的源IP地址替换成自己的WAN口IP地址，由于路由器用于访问该服务器的1025号端口没有被使用，因此该数据包的源端口号可以不变。
- 当主机B发来的数据包到达路由器时，路由器同样将数据包的源IP地址替换成自己的WAN口IP地址，但此时路由器用于访问该服务器的1025号端口已经被主机A使用了，因此路由器会重新选定一个端口号对数据包的源端口号进行替换。

此时转换表中就会建立如下两队映射关系：

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/08cda2cf3d3e45ce9865bf6e40842dac-1681022424575129.png)

此时这张转换表既能保证从左到右的唯一性，也能保证从右到左的唯一性。

当服务器发来的响应数据到达路由器时，虽然服务器发给主机A和主机B的数据包对应的目的IP地址是一样的。
但路由器是用自己的1025号端口代替主机A进行数据请求的，而用的是1026号端口代替主机B进行数据请求的。
因此现在路由器可以继续根据数据包的源端口号，来判断应该将该数据包转发给主机A还是主机B，进行对数据包中的目的IP地址和目的端口号进行替换，然后转发给局域网内对应的主机。

##### 谈谈路由器

路由器是工作在网络层的一个设备，负责将数据包从一个网络转发到另一个网络，但**不能狭义的认为路由器只能工作在网络层**。

- NAT路由器在进行数据转发时，不仅有能力替换数据包的源和目的IP地址，而且**在必要的情况下还可能会替换数据包的源和目的端口号，而端口号实际是传输层的概念。**
- **为了对IP地址进行动态管理，大部分路由器都带有DHCP功能**，而DHCP实际是应用层的一个协议。

因此现在的路由器其实并不仅仅提供网络层相关的服务，网络协议栈中的各层路由器可能都有涉及。

#### NAT技术的缺陷

NAT技术进行私有IP和公网之间的替换，主要就是依赖NAT路由器当中维护的网络地址转换表，但这张转换表也体现出了NAT的一些缺陷：

- 无法从NAT外部向内部服务器建立连接，因为外部无法知道内部的私网IP，也就无法主动与内部服务器建立连接。
- 转换表的生成和销毁都需要额外开销。
- 通信过程中一旦NAT设备异常，即使存在热备，所有的TCP连接也都会断开。

#### 代理服务器

> 代理服务器（Proxy Server）的功能就是代理网络用户去取得网络信息，代理服务器又分为正向代理和反向代理。

##### 正向代理

正向代理，是一个位于客户端和目标服务器之间的服务器，客户端并不直接访问目标服务器，而是先访问代理服务器，由代理服务器代替客户端去访问对应的目标服务器，并将目标服务器的响应结果返回给客户端。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/fa2a4417f3db43b9977e16564e5d2f68-1681022801606133.png)

比如公司内部一般都会有自己的服务器，当我们使用公司内网上网时。

- 我们对外网发起的数据请求，首先会转发到公司的这台服务器上，然后由公司的这台服务器代替你对外网进行访问。
- 当公司的服务器收到对应外网的响应数据后，再由公司的这台服务器将数据转发给你。

正向代理的好处：

- 正向代理最大的一个好处就是可**以加速资源访问**。比如公司中大量员工都要访问外网的同一个资源，那么正向代理服务器就可以将对应的资源缓存到本地，此时当其他人要访问该资源时，直接在正向代理服务器就可以获取，而不需要再次进行外网访问。
- 管理

##### 反向代理

反向代理，也是一个位于客户端和目标服务器之间的服务器，对于客户端而言，反向代理服务器就相当于目标服务器，用户不需要知道目标服务器的地址，用户只需要访问反向代理服务器就可以获得目标服务器提供的服务。

反向代理，也是一个位于客户端和目标服务器之间的服务器，客户端直接向反向代理服务器发起数据请求，然后再由反向代理服务器将客户端的数据请求转发给真正的目标服务器进行处理，数据处理完毕后反向代理服务器再将数据结果返回给客户端。

![在这里插入图片描述](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/2e5480ca4480423ca90e62a715f2e08d-1681022896283137.png)

比如域名`www.baidu.com`对应的服务器实际就是一个反向代理服务器。

- 百度内部实际并不是只有一台服务器，但不同地区的人们都可以通过访问`www.baidu.com`享受到百度提供的服务，实际我们访问的就是百度的反向代理服务器。
- 当这台反向代理服务器收到客户端的数据请求后，就会将我们的数据请求转发给百度内部的某台服务器进行数据处理，然后再将数据处理的结果返回给客户端。

反向代理的好处：

- **反向代理可以起到负载均衡的作用**。比如不设置反向代理服务器，那么用户在访问百度时，就会随机访问到百度内部的某台服务器，此时就可能导致某些服务器压力太大，而某些服务器却处于闲置状态。而设置了反向代理服务器后，我们就能够通过某些方法让用户的数据请求较为平均的落到每台服务器上。
- **反向代理还能起到安全防护的作用**。有了方向代理服务器后，我们不需要直接将提供服务的服务器对应的信息暴露出去，此外，当由非法请求发送到反向代理服务器时，反向代理服务器就相当于一层软件屏障，可以在反向代理服务器当中部署一些防护措施，让这些非法请求在反向代理服务器这里就被过滤掉，而不会影响内部实际提供服务的服务器。

需要注意的是，代理服务器的主要工作只是对数据进行转发，因此代理服务器处理数据的压力不会特别大，并且代理服务器也可以有多个，因此不必担心代理服务器过载的情况。

##### 正向代理和反向代理的异同

正向代理和反向代理的相同点：

- 正向代理服务器和反向代理服务器都是位于客户端和服务器之间的。
- 正向代理服务器和反向代理服务器的主要工作，都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端

正向代理和反向代理的不同点：

- 正向代理是客户端的代理，帮助客户端访问其无法访问的服务器资源的，而反向代理则是服务器的代理，帮助服务器做负载均衡、安全防护等工作的。
- 正向代理一般是客户端架设的，比如公司的正向代理服务器是公司作为客户端架设的，而反向代理一般是服务端架设的，比如百度的反向代理服务器是百度作为服务端架设的。
- 正向代理中，服务器不知道真正的客户端到底是谁，服务器认为正向代理服务器就是真实的客户端，而反向代理中，客户端不知道真正的服务器是谁，客户端认为反向代理服务器就是真实的服务器。

> 正向代理中，客户端请求数据和接收数据都是通过正向代理服务器进行的
>
> ![image-20230409145314951](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230409145314951-1681023196755139.png)
>
> 反向代理中，客户端请求数据是通过反向代理服务器进行的，但接收数据时，接收到的是真正服务器发送的数据。
>
> ![image-20230409145357181](%E5%9B%BE%E7%89%87/%E7%BD%91%E7%BB%9C/image-20230409145357181-1681023239769141.png)

##### NAT和代理服务器的区别

- 从应用上讲，NAT设备是网络基础设备之一，解决的是IP不足的问题，而代理服务器则是更贴近具体应用，比如通过代理服务器进行翻墙，另外像迅游这样的加速器，也是使用的代理服务器。
- 从底层实现上讲，NAT工作在网络层，直接对IP地址进行替换，而代理服务器往往工作在应用层。
- 从使用范围上讲，NAT一般在局域网的出口部署，而代理服务器可以在局域网代理，也可以在广域网代理，也可以跨网代理。
- 从部署位置上看，NAT一般集成在防火墙、路由器等硬件设备上，而代理服务器则是一个软件程序（比如Nginx和Apache），需要部署在服务器上。

#### 小结

不止IP会被替换，源端口号也可以被替换

四元组维护

内网穿透

正向代理/反向代理

访问外网/加速器/VPN 原理



## 网络协议总结

###### 应用层

- 应用层的作用：负责应用程序间沟通，完成一系列业务处理所需服务。
- 能够根据自己的需求，设计对应的应用层协议。
- 了解HTTP协议。
- 理解DNS的原理和工作流程。

###### 传输层

- 传输层的作用：负责为两个网络通信进程之间的通信提供服务，更多的是为数据的传输提供一些策略。
- 理解端口号的概念。
- 认识TCP协议，理解TCP协议的可靠性，理解TCP协议的状态转化。
- 掌握TCP的连接管理、确认应答、超时重传、滑动窗口、流量控制、拥塞控制、延迟应答、捎带应答特性。
- 理解TCP面向字节流，理解粘包问题和解决方案。
- 能够基于UDP实现可靠传输。
- 理解MTU对UDP/TCP的影响。

###### 网络层

- 网络层的作用：在复杂的网络环境中确定一条合适的路径。
- 理解IP地址，理解IP地址和MAC地址的区别。
- 理解IP协议格式。
- 理解如何解决IP数目不足的问题，掌握网段划分的两种方案，理解私有IP和公网IP。
- 理解网络层的IP地址路由过程，理解一个数据包如何跨网段到达最终目的地。
- 理解IP数据包分片的原因。
- 了解ICMP协议。
- 了解NAT设备的工作原理。

###### 数据链路层

- 数据链路层的作用：负责局域网内两个设备之间的数据传递。
- 理解以太网通信原理
- 以太网帧格式。
- 理解MAC地址。
- 理解ARP协议。
- 理解MTU。